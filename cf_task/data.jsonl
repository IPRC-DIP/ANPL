{"id": 1490, "question": "In Berland recently a new collection of toys went on sale. This collection consists of 10^9 types of toys, numbered with integers from 1 to 10^9. A toy from the new collection of the i-th type costs i bourles.\n\nTania has managed to collect n different types of toys a_1, a_2, ..., a_{n} from the new collection. Today is Tanya's birthday, and her mother decided to spend no more than m bourles on the gift to the daughter. Tanya will choose several different types of toys from the new collection as a gift. Of course, she does not want to get a type of toy which she already has.\n\nTanya wants to have as many distinct types of toys in her collection as possible as the result. The new collection is too diverse, and Tanya is too little, so she asks you to help her in this.\n\n\n-----Input-----\n\nThe first line contains two integers n (1 \u2264 n \u2264 100 000) and m (1 \u2264 m \u2264 10^9)\u00a0\u2014 the number of types of toys that Tanya already has and the number of bourles that her mom is willing to spend on buying new toys.\n\nThe next line contains n distinct integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the types of toys that Tanya already has.\n\n\n-----Output-----\n\nIn the first line print a single integer k\u00a0\u2014 the number of different types of toys that Tanya should choose so that the number of different types of toys in her collection is maximum possible. Of course, the total cost of the selected toys should not exceed m.\n\nIn the second line print k distinct space-separated integers t_1, t_2, ..., t_{k} (1 \u2264 t_{i} \u2264 10^9)\u00a0\u2014 the types of toys that Tanya should choose.\n\nIf there are multiple answers, you may print any of them. Values of t_{i} can be printed in any order.\n\n\n-----Examples-----\nInput\n3 7\n1 3 4\n\nOutput\n2\n2 5 \n\nInput\n4 14\n4 6 12 8\n\nOutput\n4\n7 2 3 1\n\n\n\n-----Note-----\n\nIn the first sample mom should buy two toys: one toy of the 2-nd type and one toy of the 5-th type. At any other purchase for 7 bourles (assuming that the toys of types 1, 3 and 4 have already been bought), it is impossible to buy two and more toys.", "solutions": "[\"n, m = map(int, input().split())\\na = list(map(int, input().split()))\\na.sort()\\ns = 0\\ncount = 1\\ni = 0\\nanswer = []\\nwhile i < len(a) and s <= m:\\n    if a[i] == count:\\n        i += 1\\n        count += 1\\n    else:\\n        s += count\\n        answer.append(count)\\n        count += 1\\nif s > m:\\n    s = s - count + 1\\n    print(len(answer) - 1)\\n    for i in range(len(answer) - 1):\\n        print(answer[i], end = ' ')\\nelif s == m:\\n    print(len(answer))\\n    for i in range(len(answer)):\\n        print(answer[i], end = ' ')\\nelse:\\n    while s <= m:\\n        s += count\\n        answer.append(count)\\n        count += 1\\n    if s == m:\\n        print(len(answer))\\n        for i in range(len(answer)):\\n            print(answer[i], end = ' ')\\n    else:\\n        s = s - count + 1\\n        print(len(answer) - 1)\\n        for i in range(len(answer) - 1):\\n            print(answer[i], end = ' ')\", \"def main():\\n    n, m = map(int, input().split())\\n    mas = list(map(int, input().split()))\\n    mas.sort()\\n    mas.append(int(1e9))\\n    ans = 0\\n    res = []\\n    ind = 0\\n    for i in range(1, int(1e9)):\\n        if m < i:\\n            break\\n        if mas[ind] == i:\\n            ind += 1\\n        else:\\n            ans += 1\\n            m -= i\\n            res.append(i)\\n    print(ans)\\n    print(*res)\\n\\n\\nmain()\", \"#!/usr/bin/env python3\\n\\nread_ints = lambda : list(map(int, input().split()))\\n\\ndef solve(n, m, s):\\n    ans = []\\n    i = 1\\n    while m -i >= 0:\\n        if i not in s:\\n            m -= i\\n            ans.append(i)\\n        i+=1\\n    return ans\\n\\ndef __starting_point():\\n    n, m = read_ints()\\n\\n    s = set(read_ints())\\n    ans = solve(n, m, s)\\n    print(len(ans))\\n    for a in ans:\\n        print(a, end=\\\" \\\")\\n__starting_point()\", \"a = input().split()\\nn = int(a[0])\\nm = int(a[1])\\nd={}\\nfor i in input().split():\\n    d[int(i)]=1\\n\\nans = []\\n\\ncnt = 1\\nwhile m>0:\\n    if m-cnt<0:\\n        break\\n    if(d.get(cnt)==None):\\n        ans.append(cnt)\\n        m-=cnt\\n    cnt+=1\\n\\nprint(len(ans))\\nfor i in ans:\\n    print(i,' ',sep='',end='')\\n\", \"n,m = map(int, input().split())\\nA = list(map(int, input().split()))\\nA.sort()\\nA.append(10**9+1)\\nB = []\\nanswer = 0\\ncou = 0\\nper = 1\\nper2 = True\\nfor i in range(n+1):\\n    if per2 == False:\\n        break\\n    while per != A[i]:\\n        \\n        answer+=per\\n        if answer <= m:\\n            cou+=1\\n            B.append(per)\\n        else:\\n            print(cou)\\n            print(' '.join(map(str, B)))\\n            per2 = False\\n            break\\n        per+=1\\n        \\n    per+=1\", \"n, m = list(map(int, input().split()))\\na = set(map(int, input().split()))\\nret = list()\\nt = 1\\nwhile True:\\n    if m < t:\\n        break\\n    if t not in a:\\n        m -= t\\n        ret.append(t)\\n    t += 1\\nprint(len(ret))\\nif ret:\\n    print(\\\" \\\".join(map(str, ret)))\\n\", \"n, m = list(map(int, input().split(' ')))\\na = sorted(list(map(int, input().split(' '))))\\n\\nb = []\\nj = 0\\nfor i in range(1, 10 ** 9 + 1):\\n    if i > m:\\n        break\\n    if i <= m and (j >= n or i != a[j]):\\n        b.append(i)\\n        m -= i\\n    if j < n and i == a[j]:\\n        j += 1\\n\\nprint(len(b))\\nprint(' '.join(map(str, b)))\\n\", \"n, m = tuple(map(int, input().split()))\\na = set(map(int, input().split()))\\nans = []\\nfor x in range(1, 10**9 + 1):\\n    if m < x:\\n        break\\n    if x not in a:\\n        ans.append(x)\\n        m -= x\\nprint(len(ans))\\nprint(\\\" \\\".join(map(str, ans)))\\n\", \"#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n\\nimport time\\n\\n(n, m) = (int(i) for i in input().split())\\na      = sorted([int(i) for i in input().split()])\\n\\nstart = time.time()\\n\\n\\nacc = 0\\nans = []\\n\\nj   = 0\\nsum = 0\\n\\nfor i in range(1, 1000000001):\\n    if j < n:\\n        if i == a[j]:\\n            j +=1\\n            continue\\n\\n    if sum+i > m:\\n        break\\n\\n    sum += i\\n    acc += 1\\n    ans.append(i)\\n\\nprint(acc)\\nfor i in range(acc):\\n    print(ans[i], end=' ')\\nprint()\\n\\n#finish = time.time()\\n#print(finish - start)\\n\", \"3\\n\\nclass StdIO:\\n\\tdef read_int(self):\\n\\t\\treturn int(self.read_string())\\n\\n\\tdef read_ints(self, sep=None):\\n\\t\\treturn [int(i) for i in self.read_strings(sep)]\\n\\n\\tdef read_float(self):\\n\\t\\treturn float(self.read_string())\\n\\n\\tdef read_floats(self, sep=None):\\n\\t\\treturn [float(i) for i in self.read_strings(sep)]\\n\\n\\tdef read_string(self):\\n\\t\\treturn input()\\n\\n\\tdef read_strings(self, sep=None):\\n\\t\\treturn self.read_string().split(sep)\\n\\nio = StdIO()\\n\\n\\ndef main():\\n\\tn, m = io.read_ints()\\n\\ta = io.read_ints()\\n\\ta.sort()\\n\\n\\thas = set()\\n\\tfor ai in a:\\n\\t\\thas.add(ai)\\n\\n\\tt = []\\n\\n\\tmu = 0\\n\\tfor i in range(1, a[0]):\\n\\t\\tif mu + i > m:\\n\\t\\t\\tbreak\\n\\n\\t\\t# print(i, end=' ')\\n\\t\\tt.append(i)\\n\\t\\tmu += i\\n\\n\\tfor i in range(a[0], a[-1]):\\n\\t\\tif mu + i > m:\\n\\t\\t\\tbreak\\n\\n\\t\\tif i not in has:\\n\\t\\t\\t# print(i, end=' ')\\n\\t\\t\\tt.append(i)\\n\\t\\t\\tmu += i\\n\\n\\tfor i in range(a[-1] + 1, 10**9):\\n\\t\\tif mu + i > m:\\n\\t\\t\\tbreak\\n\\n\\t\\t# print(i, end=' ')\\n\\t\\tt.append(i)\\n\\t\\tmu += i\\n\\n\\tprint(len(t))\\n\\tfor ti in t:\\n\\t\\tprint(ti, end=' ')\\n\\n\\ndef __starting_point():\\n\\tmain()\\n\\n__starting_point()\", \"n, m = map(int, input().split())\\nx = set(map(int, input().split()))\\nanswer = []\\ni = 1\\nwhile True:\\n    if i > m:\\n        break\\n    if i in x:\\n        i += 1\\n        continue\\n    else:\\n        answer.append(i)\\n        m -= i\\n        i += 1\\nprint(len(answer))\\nprint(' '.join(map(str, answer)))\", \"n,m=(int(z) for z in input().split())\\ns=[int(z) for z in input().split()]\\nt=set(s)\\nq=0\\ni=1\\nres=[]\\nwhile q+i<=m and i<1000000000:\\n\\tif i not in t:\\n\\t\\tq+=i\\n\\t\\tres.append(str(i))\\n\\ti+=1\\nprint(len(res))\\nprint(' '.join(res))\", \"n, m = list(map(int, input().split()))\\nhas = list(map(int, input().split()))\\nhas.sort()\\nres = []\\nuc = 0\\nfor i in range(1, 10 ** 9 + 1):\\n    if uc < len(has) and has[uc] == i:\\n        uc += 1\\n    elif m - i < 0:\\n        break\\n    else:\\n        m -= i\\n        res.append(i)\\nprint(len(res))\\nprint(*res)\\n\\n\", \"n, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\na.sort()\\na.append(10**10)\\nans = []\\ncand = 1\\nfor i in range(len(a)):\\n    while cand < a[i]:\\n        m -= cand\\n        if m < 0:\\n            print(len(ans))\\n            if len(ans) > 0:\\n                print(*ans)\\n            return\\n        ans.append(cand)\\n        cand += 1\\n\\n    cand = a[i] + 1\\n\", \"n, m = (int(x) for x in input().split())\\na = [int(x) for x in input().split()]\\na.sort()\\ni = 0\\nc = 1\\nans = []\\nn_ans = 0\\nwhile ((m > 0) and (i < n)) :\\n  if (c != a[i]) :\\n    m -= c\\n    if (m >= 0) : \\n      ans.append(c)\\n      n_ans = n_ans + 1\\n  if (c == a[i]) :\\n    i = i + 1\\n  c = c + 1\\n  \\n\\nwhile (m > 0) :\\n  m -= c\\n  if (m >= 0) : \\n    ans.append(c)\\n    n_ans = n_ans + 1\\n  c = c + 1\\n\\nprint(n_ans)\\nfor i in range(n_ans):\\n print(ans[i], ' ', sep = '', end = '')\\n                  \", \"n,m=[int(x) for x in input().split()]\\narr=[int(x) for x in input().split()]\\narr.append(1000000002)\\narr=sorted(arr)\\ncurr=0\\ni=1\\nres=[]\\nans=0\\nwhile m>=i:\\n    if i==arr[curr]:\\n        i+=1\\n        curr+=1\\n        continue\\n    ans+=1\\n    res.append(i)\\n    m-=i\\n    i+=1\\nprint(ans)\\nfor x in res:\\n    print(x,end=' ')\", \"n,m=map(int,input().split())\\ninp=list(map(int,input().split()))\\ninp=set(inp)\\ncount=1\\nst=[0]*100000\\na=0\\nwhile((m-count)>=0):\\n\\tif(not(count in inp)):\\n\\t\\tst[a]=count\\n\\t\\ta+=1\\n\\t\\tm-=count\\n\\t\\tinp.add(count)\\n\\tcount+=1\\nprint(a)\\nfor i in range(a):\\n\\tprint(st[i], end=\\\" \\\")\", \"n,m = (int(i) for i in input().split())\\nq = set(map(int,input().split()))\\ns = 0\\nk = 1\\nansv = 0\\nans = []\\nwhile s < m:\\n    \\n    if not k in q:\\n        if s+k <=m:\\n            s+=k\\n            ans+=[k]\\n            ansv+=1\\n        else:\\n            break\\n    k+=1\\n    \\n    \\nprint(ansv)\\nprint(' '.join(list(map(str,ans))))\\n\", \"n, m = map(int, input().split(' '))\\na = list(map(int, input().split(' ')))\\nb = []\\na.sort()\\nli = 0\\ni = 1\\nk = 0\\nla = len(a)\\n\\nwhile i <= m:\\n    if li < la and a[li] < i:\\n        li += 1\\n    elif li < la and a[li] == i:\\n        i += 1\\n    else:\\n        m -= i\\n        k += 1\\n        b.append(i)\\n        i += 1\\n\\nprint(k)\\nfor it in b:\\n    print(it, end=' ')\\n\", \"num,y=map(int,input().split())\\ninp1=list(map(int,input().split()))\\ninp1=set(inp1)\\ncount1=1\\ns=[0]*100000\\nb=0\\nwhile((y-count1)>=0):\\n\\tif(not(count1 in inp1)):\\n\\t\\ts[b]=count1\\n\\t\\tb+=1\\n\\t\\ty-=count1\\n\\t\\tinp1.add(count1)\\n\\tcount1+=1\\nprint(b)\\nfor j in range(b):\\n\\tprint(s[j], end=\\\" \\\")\", \"n,m=map(int,input().split())\\nls=sorted(list(map(int,input().split())))\\nsu,j,arr=0,0,[]\\nfor i in range(1,m+1):\\n    if j<n and i==ls[j]:\\n        j+=1\\n        continue\\n    su=su+i\\n    if su>m:\\n        break\\n    arr.append(i)\\n\\nprint(len(arr))\\n\\n\\nfor j in arr:\\n    print(j,end=\\\" \\\")\", \"def re():\\n    return [int(x) for x in input().split(' ')]\\n[n,m] = re()\\nus = re()\\nus.sort()\\n\\nar = []\\nk = 0\\ni = 0\\nif len(us)==0:\\n    i =1\\n    while m > 0:\\n        if m -i >= 0 and i != us[0]:\\n            ar.append(str(i))\\n            m-=i\\n            i+=1\\n        else:\\n            i+=1\\nif us[0]>1:\\n    i =1\\n    while m > 0 and i != us[0]:\\n        if m -i >=0:\\n            m-=i\\n            ar.append(str(i))\\n            i+=1\\n        else:\\n            break\\ni =0\\nwhile i < len(us)-1:\\n    for j in range(us[i]+1, us[i+1]):\\n        if m - j >=0:\\n            ar.append(str(j))\\n            m-=j\\n        else:\\n            i = len(us)\\n            break\\n    i+=1\\nif m >0 and m > us[-1]:\\n    i = us[-1]+1\\n    while m >0:\\n        if m -i >=0:\\n            m-=i\\n            ar.append(str(i))\\n            i+=1\\n        else:\\n            break\\nprint(len(ar))\\nprint(\\\" \\\".join(ar))\", \"string = input().split()\\nn = int(string[0])\\nm = int(string[1])\\ntypes = list(map(int, input().split()))\\ntypes = set(types)\\n\\n\\ncurr = 1\\nres = []\\nwhile m > 0:\\n    if m - curr < 0:\\n        break\\n    if curr not in types:\\n        m -= curr\\n        res.append(str(curr))\\n    curr += 1\\n\\nprint(len(res))\\nprint(' '.join(res))\\n\", \"n,m=map(int,input().split(' '))\\na=[int(i) for i in input().split(' ')]\\na=set(a)\\nb=[]\\ncc=0\\nlim=int(1e9)\\ni=1\\nwhile i<=m:\\n    if i not in a:\\n        cc+=1\\n        b.append(i)\\n        m-=i\\n    i+=1\\nprint(cc)\\nfor i in range(len(b)):\\n    print(b[i],end=' ')\\n\\n\"]", "input_output": "{\"inputs\": [\"3 7\\n1 3 4\\n\", \"4 14\\n4 6 12 8\\n\", \"5 6\\n97746 64770 31551 96547 65684\\n\", \"10 10\\n94125 56116 29758 94024 29289 31663 99794 35076 25328 58656\\n\", \"30 38\\n9560 64176 75619 53112 54160 68775 12655 13118 99502 89757 78434 42521 19210 1927 34097 5416 56110 44786 59126 44266 79240 65567 54602 25325 37171 2879 89291 89121 39568 28162\\n\", \"2 5\\n999999999 1000000000\\n\", \"5 5\\n100000000 200000000 300000000 400000000 1000000000\\n\", \"6 3\\n1 2 3 4 5 6\\n\", \"2 1\\n1 2\\n\", \"1 1\\n1000000000\\n\", \"5 10000\\n1000000000 888888888 777777777 666666666 959595959\\n\", \"3 1\\n1000000000 999999999 999999998\\n\", \"3 55\\n100000000 1000000000 999999999\\n\", \"2 10\\n5 10000009\\n\", \"1 1100\\n1000000000\\n\", \"1 40\\n1000000000\\n\"], \"outputs\": [\"2\\n2 5 \\n\", \"4\\n1 2 3 5 \\n\", \"3\\n1 2 3 \\n\", \"4\\n1 2 3 4 \\n\", \"8\\n1 2 3 4 5 6 7 8 \\n\", \"2\\n1 2 \\n\", \"2\\n1 2 \\n\", \"0\\n\\n\", \"0\\n\\n\", \"1\\n1 \\n\", \"140\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 \\n\", \"1\\n1 \\n\", \"10\\n1 2 3 4 5 6 7 8 9 10 \\n\", \"4\\n1 2 3 4 \\n\", \"46\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \\n\", \"8\\n1 2 3 4 5 6 7 8 \\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/659/C", "starter_code": ""}
{"id": 224, "question": "One day, the Grasshopper was jumping on the lawn and found a piece of paper with a string. Grasshopper became interested what is the minimum jump ability he should have in order to be able to reach the far end of the string, jumping only on vowels of the English alphabet. Jump ability is the maximum possible length of his jump. \n\nFormally, consider that at the begginning the Grasshopper is located directly in front of the leftmost character of the string. His goal is to reach the position right after the rightmost character of the string. In one jump the Grasshopper could jump to the right any distance from 1 to the value of his jump ability. [Image] The picture corresponds to the first example. \n\nThe following letters are vowels: 'A', 'E', 'I', 'O', 'U' and 'Y'.\n\n\n-----Input-----\n\nThe first line contains non-empty string consisting of capital English letters. It is guaranteed that the length of the string does not exceed 100. \n\n\n-----Output-----\n\nPrint single integer a\u00a0\u2014 the minimum jump ability of the Grasshopper (in the number of symbols) that is needed to overcome the given string, jumping only on vowels.\n\n\n-----Examples-----\nInput\nABABBBACFEYUKOTT\n\nOutput\n4\nInput\nAAA\n\nOutput\n1", "solutions": "[\"# You lost the game.\\n\\ns = str(input())\\nn = len(s)\\nd = -1\\nr = 0\\nV = \\\"AEIOUY\\\"\\nfor i in range(n):\\n    if V.count(s[i]):\\n        r = max(r,i-d)\\n        d = i\\nprint(max(r, n-d))\\n\", \"s = 'A' + input() + 'A'\\na = 'AEIOUY'\\nans = 0\\nlast = 0\\nfor i in range(len(s)):\\n    if s[i] in a:\\n        ans = max(ans, i - last)\\n        last = i\\nprint(ans)\\n\", \"3\\n\\nvowels = ['A', 'E', 'I', 'O', 'U', 'Y']\\ns = 'A' + input() + 'A'\\n\\narr = [i for i in range(len(s)) if s[i] in vowels]\\ndiffs = [arr[i + 1] - arr[i] for i in range(len(arr) - 1)]\\n\\nprint(max(diffs))\\n\", \"jump = ['A', 'E', 'I', 'O', 'U', 'Y']\\n\\nans = 1\\ns = input()\\nj = 1\\nfor i in s:\\n    if i in jump:\\n        ans = max(ans, j)\\n        j = 0\\n    j += 1\\nans = max(ans, j)\\nprint(ans)\", \"s = input()\\na = [0]\\nfor i in range(len(s)):\\n    if s[i] in 'AEIOUY':\\n        a.append(i + 1)\\na.append(len(s) + 1)\\nans = 0\\nfor i in range(1, len(a)):\\n    ans = max(ans, a[i] - a[i - 1])\\nprint(ans)\", \"s = \\\"A\\\" + input() + \\\"A\\\"\\nans = 0\\nprev = -1\\nfor i in range(len(s)):\\n    if (s[i] in \\\"AEIOUY\\\"):\\n        ans = max(ans, i - prev)\\n        prev = i\\nprint (ans)\", \"S = input()\\nvowels = 'AEIOUY'\\nS += 'A'\\nprev_pos = -1\\nmax_jump = 0\\nfor i, ch in enumerate(S):\\n    if ch in vowels:\\n        next_pos = i\\n        max_jump = max(max_jump, next_pos - prev_pos)\\n        prev_pos = next_pos\\nprint(max_jump)\\n\", \"field = \\\"A\\\" + input() + \\\"A\\\"\\nletters = [\\\"A\\\", \\\"E\\\", \\\"I\\\", \\\"O\\\", \\\"U\\\", \\\"Y\\\"]\\nans = 1\\nlast_let = 0\\nfor i in range(len(field)):\\n    let = field[i]\\n    if let in letters:\\n        ans = max(ans, i - last_let)\\n        last_let = i\\nprint(ans)\", \"s = input()\\na = 'AOUYEI'\\ns += 'A'\\nans = -1\\nnow = -1\\nn = len(s)\\nfor i in range(0, n):\\n    if s[i] in a:\\n        #print(i)\\n        ans = max(ans, i - now)\\n        now = i\\nprint(ans)\", \"#!/usr/bin/env python3\\n\\nfrom   functools import reduce\\nfrom   operator  import add\\nimport re\\n\\n\\ndef main():\\n    try:\\n        while True:\\n            print(reduce(max, (len(m.group()) for m in re.finditer(r\\\"[^AEIOUY]+\\\", input())), 0) + 1)\\n\\n    except EOFError:\\n        pass\\n\\n\\nmain()\\n\", \"s = input()\\na = [-1]\\nfor i in range(len(s)):\\n    if s[i] in ['A', 'E', 'I', 'O', 'U', 'Y']:\\n        a += [i]\\na += [len(s)]\\nans = -1\\nfor i in range(1, len(a)):\\n    ans = max(ans, a[i] - a[i - 1])\\nprint(ans)\", \"a = input()\\nb = ['A', 'E', 'I', 'O', 'U', 'Y']\\nm = 1\\nc = 0\\nfor i in range(len(a)):\\n    if a[i] in b:\\n        c = 0\\n    else:\\n        c += 1\\n    m = max(m, c + 1)\\nprint(m)\", \"s = input()\\na = \\\"AEUYEOI\\\"\\npos = [0]\\nfor i in range(len(s)):\\n    if s[i] in a:\\n        pos.append(i + 1)\\npos.append(len(s) + 1)\\nmax_ = pos[1] - pos[0]\\nfor i in range(2, len(pos)):\\n    max_ = max(max_, pos[i] - pos[i - 1])\\nprint(max_)\", \"s = input()\\ns = 'A' + s\\ns += 'A'\\ngl = ['A', 'E', 'I', 'O', 'U', 'Y']\\na = []\\nfor i in range(len(s)):\\n    if s[i] in gl:\\n        a.append(i)\\nans = -1\\nfor i in range(1, len(a)):\\n    ans = max(ans, a[i] - a[i - 1])\\nprint(ans)\\n\", \"import math,sys,re,itertools,pprint,collections\\nri,rai=lambda:int(input()),lambda:list(map(int, input().split()))\\n\\ns = input()\\nt = list([len(x) for x in re.split(r\\\"[AEIOUY]+\\\", s)])\\n\\nprint(max(t) + 1)\\n\", \"s = input()\\nd = ['A', 'E', 'I', 'O', 'U', 'Y']\\np = 0\\nm = 0\\nfor i in range(len(s)):\\n    if s[i] in d:\\n        if i + 1 - p > m:\\n            m = i + 1 - p\\n        p = i + 1\\nif len(s) + 1 - p > m:\\n    m = len(s)  + 1 - p\\nprint(m)\", \"s = input()\\nlast = -1\\nans = -1\\nfor i in range(len(s)):\\n    if s[i] in 'AEIOUY':\\n        ans = max(ans, i - last)\\n        last = i\\nans = max(ans, len(s) - last)\\nprint(ans)\\n\", \"s = \\\"A\\\" + input() + 'A'\\n\\ncounter = 0\\nans = 0\\nlast = 0\\n\\nfor i in range(1, len(s)):\\n    if s[i] in \\\"AEIOUY\\\":\\n        counter = i - last\\n        last = i\\n        if counter > ans:\\n            ans = counter\\n\\nprint(ans)\\n\", \"s = input()\\n\\nans = 1\\ncnt = 0\\nfor c in s:\\n\\tcnt += 1\\n\\tif c in ['A', 'I','U','E','O','Y']:\\n\\t\\tans = max(cnt, ans)\\n\\t\\tcnt = 0\\n\\nans = max(ans, cnt+1)\\nprint(ans)\\n\", \"s = input()\\nt = ['A', 'E', 'I', 'O', 'U' , 'Y']\\ncur = -1\\nn = len(s)\\nm = 0\\nfor i in range(n):\\n    if s[i] in t:\\n        m = max(m, i - cur)\\n        cur = i\\nm = max(n - cur, m)\\nprint(m)\", \"s = 'A' + input() + 'A'\\nG = {'A', 'E', 'I', 'O', 'U', 'Y'}\\nans = 1\\nt = 0\\nfor i in s:\\n    if i not in G:\\n        t += 1\\n        if t > ans:\\n            ans = t\\n    else:\\n        t = 1\\nprint(ans)\\n            \\n\", \"import sys\\n\\nLETTERS = {'A', 'E', 'I', 'O', 'U', 'Y'}\\n\\n\\nline = sys.stdin.readline().strip()\\n\\nmax_count = 0\\ncurrent_count = 0\\n\\n\\nfor ch in line:\\n    if ch in LETTERS:\\n        max_count = max(max_count, current_count)\\n        current_count = 0\\n    else:\\n        current_count += 1\\n\\nmax_count = max(max_count, current_count)\\nprint(max_count + 1)\\n\", \"s = input()\\ns = s + 'A'\\nm = 0\\ncur = -1\\nwhile cur != len(s)-1:\\n    i = cur+1\\n    while s[i] not in ['A','E','Y','U','I','O']:\\n        i+=1\\n    m = max(m,i-cur)\\n    cur = i\\nprint(m)\\n\", \"s=list(input())+[\\\"A\\\"]\\nans=1\\nk=0\\nl=['A','E','I','O','U','Y']\\nfor x in s:\\n    k+=1\\n    if ans<k: ans=k\\n    if x in l: k=0\\nprint(ans)\", \"import sys\\n\\nfin = sys.stdin\\nfout = sys.stdout\\nm = -1\\ngl = {'A', 'E', 'I', 'O', 'U', 'Y'}\\ns = fin.readline().strip()\\ncur = -1\\nfor i in range(len(s)):\\n    if s[i] in gl:\\n        m = max(m, i - cur)\\n        cur = i\\nm = max(m, len(s) - cur)\\nfout.write(str(m))\"]", "input_output": "{\n  \"inputs\": [\n    \"ABABBBACFEYUKOTT\\n\",\n    \"AAA\\n\",\n    \"A\\n\",\n    \"B\\n\",\n    \"AEYUIOAEIYAEOUIYOEIUYEAOIUEOEAYOEIUYAEOUIYEOIKLMJNHGTRWSDZXCVBNMHGFDSXVWRTPPPLKMNBXIUOIUOIUOIUOOIU\\n\",\n    \"AEYUIOAEIYAEOUIYOEIUYEAOIUEOEAYOEIUYAEOUIYEOIAEYUIOAEIYAEOUIYOEIUYEAOIUEOEAYOEIUYAEOUIYEOI\\n\",\n    \"KMLPTGFHNBVCDRFGHNMBVXWSQFDCVBNHTJKLPMNFVCKMLPTGFHNBVCDRFGHNMBVXWSQFDCVBNHTJKLPMNFVC\\n\",\n    \"QWERTYUIOPASDFGHJKLZXCVBNMQWERTYUIOPASDFGHJKLZXCVBNMQWERTYUIOPASDFGHJKLZXCVBNMQWERTYUIOPASDFGHJKLZ\\n\",\n    \"PKLKBWTXVJ\\n\",\n    \"CFHFPTGMOKXVLJJZJDQW\\n\",\n    \"TXULTFSBUBFLRNQORMMULWNVLPWTYJXZBPBGAWNX\\n\",\n    \"DAIUSEAUEUYUWEIOOEIOUYVYYOPEEWEBZOOOAOXUOIEUKYYOJOYAUYUUIYUXOUJLGIYEIIYUOCUAACRY\\n\",\n    \"VRPHBNWNWVWBWMFJJDCTJQJDJBKSJRZLVQRVVFLTZFSGCGDXCWQVWWWMFVCQHPKXXVRKTGWGPSMQTPKNDQJHNSKLXPCXDJDQDZZD\\n\",\n    \"SGDDFCDRDWGPNNFBBZZJSPXFYMZKPRXTCHVJSJJBWZXXQMDZBNKDHRGSRLGLRKPMWXNSXJPNJLDPXBSRCQMHJKPZNTPNTZXNPCJC\\n\",\n    \"NVTQVNLGWFDBCBKSDLTBGWBMNQZWZQJWNGVCTCQBGWNTYJRDBPZJHXCXFMIXNRGSTXHQPCHNFQPCMDZWJGLJZWMRRFCVLBKDTDSC\\n\",\n    \"SREZXQFVPQCLRCQGMKXCBRWKYZKWKRMZGXPMKWNMFZTRDPHJFCSXVPPXWKZMZTBFXGNLPLHZIPLFXNRRQFDTLFPKBGCXKTMCFKKT\\n\",\n    \"ICKJKMVPDNZPLKDSLTPZNRLSQSGHQJQQPJJSNHNWVDLJRLZEJSXZDPHYXGGWXHLCTVQSKWNWGTLJMOZVJNZPVXGVPJKHFVZTGCCX\\n\",\n    \"XXFPZDRPXLNHGDVCBDKJMKLGUQZXLLWYLOKFZVGXVNPJWZZZNRMQBRJCZTSDRHSNCVDMHKVXCXPCRBWSJCJWDRDPVZZLCZRTDRYA\\n\",\n    \"HDDRZDKCHHHEDKHZMXQSNQGSGNNSCCPVJFGXGNCEKJMRKSGKAPQWPCWXXWHLSMRGSJWEHWQCSJJSGLQJXGVTBYALWMLKTTJMFPFS\\n\",\n    \"PXVKJHXVDPWGLHWFWMJPMCCNHCKSHCPZXGIHHNMYNFQBUCKJJTXXJGKRNVRTQFDFMLLGPQKFOVNNLTNDIEXSARRJKGSCZKGGJCBW\\n\",\n    \"EXNMTTFPJLDHXDQBJJRDRYBZVFFHUDCHCPNFZWXSMZXNFVJGHZWXVBRQFNUIDVLZOVPXQNVMFNBTJDSCKRLNGXPSADTGCAHCBJKL\\n\",\n    \"NRNLSQQJGIJBCZFTNKJCXMGPARGWXPSHZXOBNSFOLDQVXTVAGJZNLXULHBRDGMNQKQGWMRRDPYCSNFVPUFTFBUBRXVJGNGSPJKLL\\n\",\n    \"SRHOKCHQQMVZKTCVQXJJCFGYFXGMBZSZFNAFETXILZHPGHBWZRZQFMGSEYRUDVMCIQTXTBTSGFTHRRNGNTHHWWHCTDFHSVARMCMB\\n\",\n    \"HBSVZHDKGNIRQUBYKYHUPJCEETGFMVBZJTHYHFQPFBVBSMQACYAVWZXSBGNKWXFNMQJFMSCHJVWBZXZGSNBRUHTHAJKVLEXFBOFB\\n\",\n    \"NXKMUGOPTUQNSRYTKUKSCWCRQSZKKFPYUMDIBJAHJCEKZJVWZAWOLOEFBFXLQDDPNNZKCQHUPBFVDSXSUCVLMZXQROYQYIKPQPWR\\n\",\n    \"TEHJDICFNOLQVQOAREVAGUAWODOCXJXIHYXFAEPEXRHPKEIIRCRIVASKNTVYUYDMUQKSTSSBYCDVZKDDHTSDWJWACPCLYYOXGCLT\\n\",\n    \"LCJJUZZFEIUTMSEXEYNOOAIZMORQDOANAMUCYTFRARDCYHOYOPHGGYUNOGNXUAOYSEMXAZOOOFAVHQUBRNGORSPNQWZJYQQUNPEB\\n\",\n    \"UUOKAOOJBXUTSMOLOOOOSUYYFTAVBNUXYFVOOGCGZYQEOYISIYOUULUAIJUYVVOENJDOCLHOSOHIHDEJOIGZNIXEMEGZACHUAQFW\\n\",\n    \"OUUBEHXOOURMOAIAEHXCUOIYHUJEVAWYRCIIAGDRIPUIPAIUYAIWJEVYEYYUYBYOGVYESUJCFOJNUAHIOOKBUUHEJFEWPOEOUHYA\\n\",\n    \"EMNOYEEUIOUHEWZITIAEZNCJUOUAOQEAUYEIHYUSUYUUUIAEDIOOERAEIRBOJIEVOMECOGAIAIUIYYUWYIHIOWVIJEYUEAFYULSE\\n\",\n    \"BVOYEAYOIEYOREJUYEUOEOYIISYAEOUYAAOIOEOYOOOIEFUAEAAESUOOIIEUAAGAEISIAPYAHOOEYUJHUECGOYEIDAIRTBHOYOYA\\n\",\n    \"GOIEOAYIEYYOOEOAIAEOOUWYEIOTNYAANAYOOXEEOEAVIOIAAIEOIAUIAIAAUEUAOIAEUOUUZYIYAIEUEGOOOOUEIYAEOSYAEYIO\\n\",\n    \"AUEAOAYIAOYYIUIOAULIOEUEYAIEYYIUOEOEIEYRIYAYEYAEIIMMAAEAYAAAAEOUICAUAYOUIAOUIAIUOYEOEEYAEYEYAAEAOYIY\\n\",\n    \"OAIIYEYYAOOEIUOEEIOUOIAEFIOAYETUYIOAAAEYYOYEYOEAUIIUEYAYYIIAOIEEYGYIEAAOOWYAIEYYYIAOUUOAIAYAYYOEUEOY\\n\",\n    \"EEEAOEOEEIOUUUEUEAAOEOIUYJEYAIYIEIYYEAUOIIYIUOOEUCYEOOOYYYIUUAYIAOEUEIEAOUOIAACAOOUAUIYYEAAAOOUYIAAE\\n\",\n    \"AYEYIIEUIYOYAYEUEIIIEUYUUAUEUIYAIAAUYONIEYIUIAEUUOUOYYOUUUIUIAEYEOUIIUOUUEOAIUUYAAEOAAEOYUUIYAYRAIII\\n\",\n    \"YOOAAUUAAAYEUYIUIUYIUOUAEIEEIAUEOAUIIAAIUYEUUOYUIYEAYAAAYUEEOEEAEOEEYYOUAEUYEEAIIYEUEYJOIIYUIOIUOIEE\\n\",\n    \"UYOIIIAYOOAIUUOOEEUYIOUAEOOEIOUIAIEYOAEAIOOEOOOIUYYUYIAAUIOUYYOOUAUIEYYUOAAUUEAAIEUIAUEUUIAUUOYOAYIU\\n\",\n    \"ABBABBB\\n\",\n    \"ABCD\\n\",\n    \"XXYC\\n\",\n    \"YYY\\n\",\n    \"ABABBBBBBB\\n\",\n    \"YYYY\\n\",\n    \"YYYYY\\n\",\n    \"AXXX\\n\",\n    \"YYYYYYY\\n\",\n    \"BYYBBB\\n\",\n    \"YYYYYYYYY\\n\",\n    \"CAAAAA\\n\",\n    \"CCCACCCC\\n\",\n    \"ABABBBACFEYUKOTTTT\\n\",\n    \"AABBYYYYYYYY\\n\",\n    \"BYBACYC\\n\",\n    \"Y\\n\",\n    \"ABBBBBB\\n\",\n    \"BACDYDI\\n\",\n    \"XEXXXXXXXXXXXXXXX\\n\",\n    \"TTYTT\\n\",\n    \"AAYBC\\n\",\n    \"ABABBBACFEYUKOTTTTT\\n\",\n    \"YYAYY\\n\",\n    \"YZZY\\n\",\n    \"YY\\n\",\n    \"ZZYZZ\\n\",\n    \"YBBBY\\n\",\n    \"BBBACCCCCCC\\n\",\n    \"YBBBBY\\n\",\n    \"YYYYYYYYYY\\n\",\n    \"ABABBBBBBBBBBBB\\n\"\n  ],\n  \"outputs\": [\n    \"4\",\n    \"1\",\n    \"1\",\n    \"2\",\n    \"39\",\n    \"1\",\n    \"85\",\n    \"18\",\n    \"11\",\n    \"12\",\n    \"9\",\n    \"4\",\n    \"101\",\n    \"76\",\n    \"45\",\n    \"48\",\n    \"47\",\n    \"65\",\n    \"28\",\n    \"35\",\n    \"30\",\n    \"19\",\n    \"30\",\n    \"34\",\n    \"17\",\n    \"15\",\n    \"9\",\n    \"5\",\n    \"4\",\n    \"5\",\n    \"5\",\n    \"3\",\n    \"3\",\n    \"2\",\n    \"2\",\n    \"2\",\n    \"2\",\n    \"1\",\n    \"4\",\n    \"4\",\n    \"3\",\n    \"1\",\n    \"8\",\n    \"1\",\n    \"1\",\n    \"4\",\n    \"1\",\n    \"4\",\n    \"1\",\n    \"2\",\n    \"5\",\n    \"5\",\n    \"3\",\n    \"2\",\n    \"1\",\n    \"7\",\n    \"3\",\n    \"16\",\n    \"3\",\n    \"3\",\n    \"6\",\n    \"1\",\n    \"3\",\n    \"1\",\n    \"3\",\n    \"4\",\n    \"8\",\n    \"5\",\n    \"1\",\n    \"13\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/733/A", "starter_code": ""}
{"id": 1903, "question": "Stepan is a very experienced olympiad participant. He has n cups for Physics olympiads and m cups for Informatics olympiads. Each cup is characterized by two parameters \u2014 its significance c_{i} and width w_{i}.\n\nStepan decided to expose some of his cups on a shelf with width d in such a way, that:  there is at least one Physics cup and at least one Informatics cup on the shelf,  the total width of the exposed cups does not exceed d,  from each subjects (Physics and Informatics) some of the most significant cups are exposed (i. e. if a cup for some subject with significance x is exposed, then all the cups for this subject with significance greater than x must be exposed too). \n\nYour task is to determine the maximum possible total significance, which Stepan can get when he exposes cups on the shelf with width d, considering all the rules described above. The total significance is the sum of significances of all the exposed cups.\n\n\n-----Input-----\n\nThe first line contains three integers n, m and d (1 \u2264 n, m \u2264 100 000, 1 \u2264 d \u2264 10^9) \u2014 the number of cups for Physics olympiads, the number of cups for Informatics olympiads and the width of the shelf.\n\nEach of the following n lines contains two integers c_{i} and w_{i} (1 \u2264 c_{i}, w_{i} \u2264 10^9) \u2014 significance and width of the i-th cup for Physics olympiads.\n\nEach of the following m lines contains two integers c_{j} and w_{j} (1 \u2264 c_{j}, w_{j} \u2264 10^9) \u2014 significance and width of the j-th cup for Informatics olympiads.\n\n\n-----Output-----\n\nPrint the maximum possible total significance, which Stepan can get exposing cups on the shelf with width d, considering all the rules described in the statement.\n\nIf there is no way to expose cups on the shelf, then print 0.\n\n\n-----Examples-----\nInput\n3 1 8\n4 2\n5 5\n4 2\n3 2\n\nOutput\n8\n\nInput\n4 3 12\n3 4\n2 4\n3 5\n3 4\n3 5\n5 2\n3 4\n\nOutput\n11\n\nInput\n2 2 2\n5 3\n6 3\n4 2\n8 1\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example Stepan has only one Informatics cup which must be exposed on the shelf. Its significance equals 3 and width equals 2, so after Stepan exposes it, the width of free space on the shelf becomes equal to 6. Also, Stepan must expose the second Physics cup (which has width 5), because it is the most significant cup for Physics (its significance equals 5). After that Stepan can not expose more cups on the shelf, because there is no enough free space. Thus, the maximum total significance of exposed cups equals to 8.", "solutions": "[\"n, m, d = list(map(int, input().split()))\\n\\na = []\\nb = []\\n\\nfor i in range(n):\\n    a.append(list(map(int, input().split())))\\n\\nfor i in range(m):\\n    b.append(list(map(int, input().split())))\\n\\na = sorted(a, key=lambda x: x[0] + (1- x[1] * 1e-10))\\nb = sorted(b, key=lambda x: x[0] + (1- x[1] * 1e-10))\\n\\ntc, td = 0, 0\\n\\ntc += a[-1][0]\\ntc += b[-1][0]\\ntd += a[-1][1]\\ntd += b[-1][1]\\n\\nai = n - 1\\nbi = m - 1\\n\\nif td > d:\\n    print(0)\\n    return\\n\\nwhile ai > 0:\\n    t = ai - 1\\n    if td + a[t][1] <= d:\\n        td += a[t][1]\\n        tc += a[t][0]\\n        ai -= 1\\n        continue\\n    else:\\n        break\\n    \\ncmax = tc\\n\\nwhile bi > 0:\\n    bi -= 1\\n    tc += b[bi][0]\\n    td += b[bi][1]\\n    \\n    while td > d and ai < n:\\n        tc -= a[ai][0]\\n        td -= a[ai][1]\\n        ai += 1\\n    \\n    if ai == n:\\n        break\\n    \\n    if td <= d:\\n        cmax = max(cmax, tc)\\n        \\nprint(cmax)\", \"n, m, d = list(map(int, input().split()))\\n\\na = []\\nb = []\\n\\nfor i in range(n):\\n    a.append(list(map(int, input().split())))\\n\\nfor i in range(m):\\n    b.append(list(map(int, input().split())))\\n\\na = sorted(a, key=lambda x: x[0] + (1- x[1] * 1e-10))\\nb = sorted(b, key=lambda x: x[0] + (1- x[1] * 1e-10))\\n\\ntc, td = 0, 0\\n\\ntc += a[-1][0]\\ntc += b[-1][0]\\ntd += a[-1][1]\\ntd += b[-1][1]\\n\\nai = n - 1\\nbi = m - 1\\n\\nif td > d:\\n    print(0)\\n    return\\n\\nwhile ai > 0:\\n    t = ai - 1\\n    if td + a[t][1] <= d:\\n        td += a[t][1]\\n        tc += a[t][0]\\n        ai -= 1\\n        continue\\n    else:\\n        break\\n    \\ncmax = tc\\n\\nwhile bi > 0:\\n    bi -= 1\\n    tc += b[bi][0]\\n    td += b[bi][1]\\n    \\n    while td > d and ai < n:\\n        tc -= a[ai][0]\\n        td -= a[ai][1]\\n        ai += 1\\n    \\n    if ai == n:\\n        break\\n    \\n    if td <= d:\\n        cmax = max(cmax, tc)\\n        \\nprint(cmax)\", \"n, m, d = map(int, input().split())\\nph = [[int(j) for j in input().split()] for i in range(n)]\\ninf = [[int(j) for j in input().split()] for i in range(m)]\\nfor i in range(n):\\n    ph[i][1] = -ph[i][1]\\nfor i in range(m):\\n    inf[i][1] = -inf[i][1]\\nph.sort(reverse=True)\\ninf.sort(reverse=True)\\nsw, sc = 0, 0\\nfor p in inf:\\n    sc += p[0]\\n    d += p[1]\\nans = 0\\nz = m - 1\\nfor p in ph:\\n    sc += p[0]\\n    d += p[1]\\n    #print(sc, d)\\n    while z > 0 and d < 0:\\n        sc -= inf[z][0]\\n        d -= inf[z][1]\\n        z -= 1\\n    #print(sc, d)\\n    if d >= 0:\\n        ans = max(ans, sc)\\nprint(ans)\"]", "input_output": "{\n  \"inputs\": [\n    \"3 1 8\\n4 2\\n5 5\\n4 2\\n3 2\\n\",\n    \"4 3 12\\n3 4\\n2 4\\n3 5\\n3 4\\n3 5\\n5 2\\n3 4\\n\",\n    \"2 2 2\\n5 3\\n6 3\\n4 2\\n8 1\\n\",\n    \"10 10 229\\n15 17\\n5 4\\n4 15\\n4 17\\n15 11\\n7 6\\n5 19\\n14 8\\n4 1\\n10 12\\n20 13\\n20 14\\n16 13\\n7 15\\n2 16\\n11 11\\n19 20\\n6 7\\n4 11\\n14 16\\n\",\n    \"10 20 498\\n40 12\\n23 25\\n20 9\\n8 1\\n23 8\\n31 24\\n33 2\\n22 33\\n4 13\\n25 20\\n40 5\\n27 5\\n17 6\\n8 5\\n4 19\\n33 23\\n30 19\\n27 12\\n13 22\\n16 32\\n28 36\\n20 18\\n36 38\\n9 24\\n21 35\\n20 9\\n33 29\\n29 33\\n18 25\\n11 8\\n\",\n    \"20 10 761\\n42 41\\n47 7\\n35 6\\n22 40\\n15 2\\n47 28\\n46 47\\n3 45\\n12 19\\n44 41\\n46 2\\n49 23\\n9 8\\n7 41\\n5 3\\n16 42\\n12 50\\n17 22\\n25 9\\n45 12\\n41 44\\n34 47\\n33 35\\n32 47\\n49 6\\n27 18\\n43 36\\n23 6\\n39 22\\n38 45\\n\",\n    \"1 1 1000000000\\n4 500000000\\n6 500000000\\n\",\n    \"4 2 8\\n1000000000 2\\n1000000000 2\\n1000000000 2\\n1000000000 2\\n1000000000 2\\n1000000000 2\\n\",\n    \"1 1 1000000000\\n1 1000000000\\n1 1000000000\\n\",\n    \"1 1 1\\n1 1\\n1 1\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n\",\n    \"11\\n\",\n    \"0\\n\",\n    \"198\\n\",\n    \"644\\n\",\n    \"900\\n\",\n    \"10\\n\",\n    \"4000000000\\n\",\n    \"0\\n\",\n    \"0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/774/B", "starter_code": ""}
{"id": 1463, "question": "Okabe needs to renovate the Future Gadget Laboratory after he tried doing some crazy experiments! The lab is represented as an n by n square grid of integers. A good lab is defined as a lab in which every number not equal to 1 can be expressed as the sum of a number in the same row and a number in the same column. In other words, for every x, y such that 1 \u2264 x, y \u2264 n and a_{x}, y \u2260 1, there should exist two indices s and t so that a_{x}, y = a_{x}, s + a_{t}, y, where a_{i}, j denotes the integer in i-th row and j-th column.\n\nHelp Okabe determine whether a given lab is good!\n\n\n-----Input-----\n\nThe first line of input contains the integer n (1 \u2264 n \u2264 50)\u00a0\u2014 the size of the lab. \n\nThe next n lines contain n space-separated integers denoting a row of the grid. The j-th integer in the i-th row is a_{i}, j (1 \u2264 a_{i}, j \u2264 10^5).\n\n\n-----Output-----\n\nPrint \"Yes\" if the given lab is good and \"No\" otherwise.\n\nYou can output each letter in upper or lower case.\n\n\n-----Examples-----\nInput\n3\n1 1 2\n2 3 1\n6 4 1\n\nOutput\nYes\n\nInput\n3\n1 5 2\n1 1 1\n1 2 3\n\nOutput\nNo\n\n\n\n-----Note-----\n\nIn the first sample test, the 6 in the bottom left corner is valid because it is the sum of the 2 above it and the 4 on the right. The same holds for every number not equal to 1 in this table, so the answer is \"Yes\".\n\nIn the second sample test, the 5 cannot be formed as the sum of an integer in the same row and an integer in the same column. Thus the answer is \"No\".", "solutions": "[\"N = int(input())\\ntable = []\\nfor i in range(N):\\n    table.append(list(map(int, input().split())))\\n\\nfor i in range(N):\\n    for j in range(N):\\n        if table[i][j] == 1:\\n            continue\\n        flg = False\\n        for s in range(N):\\n            for t in range(N):\\n                if table[i][j] == table[i][s] + table[t][j]:\\n                    flg = True\\n                    break\\n        if not flg:\\n            print(\\\"No\\\")\\n            return\\nprint(\\\"Yes\\\")\\n\", \"I = lambda : map(int, input().split())\\nn, = I()\\narr = []\\nfor i in range(0, n):\\n    arr.append(list(I()))\\n\\nfor x in range(0, n):\\n    for y in range(0, n):\\n        if arr[x][y] != 1:\\n            found = False\\n            for s in range(0, n):\\n                for t in range(0, n):\\n                    if arr[x][y] == arr[x][s] + arr[t][y]:\\n                        found = True\\n            if not found:\\n                print(\\\"No\\\")\\n                return\\nprint(\\\"Yes\\\")\", \"def main():\\n    n = int(input())\\n    a = []\\n    for _ in range(n):\\n        a.append(list(map(int, input().split())))\\n    for i in range(n):\\n        for j in range(n):\\n            e = a[i][j]\\n            if e == 1:\\n                continue\\n            else:\\n                fl = False\\n                for i1 in range(n):\\n                    for j1 in range(n):\\n                        if a[i1][j] + a[i][j1] == e:\\n                            fl = True\\n                            break\\n                    if fl:\\n                        break\\n                if fl:\\n                    continue\\n                else:\\n                    print('No')\\n                    return\\n    print('Yes')\\n\\nmain()\", \"n = int(input())\\na = []\\nfor i in range(n):\\n    a.append(list(map(int, input().split())))\\nok = True\\nfor i in range(n):\\n    for j in range(n):\\n        if a[i][j] != 1:\\n            check = False\\n            for k in range(n):\\n                for l in range(n):\\n                    if a[i][j] == a[i][k] + a[l][j]:\\n                        check = True\\n                    if check:\\n                        break\\n                if check:\\n                    break\\n            ok &= check\\nprint(\\\"Yes\\\" if ok else \\\"No\\\")\\n\", \"n = int(input())\\ns = []\\nfor k in range(n):\\n    s.append([int(i) for i in input().split()])\\nt = 0\\nfor i in range(n):\\n    for j in range(n):\\n        l = 0\\n        if s[i][j] !=1:\\n            for x in range(n):\\n                for y in range(n):\\n                    if s[i][x]+ s[y][j] == s[i][j]:\\n                        l = 1\\n            if not l:\\n                t = 1\\nif t:\\n    print(\\\"No\\\")\\nelse:\\n    print(\\\"Yes\\\")\\n\", \"from sys import stdin, stdout\\n\\ndef main():\\n    n = int(stdin.readline())\\n    mat = []\\n    for i in range(n):\\n        mat.append(list(map(int, stdin.readline().split())))\\n    for i in range(n):\\n        for j in range(n):\\n            st = True\\n            for u in range(n):\\n                for k in range(n):\\n                    if mat[i][j] == 1 or mat[i][j] == mat[u][j] + mat[i][k]:\\n                        st = False\\n                        break\\n                if not st: break\\n            if st:\\n                return False\\n    return True\\n\\n\\nprint('Yes' if main() else 'No')\\n\", \"import sys \\n\\ndef main():\\n    n = int(input())\\n    x = []\\n    for i in range(n):\\n        y = list(map(int,sys.stdin.readline().split()))\\n        x.append(y)\\n\\n    for i in range(n):\\n        for j in range(n):\\n            if x[i][j] == 1:\\n                continue\\n            found = False\\n            for o in range(n):\\n                a = x[i][o]\\n                if o == j:\\n                    continue\\n                for p in range(n):\\n                    if p ==i:\\n                        continue\\n                    b = x[p][j]\\n                    if a+b == x[i][j]:\\n                        found = True\\n                        break\\n                if found:\\n                    break\\n            if not found:\\n                print(\\\"No\\\")\\n                return\\n    print(\\\"Yes\\\")\\n    \\n\\nmain()\\n\", \"n = int(input())\\ndata = []\\nfor i in range(n):\\n    data += [list(map(int, input().split()))]\\n\\nfor i in range(n):\\n    for j in range(n):\\n        if data[i][j] == 1:\\n            t = True\\n            continue\\n        t = False\\n        for k in range(n):\\n            for m in range(n):\\n                if data[i][k] + data[m][j] == data[i][j]:\\n                    t = True\\n                    break\\n        if not t:\\n            print(\\\"No\\\")\\n            break\\n    if not t:\\n        break\\nif t:\\n    print(\\\"Yes\\\")\\n\", \"def check(r, c, x):\\n    rtn = False\\n    rs = [a[r][i] for i in range(n) if i != c]\\n    cs = [a[i][c] for i in range(n) if i != r]\\n    for r in rs:\\n        for c in cs:\\n            if r + c == x:\\n                rtn = True\\n                break\\n    return rtn\\n\\nn = int(input())\\na = [list(map(int, input().split()))for _ in range(n)]\\n\\nans = True\\nfor i in range(n):\\n    for j in range(n):\\n        if a[i][j] != 1:\\n            ans &= check(i, j, a[i][j])\\n\\nprint('Yes' if ans else 'No')\\n\", \"def solve(g):\\n    for i in range(n):\\n        for j in range(n):\\n            if g[i][j] == 1:continue\\n            for p in range(n):\\n                for q in range(n):\\n                    if p == i or q == j:continue\\n                    if g[i][q] + g[p][j] == g[i][j]:break\\n                else:\\n                    continue\\n                break\\n            else:\\n                return \\\"No\\\"\\n    return \\\"Yes\\\"\\n\\nn = int(input())\\n\\ng = []\\n\\nfor i in range(n):\\n    g.append([int(item) for item in input().split()])\\n    \\nprint(solve(g))\", \"#! python3\\n\\ndef is_good(a, n, i, j):\\n    c = set([])\\n    for x in range(n):\\n        c.add(a[i][j] - a[i][x])\\n    for x in range(n):\\n        if a[x][j] in c:\\n            return True\\n    return False\\n\\nn = int(input())\\na = []\\nfor _ in range(n):\\n    a.append([int(x) for x in input().strip().split(' ')])\\n\\ngood = True\\nfor i in range(n):\\n    for j in range(n):\\n        if a[i][j] != 1 and not is_good(a, n, i, j):\\n            good = False\\n            break\\nif good:\\n    print(\\\"Yes\\\")\\nelse:\\n    print(\\\"No\\\")\\n\", \"#!/usr/bin/env python3\\nimport sys\\n\\ndef main():\\n    n = int(sys.stdin.readline())\\n    mat = [None for __ in range(n)]\\n    for indx in range(n):\\n        mat[indx] = list(map(int, sys.stdin.readline().split()))\\n\\n    good = True\\n    for row in range(n):\\n        for col in range(n):\\n            if mat[row][col] == 1:\\n                continue\\n            else:\\n                good &= check_this_element(mat, row, col)\\n    if good:\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\\n\\ndef check_this_element(mat, row, col):\\n    n = len(mat)\\n    for _row in range(n):\\n        for _col in range(n):\\n            if mat[_row][col] + mat[row][_col] == mat[row][col]:\\n                return True\\n    return False\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"#!/usr/bin/env python3\\nfrom sys import stdin, stdout\\n\\ndef rint():\\n    return list(map(int, stdin.readline().split()))\\n#lines = stdin.readlines()\\n\\n\\ndef check(i, j):\\n    for r in range(n):\\n        for c in range(n):\\n           if a[i][c] + a[r][j] == a[i][j]:\\n               return 1\\n    return 0\\nn = int(input())\\na = [[] for _ in range(n)]\\nfor i in range(n):\\n    a[i] = list(rint())\\n\\nfor i in range(n):\\n    for j in range(n):\\n        if a[i][j] == 1:\\n            continue\\n        if check(i,j) == 0:\\n            print(\\\"No\\\")\\n            return\\n\\nprint(\\\"Yes\\\")\\n\\n\\n\\n\", \"def int_input():\\n    return list(map(int, input().split()))\\n\\n\\nn = int(input())\\nmatr = [list(int_input()) for i in range(n)]\\n\\ngood = True\\nfor row in range(n):\\n    nums = set(matr[row])\\n    for col in range(n):\\n        num = matr[row][col]\\n        if num == 1:\\n            continue\\n        cur_good = False\\n        for i in range(n):\\n            cur_good |= num - matr[i][col] in nums\\n        good &= cur_good\\n\\nprint('Yes' if good else 'No')\\n\", \"#def proverka(b, k, m, p):\\n#  for i in range()\\n\\nn = int(input()) \\na = []\\nfor i in range(n):\\n    a.append([int(j) for j in input().split()])\\nflag = \\\"Yes\\\" \\nfor i in range(n):\\n  for j in range(n):\\n    if(a[i][j] != 1):\\n      f = False\\n      for k in range(n):\\n        if(f):\\n          break\\n        for z in range(n):\\n          if(a[k][j] + a[i][z] == a[i][j]):\\n            f = True\\n          if(f):\\n            break\\n      if(not(f)):\\n        flag = \\\"No\\\"\\n\\nprint(flag)\", \"n=int(input())\\na=[[0]*n for i in range(n)]\\nf=True\\nd=True\\nfor i in range(n):\\n    a[i]=list(map(int,input().split(\\\" \\\")))\\nfor i in range(n):\\n    for j in range(n):\\n        s=a[i][j]\\n\\n        if s!=1:\\n            f = False\\n            for t in range(n):\\n                if t!=i:\\n                    x=s-a[t][j]\\n                    if x in a[i]:\\n                        f=True\\n        if f==False:\\n            d=False\\nif not d:\\n    print('No')\\nelse:\\n    print('Yes')\", \"n=int(input())\\na=[]\\nfor i in range(n):\\n\\ta.append(list(map(int,input().split())))\\nfor i in range(n):\\n\\tfor j in range(n):\\n\\t\\tc=0\\n\\t\\tif a[i][j]==1:\\n\\t\\t\\tcontinue\\n\\t\\tfor k in range(n):\\n\\t\\t\\tfor l in range(n):\\n\\t\\t\\t\\tif a[i][j]==a[i][k]+a[l][j]:\\n\\t\\t\\t\\t\\tc=1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif c:\\n\\t\\t\\t\\tbreak\\n\\t\\tif not c:\\n\\t\\t\\tprint('No')\\n\\t\\t\\treturn\\nprint('Yes')\\n\", \"a = [list(map(int, input().split())) for i in range(int(input()))]\\nn = len(a)\\nfor i in range(n):\\n    for j in range(n):\\n        if a[i][j] != 1:\\n            found = False\\n            for i2 in range(n):\\n                for j2 in range(n):\\n                    if a[i][j] == a[i][j2] + a[i2][j]:\\n                        found = True\\n            if not found:\\n                print('No\\\\n')\\n                return\\nprint('Yes')\", \"n = int(input())\\na = []\\nfor i in range(n):\\n\\ta.append([int(x) for x in input().split()])\\nfor i in range(n):\\n\\tfor j in range(n):\\n\\t\\tif a[i][j]==1:\\n\\t\\t\\tcontinue\\n\\t\\tval = False\\n\\t\\tfor k in range(n):\\n\\t\\t\\tfor l in range(n):\\n\\t\\t\\t\\tif (a[i][k]+a[l][j]==a[i][j]):\\n\\t\\t\\t\\t\\tval = True\\n\\t\\tif val==False:\\n\\t\\t\\tprint(\\\"No\\\")\\n\\t\\t\\treturn\\nprint(\\\"Yes\\\")\\n\\t\\t\\t\\t\\n\\t\\t\\n\", \"from itertools import *\\nn=int(input())\\nf=[list(map(int,input().split())) for _ in range(n)]\\nfor i,j in product(list(range(n)),list(range(n))):\\n    x=f[i][j]\\n    if x==1: continue\\n    if not any(a+b==x for a, b in product(chain(f[i][:j], f[i][j+1:]),(f[k][j] for k in chain(list(range(i)), list(range(i+1,n)))))):\\n        print(\\\"No\\\")\\n        return\\nprint(\\\"Yes\\\")\\n\", \"def fin(s, row, column):\\n\\tfor i in row:\\n\\t\\tfor j in column:\\n\\t\\t\\tif i+j == s:\\n\\t\\t\\t\\treturn True\\n\\treturn False\\n\\nn = int(input())\\na = []\\nfor i in range(n):\\n\\tk = input().split(' ')\\n\\tk = list(map(int,k))\\n\\ta.append(k)\\n\\nans = True\\n\\nfor i in range(n):\\n\\tfor j in range(n):\\n\\t\\tif a[i][j] == 1:\\n\\t\\t\\tcontinue\\n\\t\\telse:\\n\\t\\t\\ts = a[i][j]\\n\\t\\t\\trow = a[i]\\n\\t\\t\\tcolumn = []\\n\\t\\t\\tfor t in range(n):\\n\\t\\t\\t\\tcolumn.append(a[t][j])\\n\\t\\t\\tans = fin(s,row,column)\\n\\t\\t\\tif ans == False:\\n\\t\\t\\t\\tbreak\\n\\tif ans == False:\\n\\t\\tbreak\\n\\nif ans==True:\\n\\tprint(\\\"Yes\\\")\\nelse:\\n\\tprint(\\\"No\\\")\\n\", \"import sys\\n\\ndef is_good(lab):\\n  n = len(lab)\\n  for i in range(n):\\n    for j in range(n):\\n      v = lab[i][j]\\n      if v > 1 and all(x + y != v for x in lab[i] for y in (lab[k][j] for k in range(n))):\\n        return False\\n  return True\\n\\nn = int(input())\\n\\nlab = [[int(i) for i in input().split()] for _ in range(n)]\\n\\nprint('Yes' if is_good(lab) else 'No')\\n\", \"n = int(input())\\ntbl = []\\nfor i in range(n):\\n    tbl.append(list(map(int, input().split())))\\n\\nout = False\\nfor i, row in enumerate(tbl):\\n    for j in range(len(row)):\\n        out = False\\n        e = row[j]\\n        if e == 1:\\n            out = True\\n            continue\\n        for j1, e1 in enumerate(row):\\n            if j1 != j:\\n                for i1 in range(n):\\n                    if e1 + tbl[i1][j] == e:\\n                        out = True\\n                        break\\n            if out:\\n                break\\n        if not out:\\n            print('No')\\n            break\\n    if not out:\\n        break\\nif out:\\n    print('Yes')\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n1 1 2\\n2 3 1\\n6 4 1\\n\",\n    \"3\\n1 5 2\\n1 1 1\\n1 2 3\\n\",\n    \"1\\n1\\n\",\n    \"4\\n1 1 1 1\\n1 11 1 2\\n2 5 1 4\\n3 9 4 1\\n\",\n    \"4\\n1 1 1 1\\n1 7 1 1\\n1 3 1 2\\n2 6 3 1\\n\",\n    \"4\\n1 1 1 1\\n1 12 1 2\\n4 4 1 3\\n5 10 6 1\\n\",\n    \"4\\n1 1 1 1\\n1 13 1 2\\n4 5 1 3\\n5 11 6 1\\n\",\n    \"4\\n1 1 1 1\\n1 13 1 2\\n4 5 1 3\\n7 11 6 1\\n\",\n    \"4\\n1 1 1 1\\n1 14 1 6\\n4 5 1 5\\n3 8 2 1\\n\",\n    \"10\\n3 2 6 5 1 2 1 1 2 1\\n1 2 2 3 1 4 1 1 1 1\\n1 1 3 1 2 2 2 1 1 1\\n1 3 1 2 1 2 1 1 1 1\\n12 1 4 3 3 1 1 1 2 1\\n8 1 1 1 1 3 6 5 1 3\\n1 1 1 2 4 1 3 2 1 1\\n1 1 1 1 1 1 1 2 1 1\\n1 2 1 1 1 1 1 1 1 1\\n2 1 1 1 1 1 1 1 1 2\\n\",\n    \"4\\n1 2 3 5\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n\",\n    \"1\\n2\\n\",\n    \"3\\n1 1 4\\n1 1 2\\n1 1 2\\n\",\n    \"1\\n5\\n\",\n    \"3\\n1 2 1\\n2 2 3\\n1 3 1\\n\",\n    \"3\\n2 1 1\\n2 1 1\\n2 1 1\\n\",\n    \"1\\n60000\\n\"\n  ],\n  \"outputs\": [\n    \"Yes\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/821/A", "starter_code": ""}
{"id": 905, "question": "Caisa is going to have a party and he needs to buy the ingredients for a big chocolate cake. For that he is going to the biggest supermarket in town.\n\nUnfortunately, he has just s dollars for sugar. But that's not a reason to be sad, because there are n types of sugar in the supermarket, maybe he able to buy one. But that's not all. The supermarket has very unusual exchange politics: instead of cents the sellers give sweets to a buyer as a change. Of course, the number of given sweets always doesn't exceed 99, because each seller maximizes the number of dollars in the change (100 cents can be replaced with a dollar).\n\nCaisa wants to buy only one type of sugar, also he wants to maximize the number of sweets in the change. What is the maximum number of sweets he can get? Note, that Caisa doesn't want to minimize the cost of the sugar, he only wants to get maximum number of sweets as change. \n\n\n-----Input-----\n\nThe first line contains two space-separated integers n, s (1 \u2264 n, s \u2264 100).\n\nThe i-th of the next n lines contains two integers x_{i}, y_{i} (1 \u2264 x_{i} \u2264 100;\u00a00 \u2264 y_{i} < 100), where x_{i} represents the number of dollars and y_{i} the number of cents needed in order to buy the i-th type of sugar.\n\n\n-----Output-----\n\nPrint a single integer representing the maximum number of sweets he can buy, or -1 if he can't buy any type of sugar.\n\n\n-----Examples-----\nInput\n5 10\n3 90\n12 0\n9 70\n5 50\n7 0\n\nOutput\n50\n\nInput\n5 5\n10 10\n20 20\n30 30\n40 40\n50 50\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first test sample Caisa can buy the fourth type of sugar, in such a case he will take 50 sweets as a change.", "solutions": "[\"import itertools\\nimport math\\nimport random\\n\\nimport time\\ndef timer(f):\\n    def tmp(*args, **kwargs):\\n        t = time.time()\\n        res = f(*args, **kwargs)\\n        print(\\\"\\u0412\\u0440\\u0435\\u043c\\u044f \\u0432\\u044b\\u043f\\u043e\\u043b\\u043d\\u0435\\u043d\\u0438\\u044f \\u0444\\u0443\\u043d\\u043a\\u0446\\u0438\\u0438: %f\\\" % (time.time()-t))\\n        return res\\n\\n    return tmp\\n\\ndef genArray(length, lower, upper):\\n    return [random.randint(lower, upper) for i in range(length)]\\n\\n\\nn, s = list(map(int, input().split(' ')))\\narray = [list(map(int, input().split(' '))) for i in range(n)]\\n\\nres = -100;\\nfor i in range(n):\\n    if array[i][0]+array[i][1]/100 <= s:\\n        sdacha = 100 - array[i][1]\\n        if array[i][1]== 0:\\n            sdacha = 0\\n        if sdacha>res:\\n            res = sdacha\\n\\nif res == -100:\\n    print(-1)\\nelse:\\n    print(res)\\n\\n\", \"\\\"\\\"\\\"\\nCodeforces Contest 264 Div 2 Problem A\\n\\nAuthor  : chaotic_iak\\nLanguage: Python 3.3.4\\n\\\"\\\"\\\"\\n\\ndef main():\\n    n,s = read()\\n    mx = -1\\n    for i in range(n):\\n        x,y = read()\\n        if y == 0 and x <= s:\\n            mx = max(0, mx)\\n        elif x < s:\\n            mx = max(100-y, mx)\\n    print(mx)\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n    # 0: String\\n    # 1: List of strings\\n    # 2: List of integers\\n    inputs = input().strip()\\n    if mode == 0: return inputs\\n    if mode == 1: return inputs.split()\\n    if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\\\"\\\\n\\\"):\\n    if s is None: s = \\\"\\\"\\n    if isinstance(s, list): s = \\\" \\\".join(map(str, s))\\n    s = str(s)\\n    print(s, end=\\\"\\\")\\n\\nwrite(main())\", \"n, s = map(int, input().split())\\nmx = -1\\nfor i in range(n):\\n    xi, yi = map(int, input().split())\\n    if xi <= s:\\n        if xi < s:\\n            mx = max(mx, (100 - yi) % 100)\\n        else:\\n            if yi == 0:\\n                mx = max(0, mx)\\nprint(mx)\", \"n, s = list(map(int, input().split()))\\nm = -1\\nfor i in range(n):\\n\\tx, y = list(map(int, input().split()))\\n\\tcsum = (s-x)*100 - y\\n\\tif  csum <=s*100 and csum >=0 and csum%100 > m:\\n\\t\\tm = csum%100\\nprint(m)\\n\", \"n, s = [int(st) for st in input().split()]\\nres = -1\\nfor i in range(n):\\n    x, y = [int(st) for st in input().split()]\\n    if ( (x + y / 100) <= s):\\n        if (y == 0):\\n            y = 100\\n        res = max(res, 100 - y)\\nprint(res)\\n\", \"m=list(input().split())\\nn=int(m[0])\\ns=int(m[1])*100\\nm=list()\\nfor i in range(n):\\n    m.append(list(int(x) for x in input().split()))\\nt=100000\\nmi=None\\nt0=0\\nfor i in range(n):\\n    if ((m[i][0]*100+m[i][1])<=s and (m[i][1]<t)):\\n        if m[i][1]:\\n            t=m[i][1]\\n        else:\\n            t0=1\\nif t==100000:\\n    if t0:\\n        print('0')\\n    else:\\n        print('-1')\\nelse:\\n    print(100-t)\\n        \\n\\n\", \"n, s = list(map(int, str.split(input())))\\nr = -1\\nfor _ in range(n):\\n\\n    x, y = list(map(int, str.split(input())))\\n    if x < s or x == s and y == 0:\\n\\n        r = max(r, 100 - (y or 100))\\n\\nprint(r)\\n\", \"n, s = map(int, input().split())\\ns *= 100\\nans = -1\\nfor i in range(n):\\n    x, y = map(int, input().split())\\n    cost = x * 100 + y\\n    if s<cost:\\n        continue\\n    sd = (s - cost) % 100\\n    ans = max(ans, sd)\\nprint(ans)\", \"\\n\\nnum, sdollars = input().split(' ')\\nn = int(num)\\ns = int(sdollars)\\nsweets = -1\\n\\nfor i in range(0, n):\\n\\n    dollars, cents = input().split(' ')\\n    d = int(dollars)\\n    c = int(cents)\\n\\n    if s < d:\\n        continue\\n\\n    if s == d and c > 0:\\n        continue\\n\\n    if c == 0:\\n        if (sweets == -1):\\n            sweets = 0\\n        continue\\n\\n    if (100 - c) > sweets:\\n        sweets = 100 - c\\n\\nprint(sweets)\\n\\n\", \"n, s = [int(i) for i in input(). split()]\\nx = [0] * n\\ny = [0] * n\\nsmin = 100\\nfor i in range(n):\\n    x[i], y[i] = [int(x) for x in input(). split()]\\n    if (x[i] < s) and (y[i] < smin) and (y[i] != 0):\\n        smin = y[i]\\nif smin == 100:\\n    smin = -1\\n    for i in range(n):\\n        if (x[i] <= s) and (y[i] == 0):\\n            smin = 0\\n    print(smin) \\nelse:\\n    print(100 - smin)\", \"n,s = list(map(int,input().split()))\\nx = []\\ny = []\\nmaximum = 0\\nk = 0\\nfor i in range(n):\\n    a, b = list(map(int,input().split()))\\n    x.append(a)\\n    y.append(b)\\nfor i in range(n):\\n    if s>x[i] and 100-y[i]>maximum and y[i]>0:\\n        maximum = 100-y[i]\\n    if s < x[i]:\\n        k+=1\\n    if s == x[i] and y[i]>0:\\n        k+=1\\nif k == n:\\n    print(-1)\\nelse:\\n    print(maximum)\\n\\n\\n\\n\", \"n,s=list(map(int,input().split()))\\nans=-1\\nfor i in range(n):\\n    x,y=list(map(int,input().split()))\\n    if(x==s and y==0):\\n        ans=max(ans,0)\\n    if(x<s):\\n        ans=max(ans,(100-y)%100)\\nprint(ans)\\n\", \"[n,s]=[int(x) for x in input().split()]\\nt=[-1]\\nfor i in range(1,n+1):\\n\\t[a,b]=[int(x) for x in input().split()]\\n\\tif a+b*0.01<=s:\\n\\t\\tif b==0:\\n\\t\\t\\tt.append(0)\\n\\t\\telse:\\n\\t\\t\\tt.append(100-b)\\nt.sort(reverse=True)\\nprint(t[0])\\n\", \"n, s = list(map(int, input().split()))\\nans = -1\\nfor i in range(n):\\n    x, y = list(map(int, input().split()))\\n    if 100 * x + y > 100 * s:\\n        continue\\n    ans = max(ans, 0 if y == 0 else 100 - y)\\nprint(ans)\\n\", \"def __starting_point():\\n    n, s = [int(i) for i in input().split()]\\n    m = -1\\n\\n    for i in range(n):\\n        xi, yi = [int(j) for j in input().split()]\\n        if xi < s:\\n            m = max(m, (100 - yi) % 100)\\n        if xi == s and yi == 0:\\n            m = max(m, 0)\\n\\n    print(m)\\n\\n\\n__starting_point()\", \"n, s = list(map(int, input().split()))\\nmx = -1\\nfor i in range(n):\\n    x, y = list(map(int, input().split()))\\n    if x < s or (x == s and y == 0):\\n        mx = max(mx, 100 - (y or 100))\\nprint(mx) \\n\", \"x = input()\\nlol = False\\nn = ''\\ns = ''\\nfor letter in x:\\n    if letter == ' ':\\n        lol = True\\n    else:\\n        if lol == False:\\n            n += letter\\n        if lol == True:\\n            s += letter\\nlol = False\\nn = int(n)\\ns = 100*int(s)\\nchange = ''\\nsugars = []\\nprice = ''\\nchanges = []\\nfor i in range(n):\\n    sugar = input()\\n    for letter in sugar:\\n        if letter == ' ':\\n            lol = True\\n        else:\\n            if lol == False:\\n                price += letter\\n            if lol == True:\\n                change += letter\\n    sugars.append(100*int(price)+ int(change))\\n    lol = False\\n    change = ''\\n    price = ''\\nfor item in sugars:\\n    if s >= item:\\n        left = (item-1)%100\\n        right = 99-left\\n        changes.append(right)\\nif len(changes) == 0:\\n    ans = -1\\nelse:\\n    ans = max(changes)\\nprint(ans)\", \"n,s=list(map(int,input().split(\\\" \\\")))\\na=[]\\naa=[]\\naaa=[]\\nfor x in range(n):\\n\\tq,qq=list(map(int,input().split(\\\" \\\")))\\n\\tif qq > 0 and s > q:\\n\\t\\ta.append(qq)\\n\\taaa.append(qq)\\n\\taa.append(float(q+float(qq/100)))\\n\\tpass\\n\\nif s < min(aa):\\n\\tprint(-1)\\nelse:\\n\\tif len(a) == 0:\\n\\t\\tprint(0)\\n\\t\\tpass\\n\\telse:\\n\\t\\tprint(100-min(a))\\n\\tpass\\n\\n\\n\", \"a, b = map(int, input().split(' '))\\nmaxx = 0\\nmark = False\\nfor i in range(a):\\n    c, d = map(int, input().split(' '))\\n    if 100*c+d <= 100*b:\\n        mark = True\\n        if d > 0:\\n            maxx = max(100-d, maxx)\\nif mark == True:\\n    print(maxx)\\n        \\nelse:\\n    print(-1)\", \"ID = input().split()\\nn = int(ID[0])\\ns = int(ID[1]) * 100\\nans = -1\\nfor i in range(n):\\n    ID = input().split()\\n    x = 100 * int(ID[0]) + int(ID[1])\\n    if (x <= s) and (s - x) % 100 > ans:\\n        ans = (s - x) % 100\\n\\nprint(ans)\", \"'''n, s=map(int, input().split())\\nd=[]\\nc=-1\\nwhile(n>0):\\n    n-=1\\n    [xi, yi]=map(int, input().split())\\n    d.append([xi, 100-yi])\\nfor i in d:\\n    if(i[0]+((100-i[1])/100)<=s):\\n        if(i[1]>c and i[1]!=100):\\n            c=i[1]\\nprint(c)'''\\nn, s=list(map(int, input().split()))\\nc=-1\\nfor i in range(n):\\n    xi, yi=list(map(int, input().split()))\\n    if(yi==0 and xi<=s):\\n        c=max(0, c)\\n    elif(xi<s):\\n        c=max(100-yi, c)\\nprint(c)\\n\", \"n, s=map(int, input().split())\\nans=-1\\nfor i in range(n):\\n    x, y=map(int, input().split())\\n    if y==0 and x<=s or y!=0 and x<s:\\n        ans=max(ans, (100-y)%100)\\nprint(ans)\", \"n, s = input().split()\\nans = -1\\ns = int(s)\\nfor i in range(0,int(n)):\\n\\ta, b = input().split()\\n\\ta = int(a)\\n\\tb = int(b)\\n\\tif(s > a or (s == a and b == 0)):\\n\\t\\tans = max(ans, (100 - b) % 100)\\n\\nprint(ans)\", \"Inpt1,Inpt2=list(map(int,input().split()))\\nMaximum=-1\\nfor i in range(Inpt1):\\n    Inpt3,Inpt4=list(map(int,input().split()))\\n    if Inpt4==0 and Inpt3<=Inpt2:\\n        Maximum=max(0,Maximum)\\n    elif Inpt3<Inpt2:\\n        Maximum=max(100-Inpt4,Maximum)\\nprint(Maximum)\\n\", \"(n, s) = [int(i) for i in input().split()]\\nxy = []\\nfor i in range(n):\\n\\txy.append(tuple(int(i) for i in input().split()))\\nans = -1\\nfor pair in xy:\\n\\tif (s > pair[0]) or (s == pair[0] and pair[1] == 0):\\n\\t\\tans = max(ans, (100 - pair[1]) % 100)\\nprint(ans)\"]", "input_output": "{\n  \"inputs\": [\n    \"5 10\\n3 90\\n12 0\\n9 70\\n5 50\\n7 0\\n\",\n    \"5 5\\n10 10\\n20 20\\n30 30\\n40 40\\n50 50\\n\",\n    \"1 2\\n1 0\\n\",\n    \"2 10\\n20 99\\n30 99\\n\",\n    \"15 21\\n16 51\\n33 44\\n32 92\\n19 91\\n67 81\\n94 94\\n40 67\\n77 38\\n42 22\\n48 19\\n9 35\\n90 36\\n57 80\\n58 97\\n13 15\\n\",\n    \"1 2\\n5 0\\n\",\n    \"37 10\\n57 61\\n78 79\\n59 60\\n48 17\\n39 22\\n11 87\\n19 55\\n56 78\\n25 12\\n15 55\\n13 37\\n49 38\\n37 57\\n19 37\\n74 18\\n81 27\\n8 82\\n43 9\\n79 17\\n92 41\\n29 69\\n77 1\\n33 98\\n11 31\\n40 56\\n46 76\\n16 51\\n10 94\\n32 3\\n23 27\\n8 57\\n40 54\\n16 66\\n36 33\\n28 45\\n67 26\\n81 55\\n\",\n    \"46 27\\n53 88\\n89 56\\n98 5\\n48 35\\n88 19\\n41 22\\n71 75\\n75 88\\n57 51\\n42 63\\n100 91\\n58 78\\n99 75\\n56 3\\n49 70\\n59 81\\n38 0\\n59 98\\n35 86\\n6 5\\n80 21\\n97 45\\n86 2\\n54 22\\n38 42\\n34 94\\n25 37\\n65 42\\n46 74\\n46 19\\n53 93\\n47 55\\n55 89\\n76 56\\n62 88\\n62 32\\n78 41\\n44 9\\n32 14\\n9 48\\n43 68\\n58 93\\n37 18\\n94 21\\n41 81\\n28 38\\n\",\n    \"69 9\\n39 15\\n70 44\\n90 89\\n84 58\\n83 97\\n24 28\\n90 18\\n7 96\\n43 86\\n99 50\\n77 12\\n12 34\\n100 19\\n21 86\\n55 30\\n99 29\\n26 92\\n82 67\\n78 14\\n64 16\\n98 12\\n31 39\\n36 86\\n73 36\\n87 29\\n42 23\\n58 15\\n35 52\\n91 56\\n39 6\\n88 45\\n38 36\\n57 12\\n79 71\\n40 33\\n98 42\\n34 36\\n23 79\\n69 68\\n50 47\\n23 6\\n22 90\\n96 79\\n88 55\\n63 85\\n83 25\\n15 1\\n15 72\\n96 70\\n56 44\\n87 34\\n24 5\\n85 71\\n92 97\\n97 52\\n60 40\\n84 18\\n50 32\\n89 78\\n16 36\\n15 2\\n56 98\\n23 28\\n51 69\\n15 17\\n52 57\\n63 52\\n25 26\\n25 47\\n\",\n    \"44 77\\n95 38\\n51 48\\n89 76\\n18 40\\n97 15\\n6 57\\n30 44\\n84 8\\n93 60\\n75 96\\n14 61\\n72 97\\n17 71\\n11 85\\n29 2\\n93 86\\n88 74\\n52 94\\n88 75\\n43 20\\n79 83\\n28 99\\n8 7\\n20 62\\n59 51\\n65 94\\n44 23\\n95 36\\n74 11\\n66 57\\n44 1\\n29 57\\n53 82\\n11 79\\n100 91\\n75 4\\n5 29\\n90 53\\n16 11\\n16 8\\n55 73\\n98 79\\n68 98\\n10 43\\n\",\n    \"62 37\\n33 3\\n7 38\\n3 4\\n80 48\\n27 5\\n38 4\\n1 89\\n81 25\\n11 42\\n63 19\\n68 99\\n17 90\\n43 33\\n51 62\\n24 8\\n64 87\\n78 56\\n61 21\\n70 79\\n38 91\\n97 96\\n38 74\\n100 96\\n39 70\\n90 62\\n62 53\\n96 8\\n42 30\\n93 38\\n99 44\\n32 67\\n24 61\\n84 8\\n41 35\\n28 4\\n53 77\\n52 23\\n72 42\\n13 3\\n66 61\\n15 1\\n10 78\\n61 10\\n1 3\\n100 52\\n21 98\\n12 30\\n91 95\\n32 46\\n4 30\\n60 10\\n86 55\\n98 63\\n67 56\\n70 9\\n63 83\\n62 84\\n47 24\\n80 22\\n27 98\\n49 78\\n61 98\\n\",\n    \"6 84\\n95 74\\n34 76\\n12 46\\n89 34\\n77 28\\n26 56\\n\",\n    \"1 10\\n10 10\\n\",\n    \"7 7\\n1 0\\n2 0\\n3 0\\n4 0\\n5 0\\n6 0\\n7 0\\n\",\n    \"1 9\\n9 0\\n\",\n    \"1 1\\n1 0\\n\",\n    \"1 9\\n9 1\\n\",\n    \"1 10\\n10 0\\n\",\n    \"1 2\\n2 1\\n\",\n    \"2 2\\n1 50\\n2 0\\n\",\n    \"2 3\\n2 10\\n3 0\\n\",\n    \"2 2\\n1 10\\n2 0\\n\",\n    \"2 10\\n9 10\\n1 0\\n\",\n    \"3 7\\n1 56\\n5 49\\n7 0\\n\",\n    \"2 1\\n1 50\\n1 0\\n\",\n    \"2 10\\n10 50\\n10 0\\n\",\n    \"2 10\\n9 20\\n10 20\\n\",\n    \"3 4\\n1 0\\n2 0\\n4 1\\n\",\n    \"2 2\\n2 0\\n3 1\\n\"\n  ],\n  \"outputs\": [\n    \"50\\n\",\n    \"-1\\n\",\n    \"0\\n\",\n    \"-1\\n\",\n    \"85\\n\",\n    \"-1\\n\",\n    \"43\\n\",\n    \"95\\n\",\n    \"4\\n\",\n    \"99\\n\",\n    \"99\\n\",\n    \"72\\n\",\n    \"-1\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"-1\\n\",\n    \"0\\n\",\n    \"-1\\n\",\n    \"50\\n\",\n    \"90\\n\",\n    \"90\\n\",\n    \"90\\n\",\n    \"51\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"80\\n\",\n    \"0\\n\",\n    \"0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/463/A", "starter_code": ""}
{"id": 1975, "question": "Fox Ciel and her friends are in a dancing room. There are n boys and m girls here, and they never danced before. There will be some songs, during each song, there must be exactly one boy and one girl are dancing. Besides, there is a special rule:  either the boy in the dancing pair must dance for the first time (so, he didn't dance with anyone before);  or the girl in the dancing pair must dance for the first time. \n\nHelp Fox Ciel to make a schedule that they can dance as many songs as possible.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 100) \u2014 the number of boys and girls in the dancing room.\n\n\n-----Output-----\n\nIn the first line print k \u2014 the number of songs during which they can dance. Then in the following k lines, print the indexes of boys and girls dancing during songs chronologically. You can assume that the boys are indexed from 1 to n, and the girls are indexed from 1 to m.\n\n\n-----Examples-----\nInput\n2 1\n\nOutput\n2\n1 1\n2 1\n\nInput\n2 2\n\nOutput\n3\n1 1\n1 2\n2 2\n\n\n\n-----Note-----\n\nIn test case 1, there are 2 boys and 1 girl. We can have 2 dances: the 1st boy and 1st girl (during the first song), the 2nd boy and 1st girl (during the second song).\n\nAnd in test case 2, we have 2 boys with 2 girls, the answer is 3.", "solutions": "[\"n, m = map(int, input().split())\\nprint(n + m - 1)\\nfor i in range(1, m + 1):\\n    print(1, i)\\nfor i in range(2, n + 1):\\n    print(i, 1)\", \"n,m = map(int, input().split())\\nprint(str(n+m-1))\\nfor i in range(1,m+1):\\n\\tprint('1 '+str(i))\\nfor i in range(2,n+1):\\n\\tprint(str(i)+' 1')\", \"boys,girls=input().split()\\n\\nboys=int(boys)\\ngirls=int(girls)\\n\\nprint(boys+girls-1)\\n\\nfor i in range(1,girls+1):\\n    print(1,i)\\n\\nfor i in range(2,boys+1):\\n    print(i,girls)\\n\\n\", \"def Comp(n,m):\\n    count = n+m-1\\n    print(str(count))\\n    print(\\\"1 1\\\")\\n    for i in range(2,m+1):\\n        print(\\\"1 \\\"+str(i))\\n    for i in range(2,n+1):\\n        print(str(i)+\\\" 1\\\")\\n\\n\\nComp(*list(map(int,input().split())))\\n\", \"import sys\\n\\ngot = list(map(int, input().split()))\\nboys = got[0]\\ngirls = got[1]\\nsys.stdout.write(str(boys + girls -1) + \\\"\\\\n\\\")\\nfor i in range(1, girls+1):\\n    sys.stdout.write(\\\"1 \\\" + str(i) + \\\"\\\\n\\\")\\nfor i in range(2, boys + 1):\\n    sys.stdout.write(str(i) + \\\" 1\\\\n\\\")\\n\", \"n,m = map(int,input().split())\\nii = set()\\njj = set()\\n\\nans = []\\nfor i in range(1,n+1):\\n    for j in range(1,m+1):\\n        if i not in ii or j not in jj:\\n            ans.append ((i,j))\\n            ii.add(i)\\n            jj.add(j)\\nprint(len(ans))\\nfor a,b in ans:\\n    print(a,b)\", \"boys, girls = list(map(int,input().split()))\\nh = 1\\ni = 1\\nprint(boys + girls -1)\\nwhile h <= boys:\\n    while i <= girls:\\n        print(h, i)\\n        i += 1\\n    h += 1\\n    if h > boys:\\n        break\\n    print(h, i-1)\\n\", \"\\ndef main():\\n        nm=input().split(\\\" \\\")\\n        n=int(nm[0])\\n        m=int(nm[1])\\n        nos=0\\n        pairs=[]\\n        for i in range(1):\\n                for j in range(m):\\n                        pairs.append([i+1,j+1]);\\n                        nos+=1\\n        for j in range(1,n):\\n                pairs.append([j+1,1])\\n                nos+=1\\n        print (nos)\\n        for i in pairs:\\n                pair=str(i[0])+\\\" \\\"+str(i[1])\\n                print (pair)\\ndef __starting_point(): main()\\n\\n\\n__starting_point()\", \"n, m = list(map(int, input().split()))\\nprint(n + m - 1)\\nfor i in range(1, m + 1):\\n    print(1, i)\\nfor i in range(2, n + 1):\\n    print(i, 1)\\n\", \"n, m = [int(x) for x in input().split()]\\nprint(n+m-1)\\nfor i in range(1, m+1):\\n  print(1, i)\\nfor i in range(2, n+1):\\n  print(i, 1)\\n\", \"n, m = list(map(int, input().split()))\\nprint(n + m - 1)\\n\\nfor i in range(1, m + 1):\\n    print(1, i)\\n\\nfor i in range(2, n + 1):\\n    print(i, 1)\\n\", \"input_list = [int(i) for i in input().split()]\\nn = input_list[0]\\nm = input_list[1]\\n\\nprint(n+m-1)\\nfor i in range(1,m+1):\\n    print(1, i)\\nfor i in range(2,n+1):\\n    print(i, m)\\n\", \"n,m = list(map (int, input().split()))\\nprint(n+m-1)\\nboys = list (range (1, n+1))\\ngirls = list (range (1, m+1))\\npath = list (zip (boys, girls))\\npath += list (zip (boys, girls[1:]))\\nif n < m:\\n  path += [(n,i) for i in girls[n+1:]]\\nelse:\\n  path += [(i,m) for i in boys[m:]]\\npath.sort()\\nfor x,y in path:\\n  print(x,y)\\n\", \"def main():\\n  x,y = map(int,input().split())\\n  cx = [0]*x\\n  cy = [0]*y\\n  \\n  print(x+y-1)\\n  for i in range(x):\\n    for j in range(y):\\n      if cx[i] == 0 or cy[j] == 0:\\n        print(i+1,j+1)\\n        cx[i] = 1\\n        cy[j] = 1\\n  \\nmain()\", \"n, m = map(int, input().split(' '))\\nprint(n + m - 1)\\nfor i in range(1, m + 1):\\n    print(1, i)\\nfor i in range(2, n + 1):\\n    print(i, 1)\", \"a, b = list(map(int, input().split()))\\nprint(a + b - 1)\\nprint(1, 1)\\nfor i in range (2, b + 1):\\n    print(1, i)\\nfor i in range (2, a + 1):\\n    print(i, 1)\\n    \\n\", \"def takeinput():\\n    b,g = list(map(int,input().split()))\\n    boy = [0]*b\\n    girl = [0]*g\\n    ans = [] \\n    sum = -1\\n    for i in range(b):\\n        for j in range(g):\\n            if boy[i]==0 or girl[j]==0:\\n                temp = i+j\\n                if temp>sum:\\n                    boy[i]=1\\n                    girl[j]=1\\n                    sum=temp\\n                    ans.append((i+1,j+1))\\n    return ans\\n\\ndef __starting_point():\\n    res = takeinput()\\n    print(len(res))\\n    for val in res:\\n        print(val[0],val[1])\\n\\n\\n__starting_point()\", \"n,m = list(map(int, input().split()))\\n\\nprint(n + m - 1)\\nfor i in range(m):\\n  print(\\\"1 \\\" + str(i + 1))\\nfor i in range(1, n):\\n  print(str(i + 1) + \\\" 1\\\")\\n\", \"a = list(map(int, input().split()))\\nb = [False for i in range(0, 101)]\\nf = [False for i in range(0, 101)]\\nsol = []\\n\\nfor i in range(1, a[0]+1):\\n    for j in range(1, a[1]+1):\\n        if not b[i] or not f[j]:\\n            b[i] = True\\n            f[j] = True\\n            sol.append((i,j))\\n\\nprint(len(sol))\\nfor x in sol:\\n    print(\\\"%i %i\\\" % x)\\n\", \"n, m = list(map(int, input().split()))\\nprint(n + m - 1)\\nif n + m == 1: print(1, 1)\\nelif m > 1:\\n    for i in range(1, n + 1): print(i, 1)\\n    for i in range(2, m + 1): print(1, i)\\nelse:\\n    for i in range(2, n + 1): print(i, 1)\\n    for i in range(1, m + 1): print(1, i)\\n\", \"n, m = map(int, input().split())\\nprint(n + m - 1)\\nfor i in range (1, n + 1): print(i, 1)\\nfor i in range (1, m): print(1, i + 1)\", \"__author__ = 'Ol4a'\\nm, d = list(map(int, input().split()))\\nk=m+d-1\\nprint(k)\\nfor i in range(1, d+1):\\n    print(1, i)\\nfor j in range(2, m+1):\\n    print(j, 1)\\n\\n\\n\\n\\n\\n\\n\", \"n, m = list(map(int, input().split()))\\n\\nprint(n + m - 1)\\n\\nfor i in range(n):\\n    print(i + 1, 1)\\n    \\nfor i in range(1, m):\\n    print(1, i + 1)\\n\", \"import sys\\n\\ntmp = list(map(int, input().split()))\\nm = tmp[0]\\nn = tmp[1]\\n\\nprint(m+n-1)\\n\\nfor i in range(1, m+1):\\n    print(i, 1)\\n\\nfor i in range(2, n+1):\\n    print(1, i)\\n\", \"n, m = list(map(int, input().split()))\\n\\nprint(n + m - 1)\\n\\nfor i in range(n):\\n    print(i + 1, 1)\\n\\nfor j in range(1, m, 1):\\n    print(1, j + 1)\\n\"]", "input_output": "{\"inputs\": [\"2 1\\n\", \"2 2\\n\", \"1 1\\n\", \"2 3\\n\", \"4 4\\n\", \"1 12\\n\", \"12 1\\n\", \"24 6\\n\", \"25 5\\n\"], \"outputs\": [\"2\\n1 1\\n2 1\\n\", \"3\\n1 1\\n1 2\\n2 2\\n\", \"1\\n1 1\\n\", \"4\\n1 1\\n1 2\\n1 3\\n2 3\\n\", \"7\\n1 1\\n1 2\\n1 3\\n1 4\\n4 4\\n3 4\\n2 4\\n\", \"12\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n1 11\\n1 12\\n\", \"12\\n1 1\\n12 1\\n11 1\\n10 1\\n9 1\\n8 1\\n7 1\\n6 1\\n5 1\\n4 1\\n3 1\\n2 1\\n\", \"29\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n24 6\\n23 6\\n22 6\\n21 6\\n20 6\\n19 6\\n18 6\\n17 6\\n16 6\\n15 6\\n14 6\\n13 6\\n12 6\\n11 6\\n10 6\\n9 6\\n8 6\\n7 6\\n6 6\\n5 6\\n4 6\\n3 6\\n2 6\\n\", \"29\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n25 5\\n24 5\\n23 5\\n22 5\\n21 5\\n20 5\\n19 5\\n18 5\\n17 5\\n16 5\\n15 5\\n14 5\\n13 5\\n12 5\\n11 5\\n10 5\\n9 5\\n8 5\\n7 5\\n6 5\\n5 5\\n4 5\\n3 5\\n2 5\\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/322/A", "starter_code": ""}
{"id": 437, "question": "3R2 - Standby for Action\n\nOur dear Cafe's owner, JOE Miller, will soon take part in a new game TV-show \"1 vs. $n$\"!\n\nThe game goes in rounds, where in each round the host asks JOE and his opponents a common question. All participants failing to answer are eliminated. The show ends when only JOE remains (we assume that JOE never answers a question wrong!).\n\nFor each question JOE answers, if there are $s$ ($s > 0$) opponents remaining and $t$ ($0 \\le t \\le s$) of them make a mistake on it, JOE receives $\\displaystyle\\frac{t}{s}$ dollars, and consequently there will be $s - t$ opponents left for the next question.\n\nJOE wonders what is the maximum possible reward he can receive in the best possible scenario. Yet he has little time before show starts, so can you help him answering it instead?\n\n\n-----Input-----\n\nThe first and single line contains a single integer $n$ ($1 \\le n \\le 10^5$), denoting the number of JOE's opponents in the show.\n\n\n-----Output-----\n\nPrint a number denoting the maximum prize (in dollars) JOE could have.\n\nYour answer will be considered correct if it's absolute or relative error won't exceed $10^{-4}$. In other words, if your answer is $a$ and the jury answer is $b$, then it must hold that $\\frac{|a - b|}{max(1, b)} \\le 10^{-4}$.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1.000000000000\n\nInput\n2\n\nOutput\n1.500000000000\n\n\n\n-----Note-----\n\nIn the second example, the best scenario would be: one contestant fails at the first question, the other fails at the next one. The total reward will be $\\displaystyle \\frac{1}{2} + \\frac{1}{1} = 1.5$ dollars.", "solutions": "[\"n=int(input())\\ntot=0\\nfor i in range(n):\\n    tot+=1/(i+1)\\nprint(tot)\\n\", \"a=int(input())\\ns=0\\nfor i in range(a):\\n    s+=1/(i+1)\\nprint(s)\\n\", \"n = int(input())\\nans = 0\\nfor i in range(n, 0, -1):\\n    ans += 1 / i\\nprint(ans)\\n\", \"a = int(input())\\nsu = 0\\nfor i in range(1, a + 1):\\n    su += 1/i\\nprint(su)\", \"n, ans = int(input()), 0\\nfor i in range(1, n + 1):\\n    ans += (1 / i)\\nprint('{:.12f}'.format(ans))\\n\", \"n = int(input())\\nres = 0\\nwhile (n):\\n    res += 1 / n\\n    n -= 1\\nprint(res)\", \"n = int(input())\\nans = 0\\nfor i in range(1, n+1):\\n    ans += 1 / i\\n\\nprint(ans)\\n\", \"n = int(input())\\ntotal = 0\\nfor i in range(1, n+1):\\n\\ttotal += 1/i\\nprint(total)\", \"def main():\\n    n = int(input())\\n    ans = 0\\n    for i in range(1,n+1):\\n        ans += (1/i)\\n\\n    print(ans)\\n\\n\\nmain()\\n\", \"n = int(input())\\nans = 1\\nfor i in range(1,n):\\n\\tans += 1/(i+1)\\nprint(ans)\", \"\\nn = int(input())\\n\\ns = 0\\n\\nfor i in range(1, n + 1):\\n\\ts += 1/i\\n\\nprint(s)\\n\", \"n = int(input())\\nans = 0\\nwhile n != 0:\\n    ans += 1 / n\\n    n -= 1\\nprint(ans)\", \"n = int(input())\\nans = 0\\nfor i in range(1, n+1):\\n\\tans += 1/i\\nprint(ans)\", \"n = int(input())\\n\\nans = 0.0\\nfor i in range(1, n + 1):\\n    ans += 1.0 / i\\n\\nprint(ans)\", \"n = int(input())\\n\\nans = 0\\nfor i in range(n):\\n    i = n-i\\n    ans += 1 / i\\n\\nprint (ans)\\n\", \"n=int(input())\\ndef sum(n):\\n    i = 1\\n    s = 0.0\\n    for i in range(1, n+1):\\n        s = s + 1/i\\n    return s\\n\\nprint(sum(n))\", \"n = int(input())\\nans = 0\\nfor i in range(1, n + 1):\\n    ans += (1 / i)\\nprint(ans)\", \"#!/usr/bin/env python3\\nimport sys\\nsys.setrecursionlimit(10**8)\\ninput = sys.stdin.readline\\n \\nn = int(input())\\nans = 0\\nfor i in range(n, 0, -1):\\n    ans += 1 / i\\nprint(ans)\", \"n = int(input())\\ns = 0\\nfor i in range(1, n + 1):\\n\\ts += 1 / i\\nprint(s)\\n\", \"n = int(input())\\nans = 0\\nfor i in range(1, n+1):\\n    ans += 1/i\\n\\nprint(ans)\", \"n = int(input())\\n\\nsm = 0\\nfor i in range(1, n + 1):\\n    sm += 1 / i\\n\\nprint(sm)\\n\", \"def main():\\n    n = int(input())\\n    \\n    ans = 0\\n    \\n    for i in range(1, n + 1):\\n        ans += 1/i\\n    \\n    print(ans)\\n    \\n\\nmain()\", \"n = int(input())\\ns = 0\\nfor i in range(1,n+1):\\n    s += 1/i\\nprint(\\\"%.10f\\\" %s)\"]", "input_output": "{\n  \"inputs\": [\n    \"1\\n\",\n    \"2\\n\",\n    \"100000\\n\",\n    \"3\\n\",\n    \"4\\n\",\n    \"5\\n\",\n    \"99999\\n\",\n    \"6\\n\",\n    \"7\\n\",\n    \"8\\n\",\n    \"9\\n\",\n    \"10\\n\",\n    \"11\\n\",\n    \"12\\n\",\n    \"13\\n\",\n    \"14\\n\",\n    \"15\\n\",\n    \"16\\n\",\n    \"17\\n\",\n    \"18\\n\",\n    \"19\\n\",\n    \"20\\n\",\n    \"21\\n\",\n    \"22\\n\",\n    \"23\\n\",\n    \"71\\n\",\n    \"99\\n\",\n    \"43\\n\",\n    \"67\\n\",\n    \"368\\n\",\n    \"696\\n\",\n    \"920\\n\",\n    \"244\\n\",\n    \"7660\\n\",\n    \"9788\\n\",\n    \"8212\\n\",\n    \"1340\\n\",\n    \"10494\\n\",\n    \"40862\\n\",\n    \"71229\\n\",\n    \"50225\\n\",\n    \"99990\\n\",\n    \"99991\\n\",\n    \"99992\\n\",\n    \"99993\\n\",\n    \"99994\\n\",\n    \"99995\\n\",\n    \"99996\\n\",\n    \"99997\\n\",\n    \"99998\\n\"\n  ],\n  \"outputs\": [\n    \"1.000000000000\\n\",\n    \"1.500000000000\\n\",\n    \"12.090146129863\\n\",\n    \"1.833333333333\\n\",\n    \"2.083333333333\\n\",\n    \"2.283333333333\\n\",\n    \"12.090136129863\\n\",\n    \"2.450000000000\\n\",\n    \"2.592857142857\\n\",\n    \"2.717857142857\\n\",\n    \"2.828968253968\\n\",\n    \"2.928968253968\\n\",\n    \"3.019877344877\\n\",\n    \"3.103210678211\\n\",\n    \"3.180133755134\\n\",\n    \"3.251562326562\\n\",\n    \"3.318228993229\\n\",\n    \"3.380728993229\\n\",\n    \"3.439552522641\\n\",\n    \"3.495108078196\\n\",\n    \"3.547739657144\\n\",\n    \"3.597739657144\\n\",\n    \"3.645358704763\\n\",\n    \"3.690813250217\\n\",\n    \"3.734291511087\\n\",\n    \"4.846921264680\\n\",\n    \"5.177377517640\\n\",\n    \"4.349998620602\\n\",\n    \"4.789352407376\\n\",\n    \"6.486656683372\\n\",\n    \"7.123283544012\\n\",\n    \"7.402132714749\\n\",\n    \"6.076431670812\\n\",\n    \"9.521048200367\\n\",\n    \"9.766179171553\\n\",\n    \"9.590628328312\\n\",\n    \"7.778013645765\\n\",\n    \"9.835822254666\\n\",\n    \"11.195183715959\\n\",\n    \"11.750878002343\\n\",\n    \"11.401493809753\\n\",\n    \"12.090046125363\\n\",\n    \"12.090056126263\\n\",\n    \"12.090066127063\\n\",\n    \"12.090076127763\\n\",\n    \"12.090086128363\\n\",\n    \"12.090096128863\\n\",\n    \"12.090106129263\\n\",\n    \"12.090116129563\\n\",\n    \"12.090126129763\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1293/B", "starter_code": ""}
{"id": 2742, "question": "You have recently acquired a new job at the Bank for Acquiring Peculiar Currencies. Here people can make payments, and deposit or withdraw money in all kinds of strange currencies. At your first day on the job you help a customer from Nijmegia, a small insignificant country famous for its enormous coins with values equal to powers of $10$, that is, $1, 10, 100, 1000$, etc. This customer wants to make a rather large payment, and you are not looking forward to the prospect of carrying all those coins to and from the vault.\n\nYou therefore decide to think things over first. You have an enormous supply of Nijmegian coins in reserve, as does the customer (most citizens from Nijmegia are extremely strong). You now want to minimize the total number of coins that are exchanged, in either direction, to make the exact payment the customer has to make.\n\nFor example, if the customer wants to pay $83$ coins there are many ways to make the exchange. Here are three possibilities:Option 1.\n\nThe customer pays $8$ coins of value $10$, and $3$ coins of value $1$. This requires exchanging $8 + 3 = 11$ coins.Option 2.\n\nThe customer pays a coin of value $100$, and you return a coin of value $10$, and $7$ coins of value $1$. This requires exchanging $1 + 1 + 7 = 9$ coins.Option 3.\n\nThe customer pays a coin of value $100$, and $3$ coins of value $1$. You return $2$ coins of value $10$. This requires exchanging $1 + 3 + 2 = 6$ coins.\n\nIt turns out the last way of doing it requires the least coins possible.\n\n-----Input-----\n - A single integer $0\\leq n < 10^{1000}$, the amount the customer from Nijmegia has to pay.\n\n-----Output-----\n - Output the minimum number of coins that have to be exchanged to make the required payment.\n\n-----Examples-----\nSample Input 1:\n83\nSample Output 1:\n6\n\nSample Input 2:\n13\nSample Output 2:\n4\n\nSample Input 3:\n0\nSample Output 3:\n0", "solutions": "", "input_output": "{\n    \"inputs\": [\n        \"83\\n\",\n        \"13\\n\",\n        \"0\\n\",\n        \"12345678987654321\\n\"\n    ],\n    \"outputs\": [\n        \"6\\n\",\n        \"4\\n\",\n        \"0\\n\",\n        \"42\\n\"\n    ]\n}", "difficulty": "interview", "url": "https://open.kattis.com/problems/efficientexchange", "starter_code": ""}
{"id": 2209, "question": "Pushok the dog has been chasing Imp for a few hours already. $48$ \n\nFortunately, Imp knows that Pushok is afraid of a robot vacuum cleaner. \n\nWhile moving, the robot generates a string t consisting of letters 's' and 'h', that produces a lot of noise. We define noise of string t as the number of occurrences of string \"sh\" as a subsequence in it, in other words, the number of such pairs (i, j), that i < j and $t_{i} = s$ and $t_{j} = h$. \n\nThe robot is off at the moment. Imp knows that it has a sequence of strings t_{i} in its memory, and he can arbitrary change their order. When the robot is started, it generates the string t as a concatenation of these strings in the given order. The noise of the resulting string equals the noise of this concatenation.\n\nHelp Imp to find the maximum noise he can achieve by changing the order of the strings.\n\n\n-----Input-----\n\nThe first line contains a single integer n (1 \u2264 n \u2264 10^5)\u00a0\u2014 the number of strings in robot's memory.\n\nNext n lines contain the strings t_1, t_2, ..., t_{n}, one per line. It is guaranteed that the strings are non-empty, contain only English letters 's' and 'h' and their total length does not exceed 10^5.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the maxumum possible noise Imp can achieve by changing the order of the strings.\n\n\n-----Examples-----\nInput\n4\nssh\nhs\ns\nhhhs\n\nOutput\n18\n\nInput\n2\nh\ns\n\nOutput\n1\n\n\n\n-----Note-----\n\nThe optimal concatenation in the first sample is ssshhshhhs.", "solutions": "[\"import functools\\n\\nn = int(input())\\n\\narr = [input() for i in range(n)]\\n\\ndef compare(s1, s2):\\n    a = s1.count('s')\\n    b = s2.count('s')\\n\\n    if (a*len(s2)) < b*len(s1):\\n        return 1\\n    return -1\\n\\narr = sorted(arr, key=functools.cmp_to_key(compare))\\n\\ns = ''.join(arr)\\nc = 0\\nt = 0\\n\\nfor char in s:\\n    if char == 's':\\n        c += 1\\n    elif char == 'h':\\n        t += c\\nprint(t)\\n\\n\", \"import sys\\n\\n#f = open('input', 'r')\\nf = sys.stdin\\n\\nn = int(f.readline())\\ns = [f.readline().strip() for _ in range(n)]\\ns = [(x, x.count('s'), x.count('h')) for x in s]\\ns = sorted(s, key=lambda x: x[2]/float(x[1]+0.00000001))\\ns = ''.join(x[0] for x in s)\\n\\ncs = 0\\nans = 0\\nfor x in s:\\n  if x == 's':\\n    cs += 1\\n  else:\\n    ans += cs\\nprint(ans)\\n\", \"import sys\\n\\nf  = sys.stdin\\n\\nans = 0\\nod = 0\\n\\nn = int(f.readline())\\ns = [f.readline().strip() for _ in range(n)]\\ns = [(x,x.count('s'),x.count('h')) for x in s]\\ns = sorted(s,key = lambda x: x[2]/float(x[1] + 0.0000001))\\ns = ''.join(x[0] for x in s)\\n\\nfor x in s:\\n  if x == 's': \\n    od += 1\\n  else: \\n    ans += od\\nprint(ans)\\n\\n\", \"n = int(input())\\n\\ndef insert(s,t,ret,string,c,scount,tcount):\\n  maxval = s*tcount\\n  val = maxval\\n  maxpos = 0\\n  for i in range(len(string)):\\n    si, ti, ci = string[i]\\n    val = val + si*t*ci - s*ti*ci\\n    if maxval < val:\\n      maxval = val\\n      maxpos = i+1\\n  string = string[:maxpos] + [(s,t,c)] + string[maxpos:]\\n\\n  return ret+maxval*c, string\\n\\ndef count2(m, memo):\\n  if m in memo:\\n    return memo[m]\\n  s = 0\\n  ret = 0\\n  for c in m:\\n    if c == 's':\\n      s += 1\\n    else:\\n      ret += s\\n  memo[m] = (ret,s)\\n  return ret, s\\n\\n\\n\\nmemo = {}\\nret = 0\\nd = {}\\nfor _ in range(n):\\n  m = input()\\n  c,s = count2(m, memo)\\n  ret += c\\n  t = len(m)-s\\n  if (s,t) not in d:\\n    d[(s,t)] = 0\\n  ret += s*t*d[(s,t)]\\n  d[(s,t)] += 1\\n\\nstring = []\\nscount = 0\\ntcount = 0\\nfor s,t in d:\\n  c = d[(s,t)]\\n  ret, string = insert(s,t,ret,string,c,scount,tcount)\\n  scount += s*c\\n  tcount += t*c\\n\\n\\nprint(ret)\", \"n=int(input())\\ns=[]\\na=[]\\nfor i in range(n):\\n    s.append(input())\\n    p=0\\n    q=0\\n    for j in s[i]:\\n        if(j=='s'):\\n            p+=1\\n        elif(j=='h'):\\n            q+=1\\n    val=(q-p)/(q+p)\\n    a.append([val,i])\\na.sort()\\nfin=''\\nfor i in range(n):\\n    \\n    fin+=s[a[i][1]]\\n#print(fin)\\np=0\\nq=0\\nins=0\\nfor i in fin:\\n    if(i=='s'):\\n        q+=1\\n    elif(i=='h'):\\n        p+=1\\n        ins+=q\\nprint(ins)\\n    \\n\", \"import sys\\nfrom functools import cmp_to_key\\n\\ndef val (s):\\n    cnt = 0\\n    ret = 0\\n    for c in s:\\n        if c == \\\"s\\\":\\n            cnt += 1\\n        else:\\n            ret += cnt\\n    return ret\\n\\ndef cmp (a, b):\\n    v1 = val(a + b)\\n    v2 = val(b + a)\\n    if v1 < v2:\\n        return 1\\n    elif v1 > v2:\\n        return -1\\n    return 0\\n\\nans = \\\"\\\"\\ns = []\\n\\nn = int(input())\\n\\nfor i in range(0, n):\\n    t = input()\\n    s.append(t);\\n\\ns = sorted(s, key = cmp_to_key(cmp))\\n\\nans = \\\"\\\".join(s)\\n\\nprint(val(ans))\\n\", \"# Imports\\n\\n\\n##############################################\\n# Input\\nn = int(input())\\n\\nmas = []\\nall_h = 0\\nfor i in range(n):\\n    line = input()\\n    s = line.count('s')\\n    h = line.count('h')\\n    all_h += h\\n\\n    if h == 0:\\n        k = 100000\\n    else:\\n        k = s/h\\n    mas.append((k, line))\\n\\n\\n##############################################\\n# Main code\\nsor = sorted(mas, key=lambda val:val[0], reverse=True)\\nstr = ''\\n\\nfor item in sor:\\n    str += item[1]\\n\\n#print(str)\\n\\ncount = 0\\ncount_h = all_h\\nfor i in range(len(str)):\\n    if str[i] == 'h':\\n        count_h -= 1\\n\\n    else:\\n        count += count_h\\n\\n\\nprint(count)\\n\\n\\n\\n\\n\", \"import functools\\ndef cmp(a,b):\\n    if (a.count('s')/len(a))<(b.count('s')/len(b)) :\\n        return 1\\n\\n\\n\\n    else:\\n        return -1\\n\\nn=int(input())\\na=[input() for i in range(n)]\\n\\na=sorted(a,key=functools.cmp_to_key(cmp))\\n\\n\\n\\na=''.join(a)\\n\\nc=0\\nt=0\\n\\nfor i in a:\\n    if i=='s':\\n        c+=1\\n    else:\\n        t+=c\\n\\nprint(t)\\n\", \"n = int(input())\\na = []\\nfor i in range(n):\\n    k = input()\\n    s,t = 0,0\\n    for j in k:\\n        if j == 's':\\n            s += 1\\n        else:\\n            t += 1\\n    if t > 0:\\n        a.append([k,s/t])\\n    else:\\n        a.append([k,100000])\\na.sort(key = lambda x: x[1])\\na = list(reversed(a))\\nl = a[0][0][0]\\nx = 0\\nm =[]\\nfor i in a:\\n    for j in i[0]:\\n        if j != l:\\n            m.append(x)\\n            x = 1\\n            l = j\\n        else:\\n            x += 1\\nm.append(x)\\nif a[0][0][0] == 'h':\\n    m = m[1:]\\np,q = [],[]\\ne = 0\\nz = len(m)\\nfor i in range(z):\\n    if i % 2 == 0:\\n        p.append(m[i])\\nm = list(reversed(m))\\nif z % 2 == 1:\\n    m = m[1:]\\n    z -= 1\\nfor i in range(z):\\n    if i % 2 == 0:\\n        e += m[i]\\n        q.append(e)\\nq = list(reversed(q))\\nans = 0\\nfor i in range(z//2):\\n    ans += p[i]*q[i]\\nprint(ans)\", \"import functools\\n\\nn = int(input())\\n\\nt = [input() for i in range(n)]\\n\\n\\ndef compare(s1, s2):\\n    if (s1.count('s') * len(s2)) < (s2.count('s') * len(s1)):\\n        return 1\\n    else:\\n        return -1\\n\\n\\nt = sorted(t, key=functools.cmp_to_key(compare))\\ns = ''.join(t)\\n\\nc = 0\\nz = 0\\n\\nfor char in s:\\n    if char == 's':\\n        c += 1\\n    elif char == 'h':\\n        z += c\\nprint(z)\\n\", \"import sys\\n\\nf=sys.stdin\\n\\nn=int(f.readline())\\ns=[f.readline().strip() for i in range(n)]\\ns=[(x,x.count('s'),x.count('h')) for x in s]\\ns=sorted(s,key=lambda x:-x[1]/(x[2]+0.0001))\\ns=''.join(x[0] for x in s)\\nans,tmp=0,0\\nfor x in s:\\n\\tif x=='h':\\n\\t\\tans+=tmp\\n\\telse:\\n\\t\\ttmp+=1\\nprint(ans)\", \"n = int(input())\\ns = [input() for i in range(n)]\\ns = [(x, x.count(\\\"s\\\"), x.count(\\\"h\\\")) for x in s]\\ns.sort(key = lambda x: x[2] / float(x[1] + 1e-6))\\ns = ''.join(x[0] for x in s)\\n\\npre, ans = 0, 0\\nfor x in s:\\n    if (x == \\\"s\\\"):\\n        pre += 1\\n    else:\\n        ans += pre\\nprint(ans)\", \"n = int(input())\\nts = []\\nres = 0\\nfor _ in range(n):\\n    i = input().strip()\\n    m_res = 0\\n    s_count = 0\\n    for c in i:\\n        if c == 's':\\n            s_count += 1\\n        else:\\n            m_res += s_count\\n    res += m_res\\n    ts.append((i.count('s'), i.count('h')))\\n\\nts = sorted(ts, key=lambda k: float(k[0]) / float(k[1]) if k[1] else float('inf'), reverse=True)\\n\\nss = [s for s, h in ts]\\nhs2 = [h for s, h in ts]\\nhs = [0 for _ in ts]\\n\\nfor i in range(n-2,-1,-1):\\n    hs[i] = hs2[i + 1] + hs[i+1]\\n#print(ss, hs2, hs)\\n\\nfor i in range(n):\\n    res += ss[i] * hs[i]\\nprint(res)\\n\", \"import sys\\nimport functools\\n\\ndef sdiff(a, b):\\n    nas, nah, nbs, nbh = 0, 0, 0, 0\\n\\n    for c in a:\\n        if c == 's':\\n            nas += 1\\n        elif c == 'h':\\n            nah += 1\\n\\n    for c in b:\\n        if c == 's':\\n            nbs += 1\\n        elif c == 'h':\\n            nbh += 1\\n\\n    return nbs * nah - nas * nbh\\n\\nn = int(sys.stdin.readline().strip())\\ns = sorted(sys.stdin.readlines(), key=functools.cmp_to_key(sdiff))\\n\\nr, rs = 0, 0\\n\\nfor ss in s:\\n    for c in ss:\\n        if c == 's':\\n            rs += 1\\n        elif c == 'h':\\n            r += rs\\n\\nprint(r)\\n\", \"\\\"\\\"\\\"\\nSay I have two strings, u and v.\\nLet s(x) be the number of 's's in x.\\nLet h(x) be the number of 'h's in x.\\nLet sh(x) be the number of 'sh' subsequences in x.\\nThen\\n    sh(uv) = sh(u) + sh(v) + s(u)*h(v)\\n    sh(vu) = sh(v) + sh(u) + s(v)*h(u)\\nSo we want uv if s(u)*h(v) > s(v)*h(u), else vu.\\n\\\"\\\"\\\"\\n\\n\\nfrom functools import cmp_to_key\\n\\n\\nn = int(input())\\nstrings = [input() for _ in range(n)]\\n\\n\\nstrings = [(s, s.count(\\\"s\\\"), s.count(\\\"h\\\")) for s in strings]\\n\\n\\ndef compare(u, v):\\n    _, su, hu = u\\n    _, sv, hv = v\\n    suxhv = su*hv\\n    svxhu = sv*hu\\n    if suxhv > svxhu:\\n        return -1\\n    elif svxhu > suxhv:\\n        return 1\\n    else:\\n        return 0\\n\\n\\nstrings.sort(key=cmp_to_key(compare))\\n\\n\\nnoise = 0\\nss = 0\\nfor string, _, _ in strings:\\n    for c in string:\\n        if c == \\\"s\\\":\\n            ss += 1\\n        else:\\n            noise += ss\\n\\nprint(noise)\\n\", \"n = int(input())\\na = []\\nfor i in range(n):\\n    s = input()\\n    l = 0\\n    for c in s:\\n        if c==\\\"s\\\":\\n            l+=1\\n    a.append((s, l/len(s)))\\na.sort(key=lambda x: x[1], reverse=True)\\nns = 0\\nans = 0\\nfor st, _ in a:\\n    for c in st:\\n        if c == 's':\\n            ns += 1\\n        else:\\n            ans += ns\\nprint(ans)\", \"def mycmp(a,b):\\n\\tif (a[0]*b[1]>b[0]*a[1]):\\n\\t\\treturn -1\\n\\treturn 1\\n\\nn=int(input())\\na=[]\\nans=0\\nfor i in range(1,n+1):\\n\\tstr=input()\\n\\ttotlen=len(str)\\n\\ts=h=0\\n\\tfor j in range(0,totlen):\\n\\t\\tif (str[j]=='s'):\\n\\t\\t\\ts=s+1\\n\\t\\telse:\\n\\t\\t\\th=h+1\\n\\t\\t\\tans=ans+s\\n\\ttmp=0\\n\\tif (h==0):\\n\\t\\ttmp=1e18\\n\\telse:\\n\\t\\ttmp=s/h\\n\\ta.append((int(s),int(h),tmp))\\n\\t#print(s,h)\\na.sort(key=lambda x:x[2],reverse=True)\\nsum=0\\nfor i in range(0,len(a)):\\n\\tans=ans+sum*a[i][1]\\n\\tsum=sum+a[i][0]\\nprint(ans)\\n\", \"#input\\nn=int(input())\\n\\na=[]\\nfor i in range(0,n):\\n    a.append(input())\\n\\n#calculation\\nnoise=0\\n\\ndef calc_noise(str):\\n    result = 0\\n    \\n    struct =[]  \\n    struct.append(0)\\n    c = \\\"s\\\"\\n    j = 0\\n    str.lstrip(\\\"h\\\")\\n    for i in range(0,len(str)):\\n        if str[i]==c:\\n            struct[j] +=  1\\n        else:\\n            c = str[i]\\n            struct.append(1)\\n            j += 1\\n    \\n    s = 0\\n    for i in range(0, len(struct)):\\n        if i%2!=0:\\n            result += s*struct[i]\\n        else:\\n            s += struct[i]\\n    return result        \\n    \\n\\nv=[]\\nfor i in range(0,n):\\n    cs=a[i].count(\\\"s\\\")\\n    ch=len(a[i]) - cs\\n    sound = calc_noise(a[i])\\n    if cs==0:\\n        v.append([i,-100000, 0])\\n    else:\\n        if ch==0:\\n            v.append([i,100000, 0])\\n        else:\\n            v.append([i,cs/ch, sound])\\n            \\nv.sort(key=lambda x: x[2], reverse=1)             \\nv.sort(key=lambda x: x[1], reverse=1)      \\n\\nstr = \\\"\\\"\\nfor i in range(0,n):\\n    str += a[v[i][0]] \\nnoise = calc_noise(str)\\n    \\n#output\\n\\nprint(noise)\", \"n=int(input())\\na=[input().strip() for i in range(n)]\\na=[(z,z.count('s'),z.count('h')) for z in a]\\na=sorted(a, key=lambda p: - p[1]/(p[2]+0.000001) )\\ns=\\\"\\\".join( z[0] for z in a )\\nans,kols=0,0\\nfor c in s:\\n    if c=='s':\\n        kols+=1\\n    else:\\n        ans+=kols\\nprint(ans)\\n\", \"def key(x):\\n    s = x.count('s')\\n    return s/len(x)\\n\\n\\ndef sh_produce(x):\\n    x = str(x)\\n    sh = [0 for j in range(len(x))]\\n    if x[-1] == 'h':\\n        sh[-1] = 1\\n    for i in range(len(x)-2, -1, -1):\\n        if x[i] == 'h':\\n            sh[i] = sh[i+1] + 1\\n        else:\\n            sh[i] = sh[i+1]\\n    sh_num = 0\\n    for i in range(len(x)):\\n        if x[i] == 's':\\n            sh_num += sh[i]\\n    return sh_num\\nn = int(input())\\ninput_list = []\\nfor i in range(n):\\n    tmp = input()\\n    input_list.append(tmp)\\ninput_list = sorted(input_list, key=key, reverse=True)\\nres = ''.join(input_list)\\n\\nprint(sh_produce(res))\\n\\n\", \"# n = int(input())\\n# occurences = [''] * n\\n# t = [0] * n\\n\\n# for i in range(n):\\n#     s = input()\\n#     occurences[i] = s\\n#     num_s = s.count('s')\\n#     num_h = s.count('h')\\n#     if num_h>0:\\n#         t[i]=num_s/num_h\\n#     else:\\n#         t[i]=10000000\\n\\n# order = list(range(n))\\n# order.sort(reverse=True,key=lambda i:t[i])\\n# dum = ''\\n# for i in order:\\n#     dum += occurences[i]\\n\\n# a = 0\\n# b = 0\\n# for c in dum:\\n#     if c=='s':\\n#         a+=1\\n#     else:\\n#         b+=a\\n# print(b)\\nimport sys\\nimport functools\\n\\ndef sdiff(a, b):\\n    nas, nah, nbs, nbh = 0, 0, 0, 0\\n\\n    for c in a:\\n        if c == 's':\\n            nas += 1\\n        elif c == 'h':\\n            nah += 1\\n\\n    for c in b:\\n        if c == 's':\\n            nbs += 1\\n        elif c == 'h':\\n            nbh += 1\\n\\n    return nbs * nah - nas * nbh\\n\\nn = int(sys.stdin.readline().strip())\\ns = sorted(sys.stdin.readlines(), key=functools.cmp_to_key(sdiff))\\n\\nr, rs = 0, 0\\n\\nfor ss in s:\\n    for c in ss:\\n        if c == 's':\\n            rs += 1\\n        elif c == 'h':\\n            r += rs\\n\\nprint(r)\", \"def key(x):\\n    try:\\n        return x.count('h') / x.count('s')\\n    except ZeroDivisionError:\\n        return 10**9\\n\\n\\nn = int(input())\\nt = ''.join(sorted((input() for _ in range(n)), key=key))\\n\\nres, cnt = 0, 0\\nfor ti in t:\\n    if ti == 's':\\n        cnt += 1\\n    if ti == 'h':\\n        res += cnt\\nprint(res)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\nssh\\nhs\\ns\\nhhhs\\n\",\n    \"2\\nh\\ns\\n\",\n    \"6\\nh\\ns\\nhhh\\nh\\nssssss\\ns\\n\",\n    \"1\\ns\\n\",\n    \"10\\nsshshss\\nhssssssssh\\nhhhhhh\\nhhhs\\nhshhh\\nhhhhshsh\\nhh\\nh\\nshs\\nsshhshhss\\n\",\n    \"100\\nh\\nshh\\nh\\nhs\\nshh\\nhh\\nh\\nssh\\nhss\\nh\\nhh\\nh\\nh\\nh\\nh\\nh\\nh\\nh\\nh\\nh\\nhh\\nh\\nh\\nh\\nh\\nhhh\\nh\\nh\\nhhh\\nsh\\nhh\\nhs\\nh\\nh\\nshs\\nh\\nh\\nh\\nshh\\nhs\\nhs\\nh\\nh\\nh\\nhhh\\nh\\nhhs\\nhh\\nh\\nssh\\nh\\nh\\nhh\\nsh\\nh\\nhss\\nh\\nhh\\nsh\\nhh\\nhh\\nhhh\\nhs\\nh\\nh\\nh\\nshs\\nhs\\nshs\\nsh\\nh\\nh\\nhs\\nh\\nh\\nh\\nh\\nsh\\nssh\\nh\\nh\\nhh\\nhhh\\nssh\\nh\\nssh\\nhs\\nhh\\nh\\nhss\\nhhh\\nh\\nhhh\\nhss\\nhhh\\nh\\nhhh\\nsh\\nh\\nh\\n\"\n  ],\n  \"outputs\": [\n    \"18\\n\",\n    \"1\\n\",\n    \"40\\n\",\n    \"0\\n\",\n    \"613\\n\",\n    \"5058\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/922/D", "starter_code": ""}
{"id": 2228, "question": "During one of the space missions, humans have found an evidence of previous life at one of the planets. They were lucky enough to find a book with birth and death years of each individual that had been living at this planet. What's interesting is that these years are in the range $(1, 10^9)$! Therefore, the planet was named Longlifer.\n\nIn order to learn more about Longlifer's previous population, scientists need to determine the year with maximum number of individuals that were alive, as well as the number of alive individuals in that year. Your task is to help scientists solve this problem!\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the number of people.\n\nEach of the following $n$ lines contain two integers $b$ and $d$ ($1 \\le b \\lt d \\le 10^9$) representing birth and death year (respectively) of each individual.\n\n\n-----Output-----\n\nPrint two integer numbers separated by blank character, $y$ \u00a0\u2014 the year with a maximum number of people alive and $k$ \u00a0\u2014 the number of people alive in year $y$.\n\nIn the case of multiple possible solutions, print the solution with minimum year.\n\n\n-----Examples-----\nInput\n3\n1 5\n2 4\n5 6\n\nOutput\n2 2\n\nInput\n4\n3 4\n4 5\n4 6\n8 10\n\nOutput\n4 2\n\n\n\n-----Note-----\n\nYou can assume that an individual living from $b$ to $d$ has been born at the beginning of $b$ and died at the beginning of $d$, and therefore living for $d$ - $b$ years.", "solutions": "[\"n = int(input())\\n\\nmp = {}\\n\\nfor _ in range(n):\\n    a, b = map(int, input().split())\\n    mp[a] = mp.get(a, 0) + 1\\n    mp[b] = mp.get(b, 0) - 1\\n\\ncur = 0\\nmaxi = 0\\nmaxiy = 0\\n\\nfor i in sorted(mp):\\n    cur += mp[i]\\n\\n    if cur > maxi:\\n        maxi = cur\\n        maxiy = i\\n\\nprint(maxiy, maxi)\", \"# Program to find maximum guest\\n# at any time in a party\\ndef findMaxGuests(arrl, exit, n):\\n    # Sort arrival and exit arrays\\n    arrl.sort()\\n    exit.sort()\\n\\n    # guests_in indicates number of\\n    # guests at a time\\n    guests_in = 1\\n    max_guests = 1\\n    time = arrl[0]\\n    i = 1\\n    j = 0\\n\\n    # Similar to merge in merge sort to\\n    # process all events in sorted order\\n    while (i < n and j < n):\\n\\n        # If next event in sorted order is\\n        # arrival, increment count of guests\\n        if (arrl[i] <= exit[j]):\\n\\n            guests_in = guests_in + 1\\n\\n            # Update max_guests if needed\\n            if (guests_in > max_guests):\\n                max_guests = guests_in\\n                time = arrl[i]\\n\\n            # increment index of arrival array\\n            i = i + 1\\n\\n        else:\\n            guests_in = guests_in - 1\\n            j = j + 1\\n\\n    print( time,max_guests)\\n\\n\\n# Driver Code\\nt=int(input())\\narrl=[]\\nexit=[]\\nfor _ in range(t):\\n    a,b=list(map(int,input().strip().split(\\\" \\\")))\\n    arrl.append(a)\\n    exit.append(b-1)\\nn = len(arrl)\\nfindMaxGuests(arrl, exit, n)\\n\\n# This code is contributed\\n# by Shivi_Aggarwal\\n\", \"from bisect import bisect_right\\nn = int(input())\\nbs = []\\nds = []\\nfor i in range(n):\\n    b, d = map(int, input().split())\\n    bs.append(b)\\n    ds.append(d)\\nbs.sort()\\nds.sort()\\nmaxpop = 0\\nbestyear = 0\\nfor i in range(len(bs)):\\n    died_at_this_point = bisect_right(ds, bs[i])\\n    if maxpop < i+1 - died_at_this_point:\\n        maxpop = i+1 - died_at_this_point\\n        bestyear = bs[i]\\nprint(bestyear, maxpop)\", \"from sys import stdin\\n \\ndef input():\\n    return stdin.readline().strip()\\n\\nn = int(input())\\nbirth_arr = []\\ndeath_arr = []\\nfor i in range(n):\\n    b, d = list(map(int, input().split()))\\n    birth_arr.append(b)\\n    death_arr.append(d)\\n\\nbirth_arr = sorted(birth_arr)\\ndeath_arr = sorted(death_arr)\\n\\nnum_ppl = len(birth_arr)\\ncurr = 0\\ncurr_year = 0\\nmax_year = None\\nmax_ppl = 0\\nb_pointer = 0\\nd_pointer = 0\\n\\nwhile b_pointer < num_ppl:\\n    if birth_arr[b_pointer] < death_arr[d_pointer]:\\n        curr += 1\\n        curr_year = birth_arr[b_pointer]\\n        if curr > max_ppl:\\n            max_year = curr_year\\n            max_ppl = curr\\n        b_pointer += 1\\n    elif birth_arr[b_pointer] == death_arr[d_pointer]:\\n        curr_year = birth_arr[b_pointer]\\n        b_pointer += 1\\n        d_pointer += 1\\n    else:\\n        curr -= 1\\n        curr_year = death_arr[d_pointer]\\n        d_pointer += 1\\n\\nprint(f\\\"{max_year} {max_ppl}\\\")\", \"n = int(input())\\na = []\\nfor i in range(n):\\n    x, y = list(map(int, input().split()))\\n    a.append([x, 1])\\n    a.append([y, 0])\\na.sort()\\nc = 0\\nm = 0\\ny = 0\\nfor i in range(len(a)):\\n    if a[i][1] == 1:\\n        c += 1\\n    else:\\n        c -= 1\\n    if m < c:\\n        m = c\\n        y = a[i][0]\\nprint(y, m)\\n\\n\", \"\\nimport math\\nfrom sys import stdin\\nfrom sys import setrecursionlimit\\nsetrecursionlimit(100000)\\ndef put():  return  map(int, stdin.readline().split())\\nfor _ in range(1):\\n\\tn=int(input())\\n\\tstart=[]\\n\\tend=[]\\n\\tfor i in range(n):\\n\\t\\ta,b=put()\\n\\t\\tstart.append(a)\\n\\t\\tend.append(b)\\n\\tstart.sort()\\n\\tend.sort()\\n\\tnumalive=0\\n\\tstartyear=0\\n\\tindstart=0\\n\\tindend=0\\n\\tmx=0\\n\\twhile(indstart<n ):\\n\\t\\tif(start[indstart]<end[indend]):\\n\\t\\t\\tnumalive+=1\\n\\t\\t\\tindstart+=1\\n\\t\\t\\tif(numalive>mx):\\n\\t\\t\\t\\tmx=max(mx,numalive)\\n\\t\\t\\t\\tstartyear=start[indstart-1]\\n\\t\\telif(start[indstart]==end[indend]):\\n\\t\\t\\tindstart+=1\\n\\t\\t\\tindend+=1\\n\\t\\telse:\\n\\t\\t\\tnumalive-=1\\n\\t\\t\\tindend+=1\\n\\tprint(startyear,mx)\", \"n = int(input())\\ninterv = []\\nfor i in range(n):\\n   deb, fin = list(map(int, input().split()))\\n   interv.append((deb, +1))\\n   interv.append((fin, -1))\\n\\ninterv.sort()\\n\\nm = 0\\ny = 0\\nc = 0\\nfor (t, dx) in interv:\\n   c += dx\\n   if c > m:\\n      m = c\\n      y = t\\nprint(y, m)\\n\", \"n = int(input())\\nl1 = []\\nl2 = []\\nfor i in range(n):\\n    a,b = map(int,input().split())\\n    l1.append(a)\\n    l2.append(b)\\n\\nl1.sort(reverse=True)\\nl2.sort(reverse=True)\\n\\ncur = 0\\nmx = 0\\nans = 0\\n\\nwhile l1:\\n    if l1[-1] < l2[-1]:\\n        t = l1.pop()\\n        cur += 1\\n        if cur > mx:\\n            mx = cur\\n            ans = t\\n    else:\\n        l2.pop()\\n        cur-=1\\n\\nprint(ans,mx)\", \"n = int(input())\\nl1 = []\\nl2 = []\\nfor i in range(n):\\n    a,b = list(map(int,input().split()))\\n    l1.append(a)\\n    l2.append(b)\\nl1.sort()\\nl2.sort()\\nans = 0\\nkk = 0\\nc = 0\\ncc = 0\\ni = 0\\nwhile i<n:\\n    if l1[i]<l2[cc]:\\n        c+=1\\n        if c>ans:\\n            kk = l1[i]\\n            ans = c\\n        i+=1\\n    else:\\n        cc+=1\\n        c-=1\\n    \\nprint(kk,ans)\\n    \\n\", \"n = int(input())\\nmasb = []\\nmasd = []\\nfor i in range(n):\\n    z1, z2 = list(map(int, input().split()))\\n    masb.append(z1)\\n    masd.append(z2)\\nmasb.sort()\\nmasd.sort()\\nj = 0\\nk = 0\\ny = 0\\nmx = [0, 0]\\nfor i in range(len(masb)):\\n    y = masb[i]\\n    k += 1\\n    while y >= masd[j]:\\n        k -= 1\\n        j += 1\\n    if k > mx[1]:\\n        mx = [y, k]\\nprint(*mx)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n1 5\\n2 4\\n5 6\\n\",\n    \"4\\n3 4\\n4 5\\n4 6\\n8 10\\n\",\n    \"1\\n1 1000000000\\n\",\n    \"1\\n1 2\\n\",\n    \"3\\n1 2\\n2 4\\n2 4\\n\",\n    \"1\\n125 126\\n\"\n  ],\n  \"outputs\": [\n    \"2 2\\n\",\n    \"4 2\\n\",\n    \"1 1\\n\",\n    \"1 1\\n\",\n    \"2 2\\n\",\n    \"125 1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1424/G", "starter_code": ""}
{"id": 1540, "question": "The R2 company has n employees working for it. The work involves constant exchange of ideas, sharing the stories of success and upcoming challenging. For that, R2 uses a famous instant messaging program Spyke.\n\nR2 has m Spyke chats just to discuss all sorts of issues. In each chat, some group of employees exchanges messages daily. An employee can simultaneously talk in multiple chats. If some employee is in the k-th chat, he can write messages to this chat and receive notifications about messages from this chat. If an employee writes a message in the chat, all other participants of the chat receive a message notification.\n\nThe R2 company is conducting an audit. Now the specialists study effective communication between the employees. For this purpose, they have a chat log and the description of chat structure. You, as one of audit specialists, are commissioned to write a program that will use this data to determine the total number of message notifications received by each employee.\n\n\n-----Input-----\n\nThe first line contains three space-separated integers n, m and k (2 \u2264 n \u2264 2\u00b710^4;\u00a01 \u2264 m \u2264 10;\u00a01 \u2264 k \u2264 2\u00b710^5) \u2014 the number of the employees, the number of chats and the number of events in the log, correspondingly. \n\nNext n lines contain matrix a of size n \u00d7 m, consisting of numbers zero and one. The element of this matrix, recorded in the j-th column of the i-th line, (let's denote it as a_{ij}) equals 1, if the i-th employee is the participant of the j-th chat, otherwise the element equals 0. Assume that the employees are numbered from 1 to n and the chats are numbered from 1 to m.\n\nNext k lines contain the description of the log events. The i-th line contains two space-separated integers x_{i} and y_{i} (1 \u2264 x_{i} \u2264 n;\u00a01 \u2264 y_{i} \u2264 m) which mean that the employee number x_{i} sent one message to chat number y_{i}. It is guaranteed that employee number x_{i} is a participant of chat y_{i}. It is guaranteed that each chat contains at least two employees.\n\n\n-----Output-----\n\nPrint in the single line n space-separated integers, where the i-th integer shows the number of message notifications the i-th employee receives.\n\n\n-----Examples-----\nInput\n3 4 5\n1 1 1 1\n1 0 1 1\n1 1 0 0\n1 1\n3 1\n1 3\n2 4\n3 2\n\nOutput\n3 3 1 \nInput\n4 3 4\n0 1 1\n1 0 1\n1 1 1\n0 0 0\n1 2\n2 1\n3 1\n1 3\n\nOutput\n0 2 3 0", "solutions": "[\"n, m, k = map(int, input().split())\\nchats_ = []\\nfor i in range(n):\\n    a = list(map(int, input().split()))\\n    chats_.append(a)\\nsent = [0 for i in range(n)]\\nchats = [0 for i in range(m)]\\nfor i in range(k):\\n    a, b = map(int, input().split())\\n    sent[a - 1] += 1\\n    chats[b - 1] += 1\\nfor i in range(n):\\n    sum = 0\\n    for j in range(m):\\n        sum += chats_[i][j] * chats[j]\\n    sum -= sent[i]\\n    print(sum, end = ' ')\", \"n, m, k = map(int, input().split())\\na = [set() for i in range(m)]\\nb = [0 for i in range(n)] \\nd = [0 for i in range(m)]\\nfor i in range(n):\\n    s = list(map(int, input().split()))\\n    for j in range(m):\\n        if s[j]:\\n            a[j].add(i)\\nfor i in range(k):\\n    x, y = map(int, input().split())\\n    d[y - 1] += 1\\n    b[x - 1] -= 1\\nfor i in range(m):\\n    if d[i]:\\n        for elem in a[i]:\\n            b[elem] += d[i]        \\nfor i in range(n):\\n    print(b[i], end = ' ')\", \"n,m,k=map(int,input().split())\\nL=[]\\nfor i in range(n):\\n    L.append(list((map(int,input().split()))))\\n\\nK={}\\nfor i in range(m):\\n    K[i+1]=[]\\n    for j in range(n):\\n        if(L[j][i]==1):\\n            K[i+1].append(j+1)\\nAns=[0]*n\\nAnss=[0]*m\\nfor i in range(k):\\n    x,y=map(int,input().split())\\n    Anss[y-1]+=1\\n    Ans[x-1]-=1\\nfor i in range(n):\\n    for j in range(m):\\n        if(L[i][j]==1):\\n            Ans[i]+=Anss[j]\\nfor item in Ans:\\n    print(item,end=\\\" \\\")\\n\", \"n, m, k = map(int, input().split())\\nchatsmembers = []\\nchatkol = []\\nfor i in range(n):\\n    chatsmembers.append(list(map(int, input().split())))\\nchatkol = [0]*m\\nchatsents = [0]*n\\nfor i in range(k):\\n    a, b = map(int, input().split())\\n    chatsents[a - 1] += 1\\n    chatkol[b - 1] += 1\\nfor i in range(n):\\n    t = 0\\n    for j in range(m):\\n        if chatsmembers[i][j] == 1:\\n            t += chatkol[j]\\n    print(t - chatsents[i], end = ' ')\\n\", \"n,m,k = map(int,input().split())\\nmatrix = []\\nfor i in range(n):\\n    mat = list(map(int,input().split()))\\n    matrix.append(mat)\\nmat = [0 for i in range(m+1)]\\nans = [0 for i in range(n+1)]\\nfor i in range(k):\\n    a,b = map(int,input().split())\\n    mat[b-1] += 1\\n    ans[a-1] -= 1\\nfor i in range(n):\\n    s = sum([mat[j]  for j in range(m) if matrix[i][j]==1])\\n    print(ans[i]+s,end=\\\" \\\")\\n\", \"n, m, k = map(int, input().split())\\np, s, t = [[] for y in range(m)], [0] * n, [0] * m\\nfor x in range(n):\\n    for y, c in enumerate(input()[:: 2]):\\n        if c == '1': p[y].append(x)\\nfor i in range(k):\\n    x, y = map(int, input().split())\\n    s[x - 1] -= 1\\n    t[y - 1] += 1\\nfor y, d in enumerate(t):\\n    for x in p[y]: s[x] += d\\nprint(' '.join(map(str, s)))\", \"#!/usr/local/bin/python3\\nn, m, k = map(int, input().split())\\nroom = [[] for i in range(m)]\\nperson = []\\nresult = [0] * n\\nfor i in range(n):\\n    person.append(list(input().split()))\\nfor i in range(n):\\n    n_room = 0\\n    for n_be in person[i]:\\n        if n_be == '1':\\n            room[n_room].append(i)\\n        n_room += 1\\ncnt = [0] * m\\nfor i in range(k):\\n    n_person, n_room = map(int, input().split())\\n    n_person -= 1\\n    n_room -= 1\\n    result[n_person] -= 1\\n    cnt[n_room] += 1\\nfor n_room, n_cnt in enumerate(cnt):\\n    for i in room[n_room]:\\n        result[i] += n_cnt\\nprint(' '.join(map(str, result)))\", \"#!/usr/local/bin/python3\\nn, m, k = map(int, input().split())\\nroom = [[] for i in range(m)]; result = [0] * n; cnt = [0] * m\\nfor i in range(n):\\n    for n_room, n_be in enumerate(list(input().split())):\\n        if n_be == '1':\\n            room[n_room].append(i)\\nfor i in range(k):\\n    n_person, n_room = map(int, input().split())\\n    result[n_person-1] -= 1\\n    cnt[n_room-1] += 1\\nfor n_room, n_cnt in enumerate(cnt):\\n    for i in room[n_room]:\\n        result[i] += n_cnt\\nprint(' '.join(map(str, result)))\", \"R = lambda: map(int, input().split())\\nn, m, k = R()\\nchat = []\\nfor i in range(n):\\n    chat.append(list(R()))\\nman = [0] * n; room = [0] * m\\nfor i in range(k):\\n    a, b = R()\\n    man[a-1] += 1\\n    room[b-1] += 1\\nfor i in range(n):\\n    t = 0\\n    for j in range(m):\\n        if chat[i][j] == 1:\\n            t += room[j]\\n    print(t - man[i], end = ' ')\", \"R = lambda: map(int, input().split())\\nn, m, k = R()\\nchat = []\\nfor i in range(n):\\n    chat.append(list(R()))\\nman = [0] * n; room = [0] * m\\nfor i in range(k):\\n    a, b = R()\\n    man[a-1] += 1\\n    room[b-1] += 1\\nfor i in range(n):\\n    t = 0\\n    for j in range(m):\\n        if chat[i][j] == 1:\\n            t += room[j]\\n    print(t - man[i], end = ' ')\\n\", \"R = lambda:map(int, input().split())\\nn, m, k = R()\\na = [list(R()) for _ in range(n)]\\nb = [[0] * m for _ in range(n)]\\nc = [0] * m\\nfor i in range(k):\\n  x, y = R()\\n  x -= 1\\n  y -= 1\\n  c[y] += 1\\n  b[x][y] += 1\\nprint(\\\" \\\".join(map(str, (sum(c[j] - b[i][j] for j in range(m) if a[i][j] == 1) for i in range(n)))))\", \"R = lambda:map(int, input().split())\\nn, m, k = R()\\na = [list(R()) for _ in range(n)]\\nb = [0] * n\\nc = [0] * m\\nfor i in range(k):\\n  x, y = R()\\n  b[x - 1] += 1\\n  c[y - 1] += 1\\nprint(\\\" \\\".join(map(str, (sum(a[i][j] * c[j] for j in range(m)) - b[i] for i in range(n)))))\", \"n, m, k = map(int,input().split())\\nchats = list()\\nfor i in range(m):\\n    chats.append([set(),0])\\nemps = [0] * n\\nfor i in range(n):\\n    e = list(map(int,input().split()))\\n    for j in range(m):\\n        if e[j] == 1:\\n            chats[j][0].add(i)\\n\\nfor i in range(k):\\n    x,y = map(int,input().split())\\n    x -= 1; y -= 1\\n    chats[y][1] += 1\\n    emps[x] -= 1\\n\\nfor i in chats:\\n    for j in i[0]:\\n        emps[j] += i[1];\\n\\nfor i in range(n):\\n    print(emps[i], end = ' ')\", \"n, m, k = list(map(int, input().split()))\\na, nc, mc = [list(map(int, input().split())) for i in range(n)], [0] * n, [0] * m\\nfor i in range(k):\\n    x, y = list(map(int, input().split()))\\n    nc[x - 1] += 1\\n    mc[y - 1] += 1\\nprint(' '.join(map(str, (sum(mc[j] for j in range(m) if a[i][j]) - nc[i] for i in range(n)))))\\n\", \"# -*- coding: utf-8 -*-\\n\\\"\\\"\\\"\\nYL 2 B. K6nelogi\\n\\\"\\\"\\\"\\nn,m,k=list(map(int,input().split()))\\ntoo=dict()\\nchat=dict()\\nchat2=dict()\\nfor i in range(n):\\n    too[i]=0\\nfor i in range(m):\\n    chat2[i]=0 # Korda postitati\\nfor i in range(n):\\n    chat[i]=list(map(int,input().split()))# info inimese kohta\\nfor i in range(k):\\n    x,y=list(map(int,input().split()))\\n    chat2[y-1]+=1\\n    too[x-1]-=1\\n\\nout=[]\\nfor i in range(n):\\n    t2=0\\n    for e in range(m):\\n        if chat[i][e]: t2+=chat2[e]\\n    t=too[i]+t2\\n    out.append(str(t))\\nprint(' '.join(out))\", \"n,m,k=list(map(int,input().split()))\\ntoo=dict()\\nchat=dict()\\nchat2=dict()\\nfor i in range(n):\\n    too[i]=0\\n    chat[i]=list(map(int,input().split()))\\nfor i in range(m):\\n    chat2[i]=0 # Korda postitati\\nfor i in range(k):\\n    x,y=list(map(int,input().split()))\\n    chat2[y-1]+=1\\n    too[x-1]-=1\\n\\nout=[]\\nfor i in range(n):\\n    t2=0\\n    for e in range(m):\\n        if chat[i][e]: t2+=chat2[e]\\n    t=too[i]+t2\\n    out.append(str(t))\\nprint(' '.join(out))\", \"R = lambda:map(int, input().split())\\nn, m, k = R()\\na = [list(R()) for _ in range(n)]\\nb = [0] * n\\nc = [0] * m\\nfor i in range(k):\\n  x, y = R()\\n  b[x - 1] += 1\\n  c[y - 1] += 1\\nprint(\\\" \\\".join(map(str, (sum(a[i][j] * c[j] for j in range(m)) - b[i] for i in range(n)))))\", \"R = lambda:list(map(int, input().split()))\\n\\nn, m, k = R()\\n\\na = [list(R()) for _ in range(n)]\\n\\nb = [0] * n\\n\\nc = [0] * m\\n\\nfor i in range(k):\\n\\n  x, y = R()\\n\\n  b[x - 1] += 1\\n\\n  c[y - 1] += 1\\n\\nprint(\\\" \\\".join(map(str, (sum(a[i][j] * c[j] for j in range(m)) - b[i] for i in range(n)))))\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"n,m,k=input().split()\\nn=int(n)\\nm=int(m)\\nk=int(k)\\nl=[[0]*m]*n\\n\\nfor i in range(n):\\n    l[i]=list(map(int,input().split()))\\n\\nt=[[0]*2]*k\\ne=[0]*n\\nc=[0]*m\\n\\nfor i in range(k):\\n    t0,t1=map(int,input().split())\\n    e[t0-1]-=1\\n    c[t1-1]+=1\\n\\np=[\\\"\\\"]*n\\nfor i in range(n):\\n    for j in range(m):\\n        e[i]=e[i]+c[j]*l[i][j]\\n    p[i]=str(e[i])\\n\\nprint(\\\" \\\".join(p))\", \"n,m,k = [int(a) for a in input().split() ]\\ntable = []\\nfor i in range(n):\\n    table.append([int(a) for a in input().split() ])\\n\\n# print(table)\\nevent = []\\nfor i in range(k):\\n    event.append([int(a) for a in input().split() ])\\nmultiplier = [0]*m\\nsubtract = [0]*n\\nsumRes = [0]*n\\nfor i in range(k):\\n    sumRes[event[i][0]-1] -= 1\\n    multiplier[event[i][1]-1] += 1\\n\\nfor i in range(n):\\n    for j in range(m):\\n        sumRes[i] = sumRes[i] + multiplier[j] * table[i][j]\\n            \\nfor x in sumRes:\\n    print(x,end=\\\" \\\")\\n\\n\\n\\n \\n\\n\", \"\\nn, m, k = map(int, input().split())\\nchats_ = []\\nfor i in range(n):\\n    a = list(map(int, input().split()))\\n    chats_.append(a)\\nsent = [0 for i in range(n)]\\nchats = [0 for i in range(m)]\\nfor i in range(k):\\n    a, b = map(int, input().split())\\n    sent[a - 1] += 1\\n    chats[b - 1] += 1\\nfor i in range(n):\\n    sum = 0\\n    for j in range(m):\\n        sum += chats_[i][j] * chats[j]\\n    sum -= sent[i]\\n    print(sum, end = ' ')\\n\\n\\n\\n \\n\\n\", \"n,m,k=map(int,input().split())\\np=[]\\n\\nfor i in range(n):\\n    o=[int(w) for w in input().split()]\\n    p.append(o)\\n\\nt=[0]*n\\nr=[0]*m\\n\\nfor i in range(k):\\n    a,b=map(int,input().split())\\n    t[a-1]+=1\\n    r[b-1]+=1\\n\\nfor i in range(n):\\n    ans=0\\n    for j in range(m):\\n        if p[i][j]==1:\\n            ans+=r[j]\\n    print(ans-t[i],end=\\\" \\\")\"]", "input_output": "{\n  \"inputs\": [\n    \"3 4 5\\n1 1 1 1\\n1 0 1 1\\n1 1 0 0\\n1 1\\n3 1\\n1 3\\n2 4\\n3 2\\n\",\n    \"4 3 4\\n0 1 1\\n1 0 1\\n1 1 1\\n0 0 0\\n1 2\\n2 1\\n3 1\\n1 3\\n\",\n    \"2 1 1\\n1\\n1\\n1 1\\n\",\n    \"3 3 1\\n1 1 1\\n1 1 1\\n1 1 1\\n3 1\\n\",\n    \"3 2 1\\n0 1\\n1 0\\n1 1\\n1 2\\n\",\n    \"5 5 5\\n0 1 1 1 0\\n1 1 0 1 1\\n1 1 1 1 1\\n0 1 1 1 1\\n1 0 0 1 1\\n4 5\\n4 5\\n1 3\\n5 4\\n1 2\\n\",\n    \"4 5 6\\n1 1 1 1 1\\n1 1 1 0 1\\n1 0 1 1 1\\n1 0 1 1 1\\n2 3\\n2 5\\n1 2\\n4 5\\n4 5\\n4 1\\n\",\n    \"7 6 5\\n0 1 0 1 1 1\\n0 1 1 0 1 1\\n1 0 1 1 1 0\\n1 0 1 1 1 1\\n1 1 1 1 1 0\\n1 1 1 0 1 0\\n1 0 1 0 0 0\\n4 1\\n2 6\\n7 3\\n7 1\\n5 3\\n\",\n    \"3 3 4\\n1 1 1\\n0 0 0\\n1 1 1\\n1 1\\n3 1\\n3 2\\n3 3\\n\",\n    \"10 1 10\\n0\\n0\\n0\\n0\\n0\\n0\\n1\\n0\\n1\\n0\\n7 1\\n9 1\\n9 1\\n7 1\\n9 1\\n9 1\\n9 1\\n7 1\\n9 1\\n9 1\\n\",\n    \"2 1 1\\n1\\n1\\n1 1\\n\",\n    \"2 1 1\\n1\\n1\\n2 1\\n\",\n    \"3 1 2\\n1\\n1\\n0\\n1 1\\n2 1\\n\",\n    \"3 1 2\\n1\\n0\\n1\\n1 1\\n3 1\\n\",\n    \"3 1 2\\n0\\n1\\n1\\n2 1\\n3 1\\n\"\n  ],\n  \"outputs\": [\n    \"3 3 1 \",\n    \"0 2 3 0 \",\n    \"0 1 \",\n    \"1 1 0 \",\n    \"0 0 1 \",\n    \"1 4 5 3 2 \",\n    \"5 4 5 2 \",\n    \"1 2 4 4 3 4 2 \",\n    \"3 0 1 \",\n    \"0 0 0 0 0 0 7 0 3 0 \",\n    \"0 1 \",\n    \"1 0 \",\n    \"1 1 0 \",\n    \"1 0 1 \",\n    \"0 1 1 \"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/413/B", "starter_code": ""}
{"id": 2986, "question": "This problem is an extension of another Kattis problem - backspace. In that problem, every time we see a character \u2018<\u2019, it actually means that the \u2018Backspace\u2019 key is pressed and we undo the last character that was just typed.\n\n\nThe extension is as follows: Now, pressing a \u2018<\u2019 (the \u2018Backspace\u2019 key) when the (typing) cursor is at the front of the line does nothing. Now if we see a character \u2018[\u2019, it actually means that the \u2018Home\u2019 key is pressed and we move the (typing) cursor to the front of the line. Similarly, if we see a character \u2018]\u2019, it actually means that the \u2018End\u2019 key is pressed and we move the (typing) cursor the back of the line. For all other valid character in the input, it actually means that the corresponding key is pressed, we insert that character at the (typing) cursor position, and advance one position to the right the cursor accordingly.\n\n-----Input-----\nThe input starts with a line containing just one integer $T \\: (1 \\le T \\le 10)$, denoting the number of test cases.\n\n\nEach test case is a line containing the string that was written in the Text Editor Sim (Steven IMproved). The length of the string is at most $10^{6}$, and it will only contain lowercase letters from the English alphabet [\u2018$a$\u2019$\\; \\ldots \\; $\u2018$z$\u2019], digits [\u2018$0$\u2019$\\; \\ldots \\; $\u2018$9$\u2019], spaces, as well as some of the three special characters: \u2018<\u2019, \u2018[\u2019, or \u2018]\u2019.\n\n-----Output-----\nFor each test case, output one line containing the final string that is displayed on screen.\n\n-----Subtasks-----\n - $\\textbf{(27.5 points)}$: $1 \\le T \\le 10$, string length is at most $10^{3}$, there is no \u2018[\u2019, as seen in sample $1$.\n - $\\textbf{(32.5 points)}$: $1 \\le T \\le 10$, string length is at most $10^{3}$, there may be \u2018[\u2019, as seen in sample $2$.\n - $\\textbf{(40 points)}$: $1 \\le T \\le 4$, string length is at most $10^{6}$.\n\n-----Examples-----\nSample Input:\n1\nmy ]]name]] is]] steva<en]<n halim]]]]]\nSample Output:\nmy name is steven halim", "solutions": "", "input_output": "{\n    \"inputs\": [\n        \"1\\nmy ]]name]] is]] steva<en]<n halim]]]]]\\n\",\n        \"1\\n<<hate<<<<loves[steva<en ] cs2040c< and also cs2040c\\n\"\n    ],\n    \"outputs\": [\n        \"my name is steven halim\\n\",\n        \"steven loves cs2040 and also cs2040c\\n\"\n    ]\n}", "difficulty": "interview", "url": "https://open.kattis.com/problems/sim", "starter_code": ""}
{"id": 1032, "question": "This is the hard version of the problem. The difference between versions is the constraints on $n$ and $a_i$. You can make hacks only if all versions of the problem are solved.\n\nFirst, Aoi came up with the following idea for the competitive programming problem:\n\nYuzu is a girl who collecting candies. Originally, she has $x$ candies. There are also $n$ enemies numbered with integers from $1$ to $n$. Enemy $i$ has $a_i$ candies.\n\nYuzu is going to determine a permutation $P$. A permutation is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $\\{2,3,1,5,4\\}$ is a permutation, but $\\{1,2,2\\}$ is not a permutation ($2$ appears twice in the array) and $\\{1,3,4\\}$ is also not a permutation (because $n=3$ but there is the number $4$ in the array).\n\nAfter that, she will do $n$ duels with the enemies with the following rules:\n\n  If Yuzu has equal or more number of candies than enemy $P_i$, she wins the duel and gets $1$ candy. Otherwise, she loses the duel and gets nothing.  The candy which Yuzu gets will be used in the next duels. \n\nYuzu wants to win all duels. How many valid permutations $P$ exist?\n\nThis problem was easy and wasn't interesting for Akari, who is a friend of Aoi. And Akari made the following problem from the above idea:\n\nLet's define $f(x)$ as the number of valid permutations for the integer $x$.\n\nYou are given $n$, $a$ and a prime number $p \\le n$. Let's call a positive integer $x$ good, if the value $f(x)$ is not divisible by $p$. Find all good integers $x$.\n\nYour task is to solve this problem made by Akari.\n\n\n-----Input-----\n\nThe first line contains two integers $n$, $p$ $(2 \\le p \\le n \\le 10^5)$. It is guaranteed, that the number $p$ is prime (it has exactly two divisors $1$ and $p$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ $(1 \\le a_i \\le 10^9)$.\n\n\n-----Output-----\n\nIn the first line, print the number of good integers $x$.\n\nIn the second line, output all good integers $x$ in the ascending order.\n\nIt is guaranteed that the number of good integers $x$ does not exceed $10^5$.\n\n\n-----Examples-----\nInput\n3 2\n3 4 5\n\nOutput\n1\n3\n\nInput\n4 3\n2 3 5 6\n\nOutput\n2\n3 4\n\nInput\n4 3\n9 1 1 1\n\nOutput\n0\n\n\nInput\n3 2\n1000000000 1 999999999\n\nOutput\n1\n999999998\n\n\n\n-----Note-----\n\nIn the first test, $p=2$.\n\n  If $x \\le 2$, there are no valid permutations for Yuzu. So $f(x)=0$ for all $x \\le 2$. The number $0$ is divisible by $2$, so all integers $x \\leq 2$ are not good.  If $x = 3$, $\\{1,2,3\\}$ is the only valid permutation for Yuzu. So $f(3)=1$, so the number $3$ is good.  If $x = 4$, $\\{1,2,3\\} , \\{1,3,2\\} , \\{2,1,3\\} , \\{2,3,1\\}$ are all valid permutations for Yuzu. So $f(4)=4$, so the number $4$ is not good.  If $x \\ge 5$, all $6$ permutations are valid for Yuzu. So $f(x)=6$ for all $x \\ge 5$, so all integers $x \\ge 5$ are not good. \n\nSo, the only good number is $3$.\n\nIn the third test, for all positive integers $x$ the value $f(x)$ is divisible by $p = 3$.", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\nn,p=map(int,input().split())\\na=list(map(int,input().split()))\\na.sort()\\nmn=0\\nmx=2000000000000000\\nfor i in range(n):\\n    d=a[i]-i\\n    mn=max(d,mn)\\n    if i>=p-1:\\n        d2=a[i]-i+p-1\\n        mx=min(mx,d2)\\nprint(max(mx-mn,0))\\nfor i in range(mn,mx):\\n    print(i,end=\\\" \\\")\", \"def smallest_winner(matrix):\\n    starting_x = 1\\n    x = 1\\n    for m in matrix:\\n        if m > x:\\n            starting_x += m - x\\n            x += m - x\\n        x += 1\\n    return starting_x\\n\\n\\ndef biggest_winner(matrix, p):\\n    maxi = matrix[-1]\\n    for i in range(len(matrix)):\\n        if i + p - 1 >= len(matrix):\\n            break\\n        temp = matrix[i + p - 1] - i\\n        maxi = min(maxi, temp)\\n    return maxi\\n\\n\\ndef check_multiple(matrix):\\n    count = 0\\n    maxi = 0\\n    for i in range(1, len(matrix)):\\n        if matrix[i] == matrix[i - 1]:\\n            count += 1\\n        else:\\n            count = 1\\n        maxi = max(maxi, count)\\n    return maxi\\n\\n\\ndef solve(n, p, matrix):\\n    matrix = sorted(matrix)\\n    min_x = smallest_winner(matrix)\\n    max_x = biggest_winner(matrix, p) - 1\\n    return [i for i in range(min_x, max_x + 1)]\\n\\n\\n# T = int(input())\\n# for _ in range(T):\\nn, p = list(map(int, input().split()))\\nmatrix = list(map(int, input().split()))\\nres = solve(n, p, matrix)\\nprint(len(res))\\nprint(\\\" \\\".join(map(str, res)))\\n\", \"import sys\\ninput=lambda: sys.stdin.readline().rstrip()\\nn,p=map(int,input().split())\\nA=sorted([int(i) for i in input().split()])\\nA=[A[i]-int(i) for i in range(n)]\\nAA=[A[-1]]\\nfor i in range(n-1):\\n  AA.append(min(AA[-1],A[n-2-i]))\\nAA=AA[::-1]\\nAns=[]\\nfor i in range(max(A),max(A)+p+1):\\n  if i-AA[p-1]+1<p:\\n    Ans.append(i)\\nprint(len(Ans))\\nprint(*Ans)\", \"n,p = map(int,input().split())\\na = list(map(int,input().split()))\\na.sort()\\nans = 0\\nansls = []\\nmx = max(a)\\nmn = max([a[i]-i for i in range(n)])\\nansmx = -1\\nfor j in range(p-1,n)[::-1]:\\n  ansmx = max(ansmx,n-max(mn,a[j])+mn-(n-j-1))\\nwhile ansmx < p:\\n  ans += 1\\n  ansls.append(mn)\\n  mn += 1\\n  ansmx += 1\\nprint(ans)\\nprint(*ansls)\", \"def ican(a, x):\\n    k = x\\n    wr = 0\\n    for i in range(len(a)):\\n        if a[i] <= k:\\n            wr += 1\\n        else:\\n            wr -= a[i] - k\\n            k = a[i]\\n            if wr < 0:\\n                return False\\n            wr += 1\\n    return True\\ndef bnpleft(a):\\n    r = max(a)\\n    l = -1\\n    while r - l > 1:\\n        h = (r+l)//2\\n        if ican(a, h): r = h\\n        else: l = h\\n    return l\\ndef fa(a, x, p):\\n    k = x\\n    wr = 0\\n    for i in range(len(a)):\\n        if a[i] <= k:\\n            wr += 1\\n        else:\\n            nk = wr // p * p\\n            wr -= a[i] - k\\n            if wr < nk:\\n                return False\\n            k = a[i]\\n            if wr < 0:\\n                return False\\n            wr += 1\\n    if wr >= p:\\n        return False\\n    else:\\n        return True\\n\\ndef bnpr(a,p,left):\\n    l = left\\n    r = max(a)\\n    while r - l > 1:\\n        h = (r+l)//2\\n        if fa(a, h, p): l = h\\n        else: r = h\\n    return l\\ndef solve():\\n    n, p = map(int, input().split())\\n    lst = list(map(int,input().split()))\\n    lst.sort()\\n    ll = bnpleft(lst)\\n    rr = bnpr(lst,p,ll)\\n    print(rr-ll)\\n    for i in range(ll + 1, rr + 1):\\n        print(i, end=\\\" \\\")\\nfor i in range(1):\\n    solve()\", \"mod = 1000000007\\neps = 10**-9\\n\\n\\ndef main():\\n    import sys\\n    from collections import Counter\\n    input = sys.stdin.readline\\n    N, p = list(map(int, input().split()))\\n    A = list(map(int, input().split()))\\n    A.sort()\\n\\n    \\\"\\\"\\\"\\n    C = Counter(A)\\n    for a in A:\\n        if C[a] >= p:\\n            print(0)\\n            print(\\\"\\\\n\\\")\\n            return\\n    \\\"\\\"\\\"\\n    x0 = -1\\n    for i in range(N):\\n        x0 = max(x0, A[i] - i)\\n    x1 = A[p-1]\\n    \\\"\\\"\\\"\\n    if x0 >= x1:\\n        print(0)\\n        print(\\\"\\\\n\\\")\\n        return\\n    \\\"\\\"\\\"\\n\\n    dic = {}\\n    i = 0\\n    for x in range(x0, x0 + 2*10**5+1):\\n        while True:\\n            if i == N-1:\\n                break\\n            if A[i+1] <= x:\\n                i += 1\\n            else:\\n                break\\n        dic[x] = i+1\\n\\n    ok = x0-1\\n    ng = x1\\n    mid = (ok+ng)//2\\n    while ng - ok > 1:\\n        x = mid\\n        flg = 1\\n        for i in range(N):\\n            if (dic[x+i] - i) % p == 0:\\n                flg = 0\\n                break\\n        if flg:\\n            ok = mid\\n        else:\\n            ng = mid\\n        mid = (ok+ng)//2\\n    print(ok - x0 + 1)\\n    X = list(range(x0, ok+1))\\n    print(*X)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n, p = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\na.sort()\\nleft = 0\\nright = 10**9+1\\nwhile right - left > 1:\\n\\n    mid = left + (right - left)//2\\n    x = mid\\n\\n    flag = 1\\n    for i in range(n):\\n        if a[i] <= x:\\n            x += 1\\n        else:\\n            flag = 0\\n            break\\n\\n    if flag:\\n        right = mid\\n    else:\\n        left = mid\\n\\nansleft = right\\n\\nleft = 0\\nright = 10**9+1\\n\\nwhile right - left > 1:\\n    mid = left + (right - left)//2\\n    x = mid\\n\\n    flag = 1\\n    r = 0\\n    for i in range(n):\\n        while r < n:\\n            if a[r] <= x:\\n                r += 1\\n            else:\\n                break\\n\\n        if r - i >= p:\\n            flag = 0\\n            break\\n        x += 1\\n\\n    if flag:\\n        left = mid\\n    else:\\n        right = mid\\n\\nansright = left\\n\\nans = [i for i in range(ansleft, ansright+1)]\\nprint(len(ans))\\nprint(*ans)\\n\", \"import sys\\nlines = sys.stdin.readlines()\\n# (N, K) = map(int, lines[0].strip().split(\\\" \\\"))\\n(n, p) = map(int, lines[0].strip().split(\\\" \\\"))\\narr = list(map(int, lines[1].strip().split(\\\" \\\")))\\narr.sort()\\ncounter = {}\\nfor a in arr:\\n    if a not in counter:counter[a] = 0\\n    counter[a] += 1\\nlower = max(arr[-1] - n + 1, 1)\\na, b, c, d = lower-1, -1, -1, arr[-1] + 1\\n\\ndef check(val):\\n    pt = 0\\n    cnt = 0\\n    while pt < n and arr[pt] <= val:\\n        cnt += 1; pt += 1\\n    if cnt >= p: return 1\\n    while cnt > 0:\\n        val += 1\\n        cnt -= 1\\n        if val in counter: cnt += counter[val]\\n        if cnt >= p: return 1\\n        if val >= arr[-1]: break\\n    if ( cnt <= 0 or val < arr[-1]): return -1\\n    else: return 0\\n\\nexist = False\\nwhile(a<d-1):\\n    mid = (a+d)//2\\n    res = check(mid)\\n    if res == 1: d = mid\\n    elif res == -1: a = mid\\n    else:\\n        exist = True; break\\n\\nif exist:\\n    b = mid; c = mid\\n    while(a < b-1):\\n        mid = (a+b)//2\\n        res = check(mid)\\n        if res == 0: b = mid\\n        else: a = mid\\n    while(c < d-1):\\n        mid = (c+d)//2\\n        if check(mid) == 1: d = mid\\n        else: c = mid\\n\\nif exist:\\n    print(c-b+1)\\n    print(' '.join(map(str, range(b, c+1))))\\nelse: \\n    print(0); print()\", \"#!usr/bin/env python3\\nimport sys\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\n\\ndef solve():\\n    n,p = LI()\\n    a = LI()\\n    a.sort()\\n    ap = [i for i in a[p-1:]]\\n    ap = [ap[i]-i for i in range(len(ap))]\\n    M = min(ap)\\n    b = [a[i]-i for i in range(n)]\\n    m = max(b)\\n    ans = list(range(m,M))\\n    print(len(ans))\\n    print(*ans)\\n    return\\n\\n#Solve\\ndef __starting_point():\\n    solve()\\n\\n__starting_point()\", \"def places(num,v):\\n\\tif num>=v+n:\\n\\t\\treturn 0\\n\\tif num<v:\\n\\t\\treturn n\\n\\treturn (n-(num-v))\\n\\n\\ndef check(num):\\n\\tfor i in range(n-1,-1,-1):\\n\\t\\tcount = max(0, places(b[i],num) - ((n-1)-i))\\n\\t\\t# print (num,count)\\n\\t\\tif count==0:\\n\\t\\t\\treturn True\\n\\t\\tif count%p==0:\\n\\t\\t\\treturn False\\n\\treturn False\\n\\ndef check2(num):\\n\\tfor i in range(n-1,-1,-1):\\n\\t\\tcount = max(0, places(b[i],num) - ((n-1)-i))\\n\\t\\t# print (num,count)\\n\\t\\tif count%p==0:\\n\\t\\t\\treturn True\\n\\treturn False\\n\\nn,p = map(int,input().split())\\na = list(map(int,input().split()))\\nb = sorted(a)\\nminn = b[0]\\nmaxx = b[-1]\\nlow = 0\\nhigh = maxx-1\\nwhile low<high:\\n\\tmid = (low+high)//2\\n\\tif check(mid):\\n\\t\\tlow = mid+1\\n\\telse:\\n\\t\\thigh = mid-1\\nif check(low):\\n\\tstart = low+1\\nelse:\\n\\tstart = low\\n\\nlow = start\\nhigh = maxx-1\\nwhile low<high:\\n\\tmid = (low+high)//2\\n\\tif not check2(mid):\\n\\t\\tlow = mid + 1\\n\\telse:\\n\\t\\thigh = mid - 1\\nif check2(low):\\n\\tend = low - 1\\nelse:\\n\\tend = low\\n\\nans = []\\nfor i in range(start,end+1):\\n\\tans.append(i)\\nprint (len(ans))\\nprint (*ans)\", \"n, p = list(map(int, input().split(' ')))\\na = list(map(int, input().split(' ')))\\na.sort()\\nresult = []\\n_min = 0\\nfor i in range(len(a) - 1, -1, -1):\\n    if _min <= a[i] - i:\\n        _min = a[i] - i\\n\\n_max = a[-1]\\nfor i in range(len(a) - 1, p-2, -1):\\n    if _max >= p - 2 - i + a[i]:\\n        _max = p - 2 - i + a[i]\\n\\nresult = max(_max - _min + 1, 0)\\nprint(result)\\nif result > 0:\\n    for i in range(_min, _max + 1):\\n        print(i, end=' ')\\n\\\"\\\"\\\" print('max ', _max)\\nprint('min ', _min) \\\"\\\"\\\"\\n\", \"import copy\\ncon = 10 ** 9 + 7; INF = float(\\\"inf\\\")\\n\\ndef getlist():\\n\\treturn list(map(int, input().split()))\\n\\ndef Binary_Search(N, P, A, dif):\\n\\t#\\u521d\\u671f\\u5316\\n\\tleft = 0\\n\\tright = N - 1\\n\\tansleft = dif\\n\\tansright = -INF\\n\\t\\n\\t#\\u4e8c\\u5206\\u63a2\\u7d22\\n\\twhile left <= right:\\n\\t\\tmid = (left + right) // 2\\n\\t\\tjud = \\\"Yes\\\"\\n\\n\\t\\tB = copy.deepcopy(A)\\n\\t\\tB.append(INF)\\n\\t\\tfor t in range(N):\\n\\t\\t\\tB[t] -= mid\\n\\n\\t\\t# \\u5c3a\\u53d6\\u308a\\n\\t\\tarray = [None] * N\\n\\t\\ti = 0; j = 0\\n\\t\\twhile True:\\n\\t\\t\\tif B[j] <= i:\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif (j - i) % P == 0:\\n\\t\\t\\t\\t\\tjud = \\\"No\\\"\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tarray[i] = j - i\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tif i >= N:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif jud == \\\"Yes\\\":\\n\\t\\t\\tansright = max(ansright, dif + mid)\\n\\t\\t\\tleft = mid + 1\\n\\t\\telse:\\n\\t\\t\\tright = mid - 1\\n\\n\\treturn ansleft, ansright\\n\\n#\\u51e6\\u7406\\u5185\\u5bb9\\ndef main():\\n\\tN, P = getlist()\\n\\tA = getlist()\\n\\tA = sorted(A)\\n\\tdif = 0\\n\\t# \\u914d\\u5217\\u306e\\u521d\\u671f\\u5316\\n\\tfor i in range(N):\\n\\t\\tdif = max(dif, A[i] - i)\\n\\tfor i in range(N):\\n\\t\\tA[i] -= dif\\n\\n\\tL, R = Binary_Search(N, P, A, dif)\\n\\tif R == -INF:\\n\\t\\tprint(0)\\n\\t\\tprint()\\n\\telse:\\n\\t\\tXlis = [i for i in range(L, R + 1)]\\n\\t\\tprint(len(Xlis))\\n\\t\\tprint(*Xlis)\\n\\ndef __starting_point():\\n\\tmain()\\n__starting_point()\", \"import math\\nimport sys\\ninput = sys.stdin.readline\\nn, p = list(map(int, input().split()))\\na = sorted([int(_) for _ in input().split()])\\ninf = 10**18\\nbad = dict()\\nlow, high = 1, inf\\nopt = [0] * p\\nfor i in range(n):\\n    j = (i + 1) % p\\n    if a[i] >= j:\\n        var = (a[i] - j) % p\\n        opt[var] = max(opt[var], a[i] - j) \\n    if j == 0:\\n        high = min(high, a[i])\\n    low = max(low, a[i] - i)\\nfor i in range(p):\\n    cur = opt[i]\\n    while cur >= low:\\n        bad[cur] = True\\n        cur -= p\\nresult = []\\nfor i in range(low, high):\\n    if bad.get(i, False) == False:\\n        result.append(i)\\nprint(len(result))\\nprint(' '.join(map(str, result)))\\n\\n\", \"import bisect\\nimport sys\\ninput=sys.stdin.readline\\n\\nn,p=map(int,input().split())\\narr1=list(map(int,input().split()))\\narr1=sorted(arr1)\\nmins=0\\nfor i in range(n):\\n    mins=max(mins,arr1[i]-i)\\nmaxs=arr1[p-1]\\narr2=[0]*n\\nfor i in range(n):\\n    arr2[i]=(n-arr1[n-i-1]-i)%p\\narr2=arr2[::-1]\\ncan=set(range(p))\\npos=bisect.bisect_right(arr1,maxs-1)\\nfor i in range(pos,n):\\n    can.discard((p-arr2[i])%p)\\nans=[]\\nprev=pos\\nfor x in range(maxs-1,mins-1,-1):\\n    pos=bisect.bisect_right(arr1,x)\\n    if pos==prev:\\n        if x%p in can:\\n            ans.append(x)\\n    else:\\n        for i in range(pos,prev):\\n            can.discard((p-arr2[i])%p)\\n        if x%p in can:\\n            ans.append(x)\\n    prev=pos\\nans=ans[::-1]\\nprint(len(ans))\\nprint(*ans)\", \"n,p=list(map(int,input().split()))\\na=list(map(int,input().split()))\\na.sort()\\nm=max(a[i]-i for i in range(n))\\nM=a[p-1]-1\\nban=[0 for i in range(p)]\\nans=[]\\n\\nquery=[(a[i]-1-i,1,-100) for i in range(n)]\\nfor x in range(m,M+1):\\n    query.append((x,0,-100))\\nfor i in range(n):\\n    query.append((a[i],-1,i))\\n\\nquery.sort()\\n#print(query)\\nfor val,q,id in query:\\n    if q==-1:\\n        r=(val-id-1)%p\\n        ban[r]-=1\\n    elif q==0:\\n        if ban[val%p]==0:\\n            ans.append(val)\\n    else:\\n        ban[val%p]+=1\\n\\nans.sort()\\nprint(len(ans))\\nprint(*ans)\\n\", \"n, p = map(int, input().split())\\na = list(map(int, input().split()))\\n\\n\\na = sorted(a)\\nfor i in range(n):\\n    a[i] -= i\\nl = max(a)\\n\\nfor i in range(n):\\n    a[i] += p - 1\\nr = min(a[p - 1:])\\n\\nprint(max(r - l, 0))\\nprint(*[val for val in range(l, r)])\", \"n, p = map(int,input().split())\\nl = list(map(int,input().split()))\\nl.sort()\\n\\nsmalls = [l[i] - i for i in range(n)]\\ntols = [l[i]-i+p-1 for i in range(p-1,n)]\\nsmol = max(smalls)\\ntol = min(tols)\\n\\nout = list(range(smol,tol))\\nprint(len(out))\\nprint(' '.join(map(str,out)))\", \"def smallest_winner(matrix,starting_x,x):\\n    for m in matrix:\\n        if m > x:starting_x += m - x;x += m - x\\n        x += 1\\n    return starting_x\\ndef biggest_winner(matrix, p,maxi):\\n    for i in range(len(matrix)):\\n        if i + p - 1 >= len(matrix):break\\n        maxi = min(maxi, matrix[i + p - 1] - i)\\n    return maxi\\nn, p = map(int, input().split());matrix = sorted(list(map(int, input().split())));res = [i for i in range(smallest_winner(matrix,1,1), biggest_winner(matrix, p,matrix[-1]) )];print(len(res));print(\\\" \\\".join(map(str, res)))\", \"# f = open('test.py')\\n# def input():\\n# \\treturn f.readline().replace('\\\\n','')\\n\\n# import heapq\\n# import bisect\\n# from collections import deque\\n# from collections import defaultdict\\ndef read_list():\\n\\treturn list(map(int,input().strip().split(' ')))\\ndef print_list(l):\\n\\tprint(' '.join(map(str,l)))\\n\\n# N = int(input())\\n# for _ in range(N):\\nn,p= read_list()\\na = read_list()\\na.sort()\\nmi = max(a[i]-i for i in range(n))\\nres = []\\nll = []\\n\\nx = mi\\nnow = x \\ni = 0\\ndic = [[-1]]\\nfor step in range(n):\\n\\twhile i<n and now>=a[i]:\\n\\t\\ti+=1\\n\\tnow+=1\\n\\ttmp = (i - step)%p\\n\\ttmp = (p - tmp)%p\\n\\tif step>=tmp:\\n\\t\\tdic.append([tmp,step])\\ndic.pop(0)\\n\\nfor i in range(len(dic)-1,0,-1):\\n\\tif dic[i][0]<=dic[i-1][1]-1:\\n\\t\\tdic[i-1][1] = dic[i][1]\\n\\t\\tdic[i-1][0] = min(dic[i][0],dic[i-1][0])\\n\\t\\tdic.pop(i)\\n# print(dic)\\n\\nlas = 0\\nfor d in dic:\\n\\tflag = True\\n\\tfor i in range(las,d[0]):\\n\\t\\tif i>=p-1:\\n\\t\\t\\tflag = False\\n\\t\\t\\tbreak\\n\\t\\tres.append(mi+i)\\n\\tlas = d[1]+1\\n\\tif not flag:\\n\\t\\tbreak\\nif dic:\\n\\tfor i in range(dic[-1][-1]+1,p-1):\\n\\t\\tres.append(mi+i)\\n\\nprint(len(res))\\nprint_list(res)\\n\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3 2\\n3 4 5\\n\",\n    \"4 3\\n2 3 5 6\\n\",\n    \"4 3\\n9 1 1 1\\n\",\n    \"3 2\\n1000000000 1 999999999\\n\",\n    \"2 2\\n603532654 463735162\\n\",\n    \"5 5\\n292213182 292213182 292213182 292213183 292213182\\n\",\n    \"5 2\\n720537834 720537833 720537836 720537836 720537836\\n\",\n    \"5 2\\n294086679 294086678 294086679 294086678 294086677\\n\",\n    \"5 3\\n162602818 162602819 162602820 162602819 162602820\\n\",\n    \"3 2\\n472048795 907772611 386584751\\n\",\n    \"4 2\\n45597639 501553165 412214228 678482810\\n\",\n    \"5 5\\n324179187 95333719 583067898 217640575 166623692\\n\",\n    \"12 5\\n1 10 2 9 3 8 3 2 8 1 10 6\\n\",\n    \"87 83\\n40 6 7 50 16 65 47 90 94 65 79 29 41 76 80 13 87 37 92 71 54 53 93 79 14 53 71 78 50 50 74 40 30 92 66 86 94 60 37 65 82 14 61 48 68 71 91 99 74 88 89 34 57 74 25 2 79 72 92 37 61 16 32 85 29 74 6 69 50 74 76 48 31 42 40 95 29 27 28 31 38 60 52 45 14 78 59\\n\",\n    \"2 2\\n271266633 271266631\\n\",\n    \"3 2\\n994829850 994829851 994829849\\n\",\n    \"3 2\\n568378695 568378695 568378694\\n\",\n    \"4 2\\n718393070 718393070 718393069 718393069\\n\",\n    \"4 2\\n291941912 291941912 291941911 291941913\\n\",\n    \"4 2\\n865490756 865490757 865490758 865490754\\n\",\n    \"6 3\\n720809104 720809106 720809104 720809104 720809105 720809104\\n\",\n    \"6 5\\n589325244 589325243 589325246 589325243 589325246 589325243\\n\",\n    \"6 3\\n17649897 17649898 17649899 17649895 17649896 17649896\\n\",\n    \"6 2\\n591198739 591198742 591198738 591198741 591198743 591198738\\n\",\n    \"6 5\\n459714880 459714883 459714884 459714882 459714878 459714881\\n\",\n    \"21 3\\n653112937 653112928 653112933 653112933 653112935 653112940 653112929 653112927 653112953 653112942 653112930 653112939 653112929 653112940 653112937 653112929 653112950 653112936 653112934 653112937 653112929\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n3\\n\",\n    \"2\\n3 4\\n\",\n    \"0\\n\\n\",\n    \"1\\n999999998\\n\",\n    \"1\\n603532653\\n\",\n    \"1\\n292213182\\n\",\n    \"0\\n\\n\",\n    \"0\\n\\n\",\n    \"0\\n\\n\",\n    \"0\\n\\n\",\n    \"0\\n\\n\",\n    \"4\\n583067894 583067895 583067896 583067897\\n\",\n    \"1\\n1\\n\",\n    \"75\\n17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91\\n\",\n    \"1\\n271266632\\n\",\n    \"1\\n994829849\\n\",\n    \"0\\n\\n\",\n    \"0\\n\\n\",\n    \"0\\n\\n\",\n    \"1\\n865490755\\n\",\n    \"0\\n\\n\",\n    \"2\\n589325243 589325244\\n\",\n    \"1\\n17649895\\n\",\n    \"0\\n\\n\",\n    \"4\\n459714879 459714880 459714881 459714882\\n\",\n    \"0\\n\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1371/E2", "starter_code": ""}
{"id": 2559, "question": "Welcome! Everything is fine.\n\nYou have arrived in The Medium Place, the place between The Good Place and The Bad Place. You are assigned a task that will either make people happier or torture them for eternity.\n\nYou have a list of $k$ pairs of people who have arrived in a new inhabited neighborhood. You need to assign each of the $2k$ people into one of the $2k$ houses. Each person will be the resident of exactly one house, and each house will have exactly one resident.\n\nOf course, in the neighborhood, it is possible to visit friends. There are $2k - 1$ roads, each of which connects two houses. It takes some time to traverse a road. We will specify the amount of time it takes in the input. The neighborhood is designed in such a way that from anyone's house, there is exactly one sequence of distinct roads you can take to any other house. In other words, the graph with the houses as vertices and the roads as edges is a tree.\n\nThe truth is, these $k$ pairs of people are actually soulmates. We index them from $1$ to $k$. We denote by $f(i)$ the amount of time it takes for the $i$-th pair of soulmates to go to each other's houses.\n\nAs we have said before, you will need to assign each of the $2k$ people into one of the $2k$ houses. You have two missions, one from the entities in The Good Place and one from the entities of The Bad Place. Here they are:  The first mission, from The Good Place, is to assign the people into the houses such that the sum of $f(i)$ over all pairs $i$ is minimized. Let's define this minimized sum as $G$. This makes sure that soulmates can easily and efficiently visit each other;  The second mission, from The Bad Place, is to assign the people into the houses such that the sum of $f(i)$ over all pairs $i$ is maximized. Let's define this maximized sum as $B$. This makes sure that soulmates will have a difficult time to visit each other. \n\nWhat are the values of $G$ and $B$?\n\n\n-----Input-----\n\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 500$) denoting the number of test cases. The next lines contain descriptions of the test cases.\n\nThe first line of each test case contains a single integer $k$ denoting the number of pairs of people ($1 \\le k \\le 10^5$). The next $2k - 1$ lines describe the roads; the $i$-th of them contains three space-separated integers $a_i, b_i, t_i$ which means that the $i$-th road connects the $a_i$-th and $b_i$-th houses with a road that takes $t_i$ units of time to traverse ($1 \\le a_i, b_i \\le 2k$, $a_i \\neq b_i$, $1 \\le t_i \\le 10^6$). It is guaranteed that the given roads define a tree structure.\n\nIt is guaranteed that the sum of the $k$ in a single file is at most $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output a single line containing two space-separated integers $G$ and $B$. \n\n\n-----Example-----\nInput\n2\n3\n1 2 3\n3 2 4\n2 4 3\n4 5 6\n5 6 5\n2\n1 2 1\n1 3 2\n1 4 3\n\nOutput\n15 33\n6 6\n\n\n\n-----Note-----\n\nFor the sample test case, we have a minimum sum equal to $G = 15$. One way this can be achieved is with the following assignment:  The first pair of people get assigned to houses $5$ and $6$, giving us $f(1) = 5$;  The second pair of people get assigned to houses $1$ and $4$, giving us $f(2) = 6$;  The third pair of people get assigned to houses $3$ and $2$, giving us $f(3) = 4$. \n\nNote that the sum of the $f(i)$ is $5 + 6 + 4 = 15$. \n\nWe also have a maximum sum equal to $B = 33$. One way this can be achieved is with the following assignment:  The first pair of people get assigned to houses $1$ and $4$, giving us $f(1) = 6$;  The second pair of people get assigned to houses $6$ and $2$, giving us $f(2) = 14$;  The third pair of people get assigned to houses $3$ and $5$, giving us $f(3) = 13$. \n\nNote that the sum of the $f(i)$ is $6 + 14 + 13 = 33$.", "solutions": "[\"import sys\\n\\n\\n# inf = open('input.txt', 'r')\\n# reader = (map(int, line.split()) for line in inf)\\nreader = (list(map(int, line.split())) for line in sys.stdin)\\n\\ndef minmaxPairs(g, costDict, n):\\n    G = B = 0\\n    s = 1\\n    stack = [s]\\n    traversal = []\\n    visited = [False] * (n + 1)\\n    subtreeSize = [1 for _ in range(n + 1)]\\n    while stack:\\n        v = stack.pop()\\n        if not visited[v]:\\n            visited[v] = True\\n            for to in g[v]:\\n                if not visited[to]:\\n                    stack.append(v)\\n                    stack.append(to)\\n        else:\\n            to = traversal[-1]\\n            if (v, to) in costDict:\\n                cost = costDict[(v, to)]\\n            else:\\n                cost = costDict[(to, v)]\\n            toSize = subtreeSize[to]\\n            subtreeSize[v] += toSize\\n            minComp = min(toSize, n - toSize)\\n            G += (minComp % 2) * cost\\n            B += minComp * cost\\n        traversal.append(v)\\n    return G, B \\n\\nt, = next(reader)\\nfor _ in range(t):\\n    k, = next(reader)\\n    n = 2 * k\\n    g = [[] for i in range(n + 1)]\\n    costDict = {}\\n    for i in range(n - 1):\\n        v, to, cost = next(reader)\\n        costDict[(v, to)] = cost\\n        g[v].append(to)\\n        g[to].append(v)\\n    G, B = minmaxPairs(g, costDict, n)\\n    print(G, B)\\n\\n# inf.close()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n3\\n1 2 3\\n3 2 4\\n2 4 3\\n4 5 6\\n5 6 5\\n2\\n1 2 1\\n1 3 2\\n1 4 3\\n\",\n    \"1\\n1\\n2 1 4\\n\"\n  ],\n  \"outputs\": [\n    \"15 33\\n6 6\\n\",\n    \"4 4\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1281/E", "starter_code": ""}
{"id": 148, "question": "The circle line of the Roflanpolis subway has $n$ stations.\n\nThere are two parallel routes in the subway. The first one visits stations in order $1 \\to 2 \\to \\ldots \\to n \\to 1 \\to 2 \\to \\ldots$ (so the next stop after station $x$ is equal to $(x+1)$ if $x < n$ and $1$ otherwise). The second route visits stations in order $n \\to (n-1) \\to \\ldots \\to 1 \\to n \\to (n-1) \\to \\ldots$ (so the next stop after station $x$ is equal to $(x-1)$ if $x>1$ and $n$ otherwise). All trains depart their stations simultaneously, and it takes exactly $1$ minute to arrive at the next station.\n\nTwo toads live in this city, their names are Daniel and Vlad.\n\nDaniel is currently in a train of the first route at station $a$ and will exit the subway when his train reaches station $x$.\n\nCoincidentally, Vlad is currently in a train of the second route at station $b$ and he will exit the subway when his train reaches station $y$.\n\nSurprisingly, all numbers $a,x,b,y$ are distinct.\n\nToad Ilya asks you to check if Daniel and Vlad will ever be at the same station at the same time during their journey. In other words, check if there is a moment when their trains stop at the same station. Note that this includes the moments when Daniel or Vlad enter or leave the subway.\n\n\n-----Input-----\n\nThe first line contains five space-separated integers $n$, $a$, $x$, $b$, $y$ ($4 \\leq n \\leq 100$, $1 \\leq a, x, b, y \\leq n$, all numbers among $a$, $x$, $b$, $y$ are distinct)\u00a0\u2014 the number of stations in Roflanpolis, Daniel's start station, Daniel's finish station, Vlad's start station and Vlad's finish station, respectively.\n\n\n-----Output-----\n\nOutput \"YES\" if there is a time moment when Vlad and Daniel are at the same station, and \"NO\" otherwise. You can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n5 1 4 3 2\n\nOutput\nYES\n\nInput\n10 2 1 9 10\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example, Daniel and Vlad start at the stations $(1, 3)$. One minute later they are at stations $(2, 2)$. They are at the same station at this moment. Note that Vlad leaves the subway right after that.\n\nConsider the second example, let's look at the stations Vlad and Daniel are at. They are:   initially $(2, 9)$,  after $1$ minute $(3, 8)$,  after $2$ minutes $(4, 7)$,  after $3$ minutes $(5, 6)$,  after $4$ minutes $(6, 5)$,  after $5$ minutes $(7, 4)$,  after $6$ minutes $(8, 3)$,  after $7$ minutes $(9, 2)$,  after $8$ minutes $(10, 1)$,  after $9$ minutes $(1, 10)$. \n\nAfter that, they both leave the subway because they are at their finish stations, so there is no moment when they both are at the same station.", "solutions": "[\"n, a, x, b, y = map(int, input().split())\\n\\nwhile a != x and b != y and a != b:\\n\\tif a == b:\\n\\t\\tbreak\\n\\n\\ta = a % n + 1\\n\\tb = b - 1 if b - 1 else n\\n\\nprint(\\\"YNEOS\\\"[a != b::2])\", \"n, a, x, b, y = list(map(int, input().split()))\\na -= 1\\nx -= 1\\nb -= 1\\ny -= 1\\n\\ndaniel = []\\nvlad = []\\ni = a\\nwhile i != x:\\n    daniel.append(i)\\n    i = (i + 1) % n\\ndaniel.append(x)\\ni = b\\nwhile i != y:\\n    vlad.append(i)\\n    i = (i - 1 + n) % n\\nvlad.append(y)\\n\\nif any(u == v for u, v in zip(daniel, vlad)):\\n    print('YES')\\nelse:\\n    print('NO')\\n\", \"n,a,x,b,y = list(map(int,input().split()))\\na -= 1\\nx -= 1\\nb -= 1\\ny -= 1\\nwhile True:\\n    if a == b:\\n        print(\\\"YES\\\")\\n        break\\n    if a == x or b == y:\\n        print(\\\"NO\\\")\\n        break\\n    a = (a+1)%n\\n    b = (b-1)%n\\n\", \"n, a, x, b, y = list(map(int, input().split()))\\nans = 'NO'\\nif a == b:\\n    ans = 'YES'\\nwhile a != x and b != y:\\n    if a == n:\\n        a = 0\\n    a += 1\\n    if b == 1:\\n        b = n + 1\\n    b -= 1\\n    if a == b:\\n        ans = 'YES'\\nprint(ans)\", \"''' \\u0628\\u0650\\u0633\\u0652\\u0645\\u0650 \\u0627\\u0644\\u0644\\u064e\\u0651\\u0647\\u0650 \\u0627\\u0644\\u0631\\u064e\\u0651\\u062d\\u0652\\u0645\\u064e\\u0670\\u0646\\u0650 \\u0627\\u0644\\u0631\\u064e\\u0651\\u062d\\u0650\\u064a\\u0645\\u0650 '''\\n#codeforces1169A_live\\ngi = lambda : list(map(int,input().strip().split()))\\nn,a, x, b, y = gi()\\nwhile a != x and b != y:\\n\\ta += 1\\n\\tif a > n:\\n\\t\\ta = 1\\n\\tb -= 1\\n\\tif b <= 0:\\n\\t\\tb = n\\n\\tif a == b:\\n\\t\\tprint(\\\"YES\\\")\\n\\t\\treturn\\nprint(\\\"NO\\\")\", \"#JMD\\n#Nagendra Jha-4096\\n\\n \\nimport sys\\nimport math\\n\\n#import fractions\\n#import numpy\\n \\n###File Operations###\\nfileoperation=0\\nif(fileoperation):\\n    orig_stdout = sys.stdout\\n    orig_stdin = sys.stdin\\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\\n    sys.stdin = inputfile\\n    sys.stdout = outputfile\\n\\n###Defines...###\\nmod=1000000007\\n \\n###FUF's...###\\ndef nospace(l):\\n    ans=''.join(str(i) for i in l)\\n    return ans\\n \\n \\n \\n##### Main ####\\nt=1\\nfor tt in range(t):\\n    #n=int(input())\\n    n,a,x,b,y= map(int, sys.stdin.readline().split(' '))\\n\\n    while 1:\\n        if a==x or b==y:\\n            break\\n\\n        if a==b:\\n            break\\n        if(a<n):\\n            a+=1\\n        else:\\n            a=1\\n\\n        if(b>1):\\n            b-=1\\n        else:\\n            b=n\\n    if a==b:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\\n    #a=list(map(int,sys.stdin.readline().split(' ')))\\n    \\n    \\n#####File Operations#####\\nif(fileoperation):\\n    sys.stdout = orig_stdout\\n    sys.stdin = orig_stdin\\n    inputfile.close()\\n    outputfile.close()\", \"n, a, x, b, y = list(map(int, input().split()))\\nwhile a != x and b != y:\\n    a += 1\\n    b -= 1\\n    if a == n + 1:\\n        a = 1\\n    if b == 0:\\n        b = n\\n    if a == b:\\n        print('YES')\\n        return\\n##    print(a, b)\\nprint('NO')\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\n\\nclass Problem:\\n    def __init__(self):\\n        pass\\n\\n    def solve(self):\\n        print(self._solve())\\n\\n    def _solve(self):\\n        n, a, x, b, y = [int(item) for item in input().split()]\\n        a -= 1\\n        b -= 1\\n        x -= 1\\n        y -= 1\\n        if (a == b):\\n            return \\\"YES\\\"\\n        for i in range(n):\\n            a = (a + 1) % n\\n            b = (b - 1) % n\\n            if a == b:\\n                return \\\"YES\\\"\\n            if b == y or a == x:\\n                break\\n\\n        return \\\"NO\\\"\\n\\n\\ndef main():\\n    problem = Problem()\\n    problem.solve()\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n, a, x, b, y = list(map(int, input().split()))\\nz1 = a\\nz2 = b\\nimport sys\\nwhile True:\\n\\tif z1 == z2:\\n\\t\\tprint(\\\"YES\\\")\\n\\t\\treturn\\n\\tif z1 == x or z2 == y:\\n\\t\\tprint(\\\"NO\\\")\\n\\t\\treturn\\n\\tz1 = (z1 % n) + 1\\n\\tif z2 == 1:\\n\\t\\tz2 = n\\n\\telse:\\n\\t\\tz2 -= 1\\n\\n\", \"def main():\\n    n,a,x,b,y = list(map(int,input().split()))\\n    same = False\\n    while True:\\n        if a != x:\\n            a += 1\\n        else:\\n            break\\n        if b != y:\\n            b -= 1\\n        else:\\n            break\\n        if a == n+1:\\n            a = 1\\n        if b == 0:\\n            b = n\\n\\n        if a == b:\\n            break\\n\\n    if a == b:\\n        print('YES')\\n    else:\\n        print('NO')\\n\\n\\nmain()\\n\", \"def main():\\n    n, a,x,b,y = map(int, input().strip().split())\\n    a -= 1\\n    x -= 1\\n    b -= 1\\n    y -= 1\\n    cf = a\\n    cs = b\\n\\n    if a == b:\\n        print('YES')\\n        return\\n    while cf != x and cs != y:\\n        cf += 1\\n        cf %= n\\n        cs += (n - 1)\\n        cs %= n\\n        if cf == cs:\\n            print('YES')\\n            return\\n    print('NO')\\n    return\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"def main():\\n    n, a, x, b, y = list(map(int, input().split()))\\n    flag = False\\n    for i in range(n):\\n        if a == b:\\n            flag = True\\n        if a == x:\\n            break\\n        if b == y:\\n            break\\n        a += 1\\n        b -= 1\\n        if a == n + 1:\\n            a = 1\\n        if b == 0:\\n            b = n\\n    if flag:\\n        print('YES')\\n    else:\\n        print('NO')\\n\\nmain()\\n\", \"n, a, x, b, y = map(int, input().split())\\na -= 1\\nb -= 1\\nx -= 1\\ny -= 1\\nres = a == b\\nwhile a != x and b != y:\\n    if a != x: a = (a + 1) % n\\n    if b != y: b = (b - 1) % n\\n    res |= a == b\\n\\nprint(\\\"YES\\\" if res else \\\"NO\\\")\", \"n,a,x,b,y=list(map(int,input().split()))\\nfl=0\\nwhile True:\\n    a+=1\\n    if a==n+1:\\n        a=1\\n    b-=1\\n    if b==0:\\n        b=n\\n    if a==b:\\n        fl=1\\n        break\\n    elif a==x or b==y:\\n        break\\nif fl:\\n    print('YES')\\nelse:\\n    print('NO')\\n        \\n\", \"n,a,x,b,y = map(int,input().split())\\n\\nt_a = [a]\\ncurrent = a\\nwhile current != x:\\n    current += 1\\n    if current == (n+1):\\n        current = 1\\n    t_a.append(current)\\n\\nt_b = [b]\\ncurrent = b\\nwhile current != y:\\n    current -= 1\\n    if current == 0:\\n        current = n\\n    t_b.append(current)\\nsteps = min(len(t_a),len(t_b))\\n\\nfor i in range(steps):\\n    if t_a[i] == t_b[i]:\\n        print (\\\"YES\\\")\\n        return\\nprint (\\\"NO\\\")\", \"n,a,x,b,y=list(map(int, input().split()))\\na-=1\\nx-=1\\nb-=1\\ny-=1\\nwhile a != x and b != y:\\n    if a == b:\\n        print('YES')\\n        raise SystemExit(0)\\n    a = (a + 1) % n\\n    b = (b - 1 + n) % n\\nif a == b:\\n    print('YES')\\nelse:\\n    print('NO')\\n\", \"def main():\\n    n, a, x, b, y = map(int, input().split())\\n    a -= 1\\n    x -= 1\\n    b -= 1\\n    y -= 1\\n    if x < a:\\n        x += n\\n    if y > b:\\n        b += n\\n    while a != x and b != y:\\n        a += 1\\n        b -= 1\\n        if a % n == b % n:\\n            print(\\\"YES\\\")\\n            return 0\\n    print(\\\"NO\\\")\\n    return 0\\n\\nmain()\", \"n, a, x, b, y = list(map(int,input().split()))\\n\\nwhile(a != x and b != y):\\n    a = (a)%n + 1\\n    b = (b - 2)%n + 1\\n    if(a == b):\\n        print('YES')\\n        return\\n    if(a == x or b == y):\\n        break\\nprint('NO')\\n\", \"import sys\\n# gcd\\n# from fractions import gcd\\n# from math import ceil, floor\\n# from copy import deepcopy\\n# from itertools import accumulate\\n# l = ['a', 'b', 'b', 'c', 'b', 'a', 'c', 'c', 'b', 'c', 'b', 'a']\\n# print(S.most_common(2))  # [('b', 5), ('c', 4)]\\n# print(S.keys())  # dict_keys(['a', 'b', 'c'])\\n# print(S.values())  # dict_values([3, 5, 4])\\n# print(S.items())  # dict_items([('a', 3), ('b', 5), ('c', 4)])\\n# from collections import Counter\\n# import math\\n# from functools import reduce\\n#\\n# fin = open('in_1.txt', 'r')\\n# sys.stdin = fin\\ninput = sys.stdin.readline\\ndef ii(): return int(input())\\ndef mi(): return list(map(int, input().rstrip().split()))\\ndef lmi(): return list(map(int, input().rstrip().split()))\\ndef li(): return list(input().rstrip())\\n# template\\n\\n\\ndef __starting_point():\\n\\n    # write code\\n    n, a, x, b, y = mi()\\n    while (a % n != x % n and b % n != y % n):\\n        a += 1\\n        a %= n\\n        b -= 1\\n        b %= n\\n        if a % n == b % n:\\n            print('YES')\\n            break\\n    else:\\n        print('NO')\\n\\n__starting_point()\", \"n,a,x,b,y = list(map(int, input().split(' ')))\\na -= 1\\nx -= 1\\nb -= 1\\ny -= 1\\nwhile True :\\n    if a == b :\\n        print(\\\"YES\\\")\\n        break\\n    elif a == x or b == y :\\n        print(\\\"NO\\\")\\n        break\\n    else :\\n        a = (a+1)%n\\n        b = (b-1)%n\\n\", \"n, a, x, b, y = [int(x) for x in input().split()]\\n\\nar = []\\nbr = []\\n\\nif a < x:\\n    ar = list(range(a, x+1))\\nelse:\\n    ar = list(range(a, n+1)) + list(range(1, x+1))\\n\\nif b > y:\\n    br = list(range(b, y-1, -1))\\nelse:\\n    br = list(range(b, 0, -1)) + list(range(n, y-1, -1))\\n\\ncan = False\\n\\nfor i in range(min(len(ar), len(br))):\\n    if ar[i] == br[i]:\\n        can = True\\n\\nif can:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\", \"n,a,x,b,y = list(map(int,input().split()))\\njoin = False\\n#print(min((x-a)%n, (b-y)%n))\\nfor k in range(min((x-a)%n, (b-y)%n)+1):\\n\\tif a==b:\\n\\t\\tjoin = True\\n\\ta+=1\\n\\ta%=n\\n\\tb-=1\\n\\tb%=n\\nif join:\\n\\tprint('YES')\\nelse:\\n\\tprint('NO')\\n\", \"#\\t!/usr/bin/env python3\\n#\\tencoding: UTF-8\\n#\\tModified: <26/May/2019 09:11:38 PM>\\n\\n\\n#\\t\\u272a H4WK3yE\\u4e61\\n#\\tMohd. Farhan Tahir\\n#\\tIndian Institute Of Information Technology (IIIT), Gwalior\\n\\n\\nimport sys\\n\\n\\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\\n\\n\\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\\n\\n\\ndef input(): return sys.stdin.readline().strip()\\n\\n\\ndef main():\\n    n, a, x, b, y = get_ints()\\n    daniel = [-1] * (n + 1)\\n    if x >= a:\\n        t = 0\\n        for i in range(a, x + 1):\\n            daniel[i] = t\\n            t += 1\\n    else:\\n        t = 0\\n        for i in range(a, n + 1):\\n            daniel[i] = t\\n            t += 1\\n        for i in range(1, x + 1):\\n            daniel[i] = t\\n            t += 1\\n\\n    vlad = [-1] * (n + 1)\\n    if y <= b:\\n        t = 0\\n        for i in range(b, y - 1, -1):\\n            vlad[i] = t\\n            t += 1\\n    else:\\n        t = 0\\n        for i in range(b, 0, -1):\\n            vlad[i] = t\\n            t += 1\\n        for i in range(n, y - 1, -1):\\n            vlad[i] = t\\n            t += 1\\n    ans = 'NO'\\n    for i in range(1, n + 1):\\n        if daniel[i] == vlad[i] and daniel[i] != -1:\\n            ans = 'YES'\\n            break\\n    # print(vlad)\\n    # print(daniel)\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def main():\\n    n, a, x, b, y = map(int, input().split(' '))\\n    while a != x and b != y:\\n        a = a + 1\\n        b = b - 1\\n        if a == n + 1:\\n            a = 1\\n        if b == 0:\\n            b = n\\n        if a == b:\\n            print(\\\"YES\\\")\\n            return\\n    print(\\\"NO\\\")\\n    return\\n\\nmain()\"]", "input_output": "{\n  \"inputs\": [\n    \"5 1 4 3 2\\n\",\n    \"10 2 1 9 10\\n\",\n    \"4 3 4 2 1\\n\",\n    \"100 2 97 84 89\\n\",\n    \"100 43 55 42 15\\n\",\n    \"47 15 45 28 38\\n\",\n    \"17 14 2 12 10\\n\",\n    \"82 9 11 15 79\\n\",\n    \"53 10 34 1 48\\n\",\n    \"55 55 27 45 50\\n\",\n    \"33 15 6 1 3\\n\",\n    \"45 26 22 39 10\\n\",\n    \"5 3 2 4 1\\n\",\n    \"20 19 10 17 8\\n\",\n    \"100 26 63 60 23\\n\",\n    \"7 2 5 6 3\\n\",\n    \"50 22 39 33 9\\n\",\n    \"50 40 10 4 34\\n\",\n    \"5 3 1 2 4\\n\",\n    \"4 1 2 3 4\\n\",\n    \"4 1 2 4 3\\n\",\n    \"4 1 3 2 4\\n\",\n    \"4 1 3 4 2\\n\",\n    \"4 1 4 2 3\\n\",\n    \"4 1 4 3 2\\n\",\n    \"4 2 1 3 4\\n\",\n    \"4 2 1 4 3\\n\",\n    \"4 2 3 1 4\\n\",\n    \"4 2 3 4 1\\n\",\n    \"4 2 4 1 3\\n\",\n    \"4 2 4 3 1\\n\",\n    \"4 3 1 2 4\\n\",\n    \"4 3 1 4 2\\n\",\n    \"4 3 2 1 4\\n\",\n    \"4 3 2 4 1\\n\",\n    \"4 3 4 1 2\\n\",\n    \"4 4 1 2 3\\n\",\n    \"4 4 1 3 2\\n\",\n    \"4 4 2 1 3\\n\",\n    \"4 4 2 3 1\\n\",\n    \"4 4 3 1 2\\n\",\n    \"4 4 3 2 1\\n\",\n    \"10 9 10 3 4\\n\",\n    \"60 1 50 51 49\\n\",\n    \"10 1 4 3 9\\n\",\n    \"9 7 2 6 8\\n\",\n    \"5 4 2 1 5\\n\",\n    \"5 4 2 1 3\\n\",\n    \"5 3 1 2 4\\n\",\n    \"6 4 3 6 5\\n\",\n    \"10 10 9 6 7\\n\",\n    \"5 1 3 2 5\\n\",\n    \"5 5 4 1 2\\n\",\n    \"10 5 10 3 1\\n\",\n    \"7 5 3 2 4\\n\",\n    \"6 4 1 2 5\\n\",\n    \"5 2 1 4 5\\n\",\n    \"7 1 6 5 2\\n\",\n    \"13 1 9 2 13\\n\",\n    \"10 1 4 5 2\\n\",\n    \"6 3 1 5 2\\n\",\n    \"43 41 39 40 1\\n\",\n    \"8 7 2 3 5\\n\",\n    \"10 2 5 8 4\\n\",\n    \"8 1 4 5 6\\n\",\n    \"100 1 5 20 2\\n\",\n    \"6 5 6 3 4\\n\",\n    \"10 9 10 5 8\\n\",\n    \"6 5 6 3 1\\n\",\n    \"7 7 1 2 6\\n\",\n    \"10 2 4 7 3\\n\",\n    \"6 3 2 5 1\\n\",\n    \"6 5 2 3 1\\n\",\n    \"91 36 25 5 91\\n\",\n    \"90 1 2 5 4\\n\",\n    \"5 4 5 3 1\\n\",\n    \"5 5 4 1 3\\n\",\n    \"7 5 3 1 2\\n\",\n    \"5 5 1 2 3\\n\",\n    \"24 14 23 18 21\\n\",\n    \"10 9 10 1 8\\n\",\n    \"20 19 2 1 20\\n\",\n    \"7 1 5 4 7\\n\",\n    \"20 19 2 1 18\\n\",\n    \"5 5 1 2 4\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1169/A", "starter_code": ""}
{"id": 2061, "question": "The map of Berland is a rectangle of the size n \u00d7 m, which consists of cells of size 1 \u00d7 1. Each cell is either land or water. The map is surrounded by the ocean. \n\nLakes are the maximal regions of water cells, connected by sides, which are not connected with the ocean. Formally, lake is a set of water cells, such that it's possible to get from any cell of the set to any other without leaving the set and moving only to cells adjacent by the side, none of them is located on the border of the rectangle, and it's impossible to add one more water cell to the set such that it will be connected with any other cell.\n\nYou task is to fill up with the earth the minimum number of water cells so that there will be exactly k lakes in Berland. Note that the initial number of lakes on the map is not less than k. \n\n\n-----Input-----\n\nThe first line of the input contains three integers n, m and k (1 \u2264 n, m \u2264 50, 0 \u2264 k \u2264 50)\u00a0\u2014 the sizes of the map and the number of lakes which should be left on the map.\n\nThe next n lines contain m characters each \u2014 the description of the map. Each of the characters is either '.' (it means that the corresponding cell is water) or '*' (it means that the corresponding cell is land).\n\nIt is guaranteed that the map contain at least k lakes.\n\n\n-----Output-----\n\nIn the first line print the minimum number of cells which should be transformed from water to land. \n\nIn the next n lines print m symbols \u2014 the map after the changes. The format must strictly follow the format of the map in the input data (there is no need to print the size of the map). If there are several answers, print any of them. \n\nIt is guaranteed that the answer exists on the given data.\n\n\n-----Examples-----\nInput\n5 4 1\n****\n*..*\n****\n**.*\n..**\n\nOutput\n1\n****\n*..*\n****\n****\n..**\n\nInput\n3 3 0\n***\n*.*\n***\n\nOutput\n1\n***\n***\n***\n\n\n\n-----Note-----\n\nIn the first example there are only two lakes \u2014 the first consists of the cells (2, 2) and (2, 3), the second consists of the cell (4, 3). It is profitable to cover the second lake because it is smaller. Pay attention that the area of water in the lower left corner is not a lake because this area share a border with the ocean.", "solutions": "[\"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**10\\nmod = 10**9 + 7\\n\\ndef f():\\n    n,m,k = list(map(int, input().split()))\\n    a = [[inf]*(m+2)]\\n    g = []\\n    for _ in range(n):\\n        a.append([inf] + [_ for _ in input()] + [inf])\\n        g.append([False]*m)\\n    a.append([[inf]*(m+2)])\\n\\n    c = 0\\n    for i in range(1,n+1):\\n        if a[i][1] == '.':\\n            a[i][1] = -1\\n        if a[i][-2] == '.':\\n            a[i][-2] = -1\\n    for j in range(1,m+1):\\n        if a[1][j] == '.':\\n            a[1][j] = -1\\n        if a[-2][j] == '.':\\n            a[-2][j] = -1\\n\\n    def ff(n1,n2):\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if a[i][j] == n1:\\n                    a[i][j] = n2\\n    ff('*', inf)\\n\\n    for i in range(1,n+1):\\n        for j in range(1,m+1):\\n            if a[i][j] == '.':\\n                mc = [inf]\\n                if a[i-1][j] != '.': mc.append(a[i-1][j])\\n                if a[i+1][j] != '.': mc.append(a[i+1][j])\\n                if a[i][j+1] != '.': mc.append(a[i][j+1])\\n                if a[i][j-1] != '.': mc.append(a[i][j-1])\\n                mm = min(mc)\\n                if mm < inf:\\n                    a[i][j] = mm\\n                    for t in [_ for _ in mc if _ < inf and _ != mm]:\\n                        ff(t,mm)\\n                else:\\n                    a[i][j] = c\\n                    c += 1\\n    cnt = [0] * c\\n    for i in range(1,n+1):\\n        for j in range(1,m+1):\\n            if -1 < a[i][j] < c:\\n                cnt[a[i][j]] += 1\\n    cnt2 = [_ for _ in cnt if _ > 0]\\n    r = 0\\n    for _i in range(len(cnt2) - k):\\n        cnt2 = [_ for _ in cnt if _ > 0]\\n        mm = min(cnt2)\\n        ind = cnt.index(mm)\\n        cnt[ind] = 0\\n        r += mm\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if a[i][j] == ind:\\n                    a[i][j] = '*'\\n\\n    print(r)\\n\\n    for i in range(1,n+1):\\n        s = ''\\n        for j in range(1,m+1):\\n            c = a[i][j]\\n            if c == '*':\\n                s += c\\n            elif c == inf:\\n                s += '*'\\n            else:\\n                s += '.'\\n        print(s)\\n\\nf()\\n\", \"#!/usr/bin/env python3\\n\\nfrom collections import deque\\n\\n\\ndef main():\\n    DELTAS = (\\n        (-1, 0),\\n        (0, 1),\\n        (1, 0),\\n        (0, -1),\\n    )\\n\\n    try:\\n        while True:\\n            n, m, k = list(map(int, input().split()))\\n            grid = [list(input()) for i in range(n)]\\n            lakes = [ ]\\n            q = deque()\\n            for i in range(n):\\n                for j in (0, m - 1):\\n                    if grid[i][j] == '.':\\n                        grid[i][j] = '?'\\n                        q.append((i, j))\\n                        while q:\\n                            y, x = q[0]\\n                            q.popleft()\\n                            for dy, dx in DELTAS:\\n                                ny = y + dy\\n                                nx = x + dx\\n                                if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == '.':\\n                                    grid[ny][nx] = '?'\\n                                    q.append((ny, nx))\\n            for i in (0, n - 1):\\n                for j in range(m):\\n                    if grid[i][j] == '.':\\n                        grid[i][j] = '?'\\n                        q.append((i, j))\\n                        while q:\\n                            y, x = q[0]\\n                            q.popleft()\\n                            for dy, dx in DELTAS:\\n                                ny = y + dy\\n                                nx = x + dx\\n                                if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == '.':\\n                                    grid[ny][nx] = '?'\\n                                    q.append((ny, nx))\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j] == '.':\\n                        grid[i][j] = '?'\\n                        q.append((i, j))\\n                        area = 1\\n                        while q:\\n                            y, x = q[0]\\n                            q.popleft()\\n                            for dy, dx in DELTAS:\\n                                ny = y + dy\\n                                nx = x + dx\\n                                if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == '.':\\n                                    grid[ny][nx] = '?'\\n                                    q.append((ny, nx))\\n                                    area += 1\\n\\n                        lakes.append((area, i, j))\\n\\n            lakes.sort(reverse=True)\\n            print(sum(x[0] for x in lakes[k:]))\\n            for _, i, j in lakes[k:]:\\n                grid[i][j] = '*'\\n                q.append((i, j))\\n                while q:\\n                    y, x = q[0]\\n                    q.popleft()\\n                    for dy, dx in DELTAS:\\n                        ny = y + dy\\n                        nx = x + dx\\n                        if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == '?':\\n                            grid[ny][nx] = '*'\\n                            q.append((ny, nx))\\n\\n            print('\\\\n'.join(\\\"\\\".join(ls).replace('?', '.') for ls in grid))\\n\\n    except EOFError:\\n        pass\\n\\n\\nmain()\\n\", \"from pprint import pprint\\nimport itertools\\nimport collections\\n\\nn,m,k = [int(s) for s in input().split()]\\n\\ng = [[0]*m for _ in range(n)]\\n\\nfor i in range(n):\\n    r = input()\\n    for (j,c) in enumerate(r):\\n        if c == '.':\\n            g[i][j] = 1\\n\\nsidecomps = set()\\ncurlab = 1\\nlabels = [[0]*m for _ in range(n)]\\nfor i in range(n):\\n    for j in range(m):\\n        if g[i][j] != 1 or labels[i][j] > 0:\\n            continue\\n        #print(i,j)\\n        labels[i][j] = curlab\\n        stack = [(i,j)]\\n        if i == 0 or j == 0 or i == n-1 or j == m-1:\\n            sidecomps.add(curlab)\\n\\n        while stack:\\n            (i1, j1) = stack.pop()\\n            #print(i1,j1)\\n            for (i2,j2) in [(i1-1,j1),(i1+1,j1),(i1,j1-1),(i1,j1+1)]:\\n                if (0 <= i2 and i2 < n and 0 <= j2 and j2 < m\\\\\\n                        and g[i2][j2] == 1 and labels[i2][j2] == 0):\\n                    labels[i2][j2] = curlab\\n                    stack.append((i2,j2))\\n                    if i2 == 0 or j2 == 0 or i2 == n-1 or j2 == m-1:\\n                        sidecomps.add(curlab)\\n        curlab += 1\\n\\nlakes = collections.defaultdict(list)\\nfor i,j in itertools.product(list(range(n)), list(range(m))):\\n    lab = labels[i][j]\\n    if lab > 0 and lab not in sidecomps:\\n        lakes[lab].append((i,j))\\n#pprint(dict(lakes))\\n\\nlakesizes = sorted((len(lakes[lab]),lab) for lab in lakes)\\nnum_remove = len(lakesizes)-k\\nans = 0\\nfor _,lab in lakesizes[:num_remove]:\\n    for (i,j) in lakes[lab]:\\n        g[i][j] = 0\\n        ans += 1\\n\\nprint(ans)\\nfor i in range(n):\\n    print(''.join('.' if g[i][j] else '*' for j in range(m)))\\n\", \"def ex(i, j, n, m):\\n\\tif i < n and i >= 0 and j < m and j >= 0:\\n\\t\\treturn True\\n\\telse:\\n\\t\\treturn False\\nn, m, k = map(int, input().split())\\nA = []\\nfor i in range(n):\\n\\tA.append(list(input()))\\nB = [[False for i in range(m)] for j in range(n)]\\nL = []\\nfor i in range(n):\\n\\tfor j in range(m):\\n\\t\\tif not B[i][j] and A[i][j] == '.':\\n\\t\\t\\tsides = False\\n\\t\\t\\tOz = [[i, j]]\\n\\t\\t\\tcount = 1\\n\\t\\t\\tQ = [[i, j]]\\n\\t\\t\\tB[i][j] = True\\n\\t\\t\\twhile len(Q) > 0:\\n\\t\\t\\t\\tx, y = Q[0][0], Q[0][1]\\n\\t\\t\\t\\tif x == 0 or x == n - 1 or y == 0 or y == m - 1:\\n\\t\\t\\t\\t\\tsides = True\\n\\t\\t\\t\\tif  ex(x - 1, y, n, m) and not B[x - 1][y] and A[x - 1][y] == '.':\\n\\t\\t\\t\\t\\tQ.append([x - 1, y])\\n\\t\\t\\t\\t\\tB[x - 1][y] = True\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tOz.append([x - 1, y])\\n\\t\\t\\t\\tif  ex(x + 1, y, n, m) and not B[x + 1][y] and A[x + 1][y] == '.':\\n\\t\\t\\t\\t\\tQ.append([x + 1, y])\\n\\t\\t\\t\\t\\tB[x + 1][y] = True\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tOz.append([x + 1, y])\\n\\t\\t\\t\\tif  ex(x, y - 1, n , m) and not B[x][y - 1] and A[x][y - 1] == '.':\\n\\t\\t\\t\\t\\tQ.append([x, y - 1])\\n\\t\\t\\t\\t\\tB[x][y - 1] = True\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tOz.append([x, y - 1])\\n\\t\\t\\t\\tif  ex(x, y + 1, n, m) and not B[x][y + 1] and A[x][y + 1] == '.':\\n\\t\\t\\t\\t\\tQ.append([x, y + 1])\\n\\t\\t\\t\\t\\tB[x][y + 1] = True\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tOz.append([x, y + 1])\\n\\t\\t\\t\\tQ.pop(0)\\n\\t\\t\\tif not sides:\\n\\t\\t\\t\\tL.append([count, Oz])\\nL.sort()\\ns = len(L)\\nans = 0\\nfor i in range(s - k):\\n\\tans += L[i][0]\\n\\tfor j in L[i][1]:\\n\\t\\tA[j[0]][j[1]] = '*'\\nprint(ans)\\nfor i in range(n):\\n\\tfor j in range(m):\\n\\t\\tprint(A[i][j], end='')\\n\\tprint()\\n\", \"#!/usr/bin/env python3\\n\\nfrom collections import Counter, defaultdict\\n\\nn, m, k = [int(x) for x in input().split()]\\n\\nmp = [[\\\".\\\"]*(m+2)] + [list(\\\".\\\" + input().strip() + \\\".\\\") for _ in range(n)] + [[\\\".\\\"]*(m+2)]\\nuf = {}\\nfor i in range(n+2):\\n  for j in range(m+2):\\n    uf[(i, j)] = (i, j)\\n\\ndef find(u):\\n  if u != uf[u]:\\n    uf[u] = find(uf[u])\\n  return uf[u]\\n\\ndef union(u, v):\\n  pu = find(u)\\n  pv = find(v)\\n  if pu != pv:\\n    uf[pv] = pu\\n\\nfor i in range(n+2):\\n  for j in range(m+2):\\n    if mp[i][j] == '*':\\n      continue\\n    if i <= n and mp[i+1][j] == '.':\\n      union((i, j), (i+1, j))\\n    if j <= m and mp[i][j+1] == '.':\\n      union((i, j), (i, j+1))\\n\\nd = defaultdict(int)\\nf0 = find((0, 0))\\nfor i in range(n+2):\\n  for j in range(m+2):\\n    if mp[i][j] == '*':\\n      continue\\n    f = find((i, j))\\n    if f != f0:\\n      d[f] += 1\\nl = sorted([(v, k) for k, v in list(d.items())])\\nll = len(l)\\nps = set([u for _, u in l[:ll-k]])\\nr = 0\\nfor i in range(1, n+1):\\n  for j in range(1, m+1):\\n    if mp[i][j] == '.' and find((i, j)) in ps:\\n      mp[i][j] = '*'\\n      r += 1\\n\\nprint(r)\\nprint((\\\"\\\\n\\\".join(\\n  \\\"\\\".join(m[1:-1])\\n  for m in mp[1:-1]\\n)))\\n\", \"import sys, math\\ndef bfs(a):\\n    Q = [a]\\n    ctr = 0\\n    used = [[0] * m for i in range(n)]\\n    while ctr < len(Q):\\n        h = Q[ctr]\\n        ctr += 1\\n        z[h[0]][h[1]] = 'o'\\n        if h[0] - 1 >= 0 and z[h[0] - 1][h[1]] == '.' and not used[h[0] - 1][h[1]]:\\n            Q.append([h[0] - 1, h[1]])\\n            used[h[0] - 1][h[1]] = 1\\n        if h[0] + 1 < n and z[h[0] + 1][h[1]] == '.' and not used[h[0] + 1][h[1]]:\\n            Q.append([h[0] + 1, h[1]])\\n            used[h[0] + 1][h[1]] = 1\\n        if h[1] - 1 >= 0 and z[h[0]][h[1] - 1] == '.' and not used[h[0]][h[1] - 1]:\\n            Q.append([h[0], h[1] - 1])\\n            used[h[0]][h[1] - 1] = 1\\n        if h[1] + 1 < m and z[h[0]][h[1] + 1] == '.' and not used[h[0]][h[1] + 1]:\\n            Q.append([h[0], h[1] + 1])\\n            used[h[0]][h[1] + 1] = 1\\n\\ndef bfs1(a, b):\\n    Q = [a]\\n    ctr = 0\\n    while ctr < len(Q):\\n        h = Q[ctr]\\n        ctr += 1\\n        if z[h[0]][h[1]] == b:\\n            continue\\n        z[h[0]][h[1]] = b\\n        if h[0] - 1 >= 0 and z[h[0] - 1][h[1]] == '.':\\n            Q.append([h[0] - 1, h[1]])\\n        if h[0] + 1 < n and z[h[0] + 1][h[1]] == '.':\\n            Q.append([h[0] + 1, h[1]])\\n        if h[1] - 1 >= 0 and z[h[0]][h[1] - 1] == '.':\\n            Q.append([h[0], h[1] - 1])\\n        if h[1] + 1 < m and z[h[0]][h[1] + 1] == '.':\\n            Q.append([h[0], h[1] + 1])\\n    ctr = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if z[i][j] == b:\\n                ctr += 1\\n    return ctr\\n        \\nn, m, k = map(int, input().split())\\nz = [list(input()) for i in range(n)]\\nfor i in range(n):\\n    if z[i][0] == '.':\\n        bfs([i, 0])\\n    if z[i][m - 1] == '.':\\n        bfs([i, m - 1])\\nfor i in range(m):\\n    if z[0][i] == '.':\\n        bfs([0, i])\\n    if z[n - 1][i] == '.':\\n        bfs([n - 1, i])\\nctr = 0\\nz1 = []\\nfor i in range(n):\\n    for j in range(m):\\n        if z[i][j] == '.':\\n            z1.append([bfs1([i, j], ctr), ctr])\\n            ctr += 1\\nz1.sort()\\ndif = ctr - k\\nans = 0\\nfor i in range(dif):\\n    u = z1[i][1]\\n    ans += z1[i][0]\\n    for j in range(n):\\n        for k in range(m):\\n            if z[j][k] == u:\\n                z[j][k] = '*'\\nfor i in range(n):\\n    for j in range(m):\\n        if z[i][j] != '*' and z[i][j] != '.':\\n            z[i][j] = '.'\\nprint(ans)\\nfor i in range(n):\\n    print(*z[i], sep = '')\\n    \\n            \\n            \\n\\n\\n\\n\", \"import sys\\nimport copy\\nsys.setrecursionlimit(10000000)\\n\\nh, w, k = list(map(int,input().split()))\\nground = [list(input()) for j in range(h)]\\nground2 = copy.deepcopy(ground)\\n\\ndx = [1,0,-1,0]\\ndy = [0,1,0,-1]\\ncnt = 0\\n\\ndef dfs(x,y,count):\\n    ground[y][x] = str(count)\\n    #print(y,x)\\n    for k in range(4):\\n        if 0 <= x + dx[k] < w and 0 <= y + dy[k] < h:\\n            if ground[y+dy[k]][x+dx[k]] == \\\".\\\":\\n                dfs(x+dx[k], y+dy[k], count)\\n\\nfor j in range(h):\\n    for i in range(w):\\n        if ground[j][i] == \\\".\\\":\\n            dfs(i, j, cnt)\\n            cnt += 1\\n\\narr = [[0, i] for i in range(cnt)]\\n\\nfor num in range(cnt):\\n    f = True\\n    for j in range(h):\\n        for i in range(w):\\n            #print(num,j,i,ground[j][i])\\n            if ground[j][i] == str(num):\\n                arr[num][0] += 1\\n                if i == 0 or i == w - 1 or j == 0 or j == h - 1:\\n                    f = False\\n                    arr[num][0] += 10**10\\n                    break\\n                    #print(num,j,i)\\n            if not f:\\n                break\\n        if not f:\\n            break\\n\\narr.sort()\\n\\nfor j in range(len(arr)):\\n    if arr[j][0] > 10**10:\\n        cnt -= 1\\n\\nnum_lake = cnt\\nans = 0\\n\\\"\\\"\\\"\\nprint(cnt,arr)\\nprint(k)\\n\\\"\\\"\\\"\\nif cnt == k:\\n    print(ans)\\n    for j in range(h):\\n        print(\\\"\\\".join(ground2[j][:]))\\n    return\\n\\nfor num in range(cnt):\\n    groundbef = ground[:][:]\\n    f = True\\n    cells = 0\\n    for j in range(h):\\n        for i in range(w):\\n            if ground[j][i] == str(arr[num][1]):\\n                if i < 0 or i > w - 1 or j < 0 or j > h - 1:\\n                    f = False\\n                    print(\\\"F\\\", i,j)\\n                    break\\n                ground[j][i] = \\\"*\\\"\\n                cells += 1\\n\\n    if not f:\\n        ground = groundbef[:][:]\\n        num_lake -= 1\\n\\n    else:\\n        num_lake -= 1\\n        ans += cells\\n\\n    if num_lake == k :\\n        break\\n\\nfor j in range(h):\\n    for i in range(w):\\n        if ground[j][i] == \\\"*\\\":\\n            continue\\n        else:\\n            ground[j][i] = \\\".\\\"\\n\\nprint(ans)\\nfor j in range(h):\\n    print(\\\"\\\".join(ground[j][:]))\\n\\n\\n\\n\\\"\\\"\\\"\\nimport sys\\nsys.setrecursionlimit(10000000)\\n\\nh, w, k = map(int,input().split())\\nground = [list(input()) for j in range(h)]\\n\\ndx = [1,0,-1,0]\\ndy = [0,1,0,-1]\\ncnt = 0\\n\\ndef dfs(x,y,count):\\n    ground[y][x] = str(count)\\n    #print(y,x)\\n    for k in range(4):\\n        if 0 <= x + dx[k] < w and 0 <= y + dy[k] < h:\\n            if ground[y+dy[k]][x+dx[k]] == \\\".\\\":\\n                dfs(x+dx[k], y+dy[k], count)\\n\\nfor j in range(h):\\n    for i in range(w):\\n        if ground[j][i] == \\\".\\\":\\n            #print(cnt, i, j)\\n            dfs(i, j, cnt)\\n            cnt += 1\\n\\narr = [[0, i] for i in range(cnt)]\\nfor num in range(cnt):\\n    for j in range(h):\\n        for i in range(w):\\n            if ground[j][i] == str(num):\\n                arr[num][0] += 1\\n\\nnum_lake = cnt\\narr.sort()\\nans = 0\\n\\nfor num in range(cnt):\\n    groundbef = ground[:][:]\\n    f = True\\n    cells = 0\\n    for j in range(h):\\n        for i in range(w):\\n            if ground[j][i] == str(arr[num][1]):\\n                if i == 0 or i == w - 1 or j == 0 or j == h - 1:\\n                    f = False\\n                    break\\n                ground[j][i] = \\\"*\\\"\\n                cells += 1\\n\\n            if not f:\\n                break\\n\\n        if not f:\\n            break\\n\\n    if not f:\\n        ground = groundbef[:][:]\\n        num_lake -= 1\\n\\n    else:\\n        num_lake -= 1\\n        ans += cells\\n\\n    if num_lake == k + 1:\\n        break\\n\\nfor j in range(h):\\n    for i in range(w):\\n        if ground[j][i] == \\\"*\\\":\\n            continue\\n        else:\\n            ground[j][i] = \\\".\\\"\\n\\nprint(ans)\\nfor j in range(h):\\n    print(\\\"\\\".join(ground[j][:]))\\n\\\"\\\"\\\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\\"\\\"\\\"\\n#c\\nn, m = map(int,input().split())\\na = list(map(int,input().split()))\\n\\n\\\"\\\"\\\"\\n\\n\\n\\\"\\\"\\\"\\nl = int(input())\\ns = input()\\n\\nleft = 0\\nans = [0] * 2\\ncurrent = \\\"\\\"\\n\\nfor i in range(l):\\n    if s[i] == \\\"_\\\":\\n        if current != \\\"\\\":\\n            if left == 0:\\n                ans[0] = max(ans[0], len(current))\\n            else:\\n                ans[1] += 1\\n                #print(1, current)\\n\\n        current = \\\"\\\"\\n        continue\\n\\n    if s[i] == \\\"(\\\":\\n        ans[0] = max(ans[0], len(current))\\n        left += 1\\n        current = \\\"\\\"\\n\\n    elif s[i] == \\\")\\\":\\n        if current != \\\"\\\":\\n            ans[1] += 1\\n            #print(1, current)\\n        left = 0\\n        current = \\\"\\\"\\n    else:\\n        current += s[i]\\n    #print(current)\\n\\nif current != \\\"\\\":\\n    ans[0] = max(ans[0], len(current))\\n\\nprint(ans[0], ans[1])\\n\\\"\\\"\\\"\\n\\n\\n\\\"\\\"\\\"\\nx = list(map(int,input().split()))\\nans = 10 ** 10\\nfor i in range(1, 101):\\n    dis = 0\\n    for j in range(3):\\n        dis += abs(x[j] - i)\\n    ans = min(ans, dis)\\nprint(ans)\\n\\\"\\\"\\\"\\n\", \"import sys\\nimport copy\\nsys.setrecursionlimit(10000000)\\n\\nh, w, k = list(map(int,input().split()))\\nground = [list(input()) for j in range(h)]\\nground2 = copy.deepcopy(ground)\\n\\ndx = [1,0,-1,0]\\ndy = [0,1,0,-1]\\ncnt = 0\\n\\ndef dfs(x,y,count):\\n    ground[y][x] = str(count)\\n    #print(y,x)\\n    for k in range(4):\\n        if 0 <= x + dx[k] < w and 0 <= y + dy[k] < h:\\n            if ground[y+dy[k]][x+dx[k]] == \\\".\\\":\\n                dfs(x+dx[k], y+dy[k], count)\\n\\nfor j in range(h):\\n    for i in range(w):\\n        if ground[j][i] == \\\".\\\":\\n            dfs(i, j, cnt)\\n            cnt += 1\\n\\narr = [[0, i] for i in range(cnt)]\\n\\nfor num in range(cnt):\\n    f = True\\n    for j in range(h):\\n        for i in range(w):\\n            #print(num,j,i,ground[j][i])\\n            if ground[j][i] == str(num):\\n                arr[num][0] += 1\\n                if i == 0 or i == w - 1 or j == 0 or j == h - 1:\\n                    f = False\\n                    arr[num][0] += 10**10\\n                    break\\n                    #print(num,j,i)\\n            if not f:\\n                break\\n        if not f:\\n            break\\n\\narr.sort()\\n\\nfor j in range(len(arr)):\\n    if arr[j][0] > 10**10:\\n        cnt -= 1\\n\\nnum_lake = cnt\\nans = 0\\n\\\"\\\"\\\"\\nprint(cnt,arr)\\nprint(k)\\n\\\"\\\"\\\"\\nif cnt == k:\\n    print(ans)\\n    for j in range(h):\\n        print(\\\"\\\".join(ground2[j][:]))\\n    return\\n\\nfor num in range(cnt):\\n    groundbef = ground[:][:]\\n    f = True\\n    cells = 0\\n    for j in range(h):\\n        for i in range(w):\\n            if ground[j][i] == str(arr[num][1]):\\n                if i < 0 or i > w - 1 or j < 0 or j > h - 1:\\n                    f = False\\n                    print(\\\"F\\\", i,j)\\n                    break\\n                ground[j][i] = \\\"*\\\"\\n                cells += 1\\n\\n    if not f:\\n        ground = groundbef[:][:]\\n        num_lake -= 1\\n\\n    else:\\n        num_lake -= 1\\n        ans += cells\\n\\n    if num_lake == k :\\n        break\\n\\nfor j in range(h):\\n    for i in range(w):\\n        if ground[j][i] == \\\"*\\\":\\n            continue\\n        else:\\n            ground[j][i] = \\\".\\\"\\n\\nprint(ans)\\nfor j in range(h):\\n    print(\\\"\\\".join(ground[j][:]))\\n\", \"import sys\\nsys.setrecursionlimit(100000)\\n\\ndef find(x,y,tag):\\n    if mplake[x][y] == tag or mp[x][y] == \\\"*\\\":\\n        return\\n    mplake[x][y] = tag\\n    lakes[tag] += 1\\n    for i in [(1,0),(-1,0),(0,1),(0,-1)]:\\n        if 0 <= x+i[0] and x+i[0] < n and 0 <= y + i[1] and y+i[1] < m:\\n            find(x+i[0],y+i[1],tag)\\n\\ndef fill(x,y,tag):\\n    nonlocal cnt\\n    if mplake[x][y] == tag:\\n        mplake[x][y] = -1\\n        mp[x][y] = \\\"*\\\"\\n        cnt += 1\\n        for i in [(1,0),(-1,0),(0,1),(0,-1)]:\\n            if 0 <= x+i[0] and x+i[0] < n and 0 <= y + i[1] and y+i[1] < m:\\n                fill(x+i[0],y+i[1],tag)\\n\\nn, m, k = [int(i) for i in input().split()]\\nmp = []\\nmplake = []\\nfor i in range(n):\\n    mp.append(list(input()))\\n    mplake.append([-1 for i in range(m)])\\n\\nstart = [(0,0)]\\nlakes = [0]\\ncnt = 0\\n\\nfor i in range(n):\\n    find(i,0,0)\\n    find(i,m-1,0)\\nfor i in range(m):\\n    find(0,i,0)\\n    find(n-1,i,0)\\n\\nfor i in range(1,n-1):\\n    for j in range(1,m-1):\\n        if mp[i][j] == \\\".\\\" and mplake[i][j] == -1:\\n            start.append((i,j))\\n            lakes.append(0)\\n            find(i,j,len(lakes)-1)\\n\\nr = sorted([(lakes[i],start[i]) for i in range(1,len(lakes))])\\n\\nfor i in range(len(r)-k):\\n    fill(r[i][1][0],r[i][1][1],mplake[r[i][1][0]][r[i][1][1]])\\n\\nprint(cnt)\\nfor i in range(n):\\n    print(\\\"\\\".join(mp[i]))\\n\", \"\\ndef make_set(a):\\n    parent[a] = a\\n    size[a] = 1\\n    \\n      \\ndef find_set(a):\\n        if a == parent[a]:\\n            return a\\n        else:\\n            parent[a] = find_set(parent[a])\\n        return parent[a]\\n    \\n\\ndef union_sets(a, b):\\n    a = find_set(a)\\n    b = find_set(b)\\n    if a != b:\\n        if size[a] < size[b]:\\n            a, b = b, a\\n        parent[b] = a\\n        size[a] += size[b]\\n        \\n        \\n        \\n        \\ndef is_valid(a):\\n    i = a[0]\\n    j = a[1]\\n    if 0<=i<=n-1 and 0<=j<=m-1:\\n        if A[i][j] == '.':\\n            if (i,j) not in parent:\\n                return False\\n            else:\\n                return True \\n        else:\\n            return True\\n    else:\\n        return True\\n        \\n        \\n        \\n        \\n        \\nparent = dict()\\nsize = dict()\\nn,m,ks = map(int, input().split())\\nA = [0] * n\\nfor i in range(n):\\n    A[i] = list(input())\\n\\nfor i in range(n):\\n    for j in range(m):\\n        if i != 0 and j != 0 and i != n - 1 and j != m - 1:\\n        \\n            if A[i][j] == '.':\\n                if is_valid((i-1,j)) and is_valid((i,j-1)):\\n                    \\n                    make_set((i,j))\\n                    if (i-1,j) in parent:\\n                        union_sets((i-1,j), (i,j))\\n                    if (i,j-1) in parent:\\n                        union_sets((i,j-1), (i,j))\\n                else:\\n                    if A[i][j] =='.':\\n                        dels = []\\n                        if (i-1,j) in parent:\\n                            a1 = find_set((i-1,j))\\n                           \\n                            for k in parent:\\n                                if find_set(k) == a1:\\n                                    \\n                                    dels.append(k)\\n                      \\n                        for f in dels:\\n                            \\n                            parent.pop(f)\\n                        dels = []\\n                        if (i,j-1) in parent:\\n                            \\n                            a1 = find_set((i,j-1))\\n                            \\n                            for k in parent:\\n                                if find_set(k) == a1:\\n                                    dels.append(k)\\n                        \\n                        for f in dels:\\n                            \\n                            parent.pop(f)            \\n                        \\n        else:\\n            if A[i][j] =='.':\\n                dels = []\\n                if (i-1,j) in parent:\\n                    a1 = find_set((i-1,j))\\n                   \\n                    for k in parent:\\n                        if find_set(k) == a1:\\n                            \\n                            dels.append(k)\\n              \\n                for f in dels:\\n                    \\n                    parent.pop(f)\\n                dels = []\\n                if (i,j-1) in parent:\\n                    \\n                    a1 = find_set((i,j-1))\\n                    \\n                    for k in parent:\\n                        if find_set(k) == a1:\\n                            dels.append(k)\\n                \\n                for f in dels:\\n                    \\n                    parent.pop(f)    \\n\\nans = 0\\nass = 0\\nans2 = []\\nfor j in parent:\\n    a1 = find_set(j)\\n    if a1 not in ans2:\\n        ans2.append(a1)\\n        ans +=1\\nfor j in range(ans-ks):\\n    mins = float('infinity')\\n    numer = 0\\n    new_sizes = dict()\\n    for t in parent:\\n        a1 = find_set(t)\\n        if a1 in new_sizes:\\n            new_sizes[a1] +=1\\n        else:\\n            new_sizes[a1] = 1\\n    \\n    for t in new_sizes:\\n        if new_sizes[t] < mins:\\n            mins = new_sizes[t]\\n            numer = t\\n    ass += mins \\n    dels = []\\n    for t in parent:\\n        \\n        if find_set(t) == numer:\\n            dels.append(t)\\n            \\n            A[t[0]][t[1]] = '*'      \\n    for t in dels:\\n        parent.pop(t)\\nprint(ass)\\nfor j in range(n):\\n    print(''.join(A[j]))\", \"x,y,k=list(map(int,input().split()))\\na=[input().strip() for i in range(x)]\\nm=[[0 if j=='*' else 1 for j in i] for i in a]\\nm1=[[0 if j=='*' else 1 for j in i] for i in a]\\nlk=[]\\n\\ndef bfs(m,i,j):\\n\\tq=set()\\n\\ts=0\\n\\tf=1\\n\\tq.add((i,j))\\n\\twhile q:\\n\\t\\tax,ay=q.pop()\\n\\t\\tm[ax][ay]=0\\n\\t\\ts+=1\\n\\t\\tif ax==0 or ay==0 or ax==x-1 or ay==y-1:f=0\\n\\t\\tif ax<x-1 and m[ax+1][ay]:\\n\\t\\t\\tq.add((ax+1,ay))\\n\\t\\tif ax>0 and m[ax-1][ay]:\\n\\t\\t\\tq.add((ax-1,ay))\\n\\t\\tif ay<y-1 and m[ax][ay+1]:\\n\\t\\t\\tq.add((ax,ay+1))\\n\\t\\tif ay>0 and m[ax][ay-1]:\\n\\t\\t\\tq.add((ax,ay-1))\\n\\treturn f,s\\n\\nfor i in range(x):\\n\\tfor j in range(y):\\n\\t\\tif m1[i][j]:\\n\\t\\t\\tf,s=bfs(m1,i,j)\\n\\t\\t\\tif f:\\n\\t\\t\\t\\tlk.append((s,i,j))\\nlk.sort()\\nk1=len(lk)\\nsal=0\\nfor e in range(k1-k):\\n\\ts,i,j=lk[e]\\n\\tsal+=s\\n\\tbfs(m,i,j)\\nprint(sal)\\nfor i in range(x):\\n\\tprint(''.join(['.' if j else '*' for j in m[i]]))\\n\", \"def find_neigh(t,x,y):\\n    return [(i,j) for (i,j) in [(x-1,y),(x+1,y),(x,y-1),(x,y+1),(x,y+1)]\\n            if t[i][j]=='.']\\n\\ndef lake(table):\\n    return [(i,j) for i in range(0,len(table)-1)\\n                  for j in range(0, len(table[i])-1)\\n            if table[i][j] == '.']\\n\\nstack=set()\\ndef the_lake(table,x,y):\\n    queue=[(x,y)]\\n    counted=set()\\n    counted.add((x,y))\\n    stack.add((x,y))\\n    while queue:\\n        start=queue.pop()\\n        for (i,j) in find_neigh(table,*start):\\n            if (i,j) in counted:\\n                continue\\n            stack.add((i,j))\\n            queue.append((i,j))\\n            counted.add((i,j))\\n    for (i,j) in counted:\\n        if table[i+1][j]=='0' or table[i-1][j]=='0':\\n            return\\n        if table[i][j+1]=='0' or table[i][j-1]=='0':\\n            return\\n    return counted\\n\\ndef island(table,n,m,k):\\n    lakes=[]\\n    count=0\\n    for (i,j) in lake(table):\\n        if (i,j) in stack:\\n            continue\\n        tlake=the_lake(table,i,j)\\n        if tlake==None:\\n            continue\\n        lakes.append(tlake)\\n    lakes=sorted(lakes,key=len)\\n    for p in range(0,len(lakes)-k):\\n        for i,j in lakes[p]:\\n            row=list(table[i])\\n            row[j]='*'\\n            count+=1\\n            table[i]=''.join(row)\\n    print(count)\\n    for i in range(1,n+1):\\n        print(table[i][1:m+1])\\n    \\nn,m,k=input().split(' ')\\ncarta=[]\\nfor i in range(int(n)):\\n    row='0'+input()+'0'\\n    carta.append(row)\\ncarta=['0'*(int(m)+2)]+carta+['0'*(int(m)+2)]\\nisland(carta,int(n),int(m),int(k))\", \"def mark(z):\\n  while z: z = z[0]\\n  return z\\n\\ndef mark2(z):\\n  while z and type(z) == list: z = z[0]\\n  return z\\n  \\n__debug = None  \\n  \\nn, m, kk = map(int, input().split())\\ndata = [list(input()) for i in range(n)]\\n\\nocean = []\\nearth = []\\nwork = [[] for i in range(m*n)]\\n\\nfor k in range(m):\\n  if data[0][k] == '.':\\n    work[m*0 + k].append(ocean)\\n  if data[n-1][k] == '.':\\n    work[m*(n-1) + k].append(ocean)\\nfor i in range(n):\\n  if data[i][0] == '.':\\n    work[m*i + 0].append(ocean)\\n  if data[i][m-1] == '.':\\n    work[m*i + m-1].append(ocean)\\n\\nfor i in range(n):\\n  for k in range(m):\\n    if data[i][k] == '.':\\n      z = mark(work[m*i + k])\\n      if i and data[i-1][k] == '.':\\n        zi = mark(work[m*(i-1) + k])\\n        if z is not zi:\\n          if z is ocean:\\n            zi.append(z)\\n          else:  \\n            z.append(zi)\\n            z = zi\\n      if k and data[i][k-1] == '.':\\n        zk = mark(work[m*i + k-1])\\n        if z is not zk:\\n          if z is ocean:\\n            zk.append(z)\\n          else:  \\n            z.append(zk)\\n\\nisl = {}\\nno = 1    \\n\\nfor i in range(n):\\n  for k in range(m):\\n    if data[i][k] == '.':\\n      if __debug: print(i, end=\\\" \\\")\\n      if __debug: print(k, end=\\\": \\\")\\n      z = mark2(work[m*i + k])\\n      if z:\\n        isl[z].append((i,k)) \\n        if __debug: print(z, end=\\\", old\\\")\\n      elif z is not ocean:\\n        z.append(no)\\n        if __debug: print(no, end=\\\", new\\\")\\n        isl[no] = [(i,k)] \\n        no += 1\\n      if __debug: print()\\n\\nif __debug: print(isl)\\nisl_s = list(isl.values())\\nif __debug: print(isl_s)\\nisl_s.sort(key = len)\\nif __debug: print(isl_s)\\ndelta = len(isl_s) - kk\\nif __debug: print(len(isl_s), end=\\\" \\\")\\nif __debug: print(kk)\\nfor t in range(delta):\\n  for i, k in isl_s[t]:\\n    data[i][k] = '*'\\n    \\nprint(sum(map(len, isl_s[:delta])))\\nfor i in range(n):\\n  print(\\\"\\\".join(data[i]))\", \"import sys\\nsys.setrecursionlimit(100000)\\n\\nn,m,k = map(int,input().split())\\n\\narr = []\\nfor i in range(n):\\n    krr = []\\n    p = input()\\n    for x in p:\\n        if(x=='*'):\\n            krr.append(0)\\n        else:\\n            krr.append(-1)\\n    arr.append(krr)\\n\\nlakes = [-1]\\nislakes = [-1]\\nlakesp = [[-1,-1]]\\n\\ndef go(x,y,c):\\n    if(x<0)or(x>=n)or(y<0)or(y>=m):\\n        return\\n    if(arr[x][y]==0):\\n        return\\n    if(arr[x][y]!=-1):\\n        return\\n    arr[x][y] = c\\n    if(x==0)or(x==n-1)or(y==0)or(y==m-1):\\n        islakes[c] = 0\\n    lakes[c] += 1\\n    go(x-1,y,c)\\n    go(x,y-1,c)\\n    go(x+1,y,c)\\n    go(x,y+1,c)\\n\\n\\ncolor = 0\\nfor x in range(n):\\n    for y in range(m):\\n        if(arr[x][y]==-1):\\n            color += 1\\n            lakes.append(0)\\n            islakes.append(1)\\n            go(x,y,color)\\n            lakesp.append([x,y])\\n\\ndef re(x,y):\\n    if(x<0)or(x>=n)or(y<0)or(y>=m):\\n        return\\n    if(arr[x][y]==0):\\n        return\\n    arr[x][y] = 0\\n    re(x-1,y)\\n    re(x,y-1)\\n    re(x+1,y)\\n    re(x,y+1)\\n\\ndef min():\\n    min = 1000000000\\n    mini = 0\\n    for i in range(1,color+1):\\n        if(islakes[i]):\\n            if(min>lakes[i]):\\n                min = lakes[i]\\n                mini = i\\n    return mini\\n\\ncnt = 0\\nnn = 0\\nfor i in range(1,color+1):\\n    if(islakes[i]==0):\\n        continue\\n    nn += 1\\n\\np = nn-k\\nfor i in range(1,color+1):\\n    if(p==0):\\n        break\\n    j = min()\\n    cnt += lakes[j]\\n    lakes[j] = 1000000000\\n    re(lakesp[j][0],lakesp[j][1])\\n    p -= 1\\n\\nprint(cnt)\\nfor x in arr:\\n    s = ''\\n    for y in x:\\n        if(y==0):\\n            s += '*'\\n        else:\\n            s += '.'\\n    print(s)\", \"import sys\\n\\nsys.setrecursionlimit(5000)\\n\\nn, m, k = [int(x) for x in input().split()]\\n\\nland = []\\ncc = 0\\nvisit = [[0 for _ in range(m)] for _ in range(n)]\\nfor i in range(n):\\n    land.append(list(input()))\\nedge = False\\n\\ndef DFS(i, j, c):\\n    nonlocal land, n, m, k, cc, visit, edge\\n    if i <= 0 or j <= 0 or i >= n-1 or j >= m-1:\\n        edge = True\\n        return 0\\n    if visit[i][j] != 0: return 0\\n    if land[i][j] == '*': return 0\\n    visit[i][j] = 1\\n    cc += 1\\n    if land[i + 1][j] == '.': DFS(i + 1, j, c + 1)\\n    if land[i - 1][j] == '.': DFS(i - 1, j, c + 1)\\n    if land[i][j + 1] == '.': DFS(i, j + 1, c + 1)\\n    if land[i][j - 1] == '.': DFS(i, j - 1, c + 1)\\n\\ndef DFS2(i, j):\\n    nonlocal land, n, m, k, cc\\n    if i < 0 or j < 0 or i >= n or j >= m: return 0\\n    if land[i][j] != '.': return 0\\n    land[i][j] = '*'\\n    DFS2(i+1,j)\\n    DFS2(i - 1, j)\\n    DFS2(i, j+1)\\n    DFS2(i, j-1)\\n    return 0\\n\\n\\nccc = []\\npos = []\\n\\nfor i in range(n):\\n    for j in range(m):\\n        cc = 0\\n        edge = False\\n        if visit[i][j] == 0:\\n            DFS(i,j,0)\\n            if edge is True: continue\\n            if cc > 0:\\n                ccc.append([cc, i, j])\\n\\n\\nccc.sort()\\n\\nred =len(ccc) - k\\n\\nif red == 0:\\n    print(0)\\n    for i in range(n):\\n        print(''.join(land[i]))\\n    return\\n\\nred_list = ccc[0:red]\\n\\np = [x[0] for x in red_list]\\nprint(sum(p))\\n\\nfor i in range(len(red_list)):\\n    DFS2(red_list[i][1], red_list[i][2])\\n\\nfor i in range(n):\\n    print(''.join(land[i]))\", \"def mark(z):\\n  while z: z = z[0]\\n  return z\\n\\ndef mark2(z):\\n  while z and type(z) == list: z = z[0]\\n  return z\\n  \\n__debug = None  \\n  \\nn, m, kk = map(int, input().split())\\ndata = [list(input()) for i in range(n)]\\n\\nocean = []\\nearth = []\\nwork = [[] for i in range(m*n)]\\n\\nfor k in range(m):\\n  if data[0][k] == '.':\\n    work[m*0 + k].append(ocean)\\n  if data[n-1][k] == '.':\\n    work[m*(n-1) + k].append(ocean)\\nfor i in range(1,n-1):\\n  if data[i][0] == '.':\\n    work[m*i + 0].append(ocean)\\n  if data[i][m-1] == '.':\\n    work[m*i + m-1].append(ocean)\\n\\nfor i in range(1,n):\\n  for k in range(1,m):\\n    if data[i][k] == '.':\\n      z = mark(work[m*i + k])\\n      if i and data[i-1][k] == '.':\\n        zi = mark(work[m*(i-1) + k])\\n        if z is not zi:\\n          if z is ocean:\\n            zi.append(z)\\n          else:  \\n            z.append(zi)\\n            z = zi\\n      if k and data[i][k-1] == '.':\\n        zk = mark(work[m*i + k-1])\\n        if z is not zk:\\n          if z is ocean:\\n            zk.append(z)\\n          else:  \\n            z.append(zk)\\n\\nisl = {}\\nno = 1    \\n\\nfor i in range(1,n-1):\\n  for k in range(1,m-1):\\n    if data[i][k] == '.':\\n      if __debug: print(i, end=\\\" \\\")\\n      if __debug: print(k, end=\\\": \\\")\\n      z = mark2(work[m*i + k])\\n      if z:\\n        isl[z].append((i,k)) \\n        if __debug: print(z, end=\\\", old\\\")\\n      elif z is not ocean:\\n        z.append(no)\\n        if __debug: print(no, end=\\\", new\\\")\\n        isl[no] = [(i,k)] \\n        no += 1\\n      if __debug: print()\\n\\nif __debug: print(isl)\\nisl_s = list(isl.values())\\nif __debug: print(isl_s)\\nisl_s.sort(key = len)\\nif __debug: print(isl_s)\\ndelta = len(isl_s) - kk\\nif __debug: print(len(isl_s), end=\\\" \\\")\\nif __debug: print(kk)\\nfor t in range(delta):\\n  for i, k in isl_s[t]:\\n    data[i][k] = '*'\\n    \\nprint(sum(map(len, isl_s[:delta])))\\nfor i in range(n):\\n  print(\\\"\\\".join(data[i]))\", \"import sys\\nfrom collections import defaultdict, OrderedDict\\n\\nsys.setrecursionlimit(10**5)\\nn, m, k = list(map(int, input().split()))\\n\\ng = []\\nfor i in range(n):\\n    g.append(list(input()))\\n\\ndy = [1, -1, 0, 0]\\ndx = [0, 0, 1, -1]\\nd = defaultdict(list)\\n\\n\\ndef dfs(g, u, visited):\\n    visited[u[0]][u[1]] = True\\n    # print(visited)\\n\\n    for i in range(4):\\n        y = u[0] + dy[i]\\n        x = u[1] + dx[i]\\n        # print('y = {0} x = {1}'.format(y, x))\\n        if y >= 0 and y < n and x >= 0 and x < m \\\\\\n           and g[y][x] == '.' and not visited[y][x]:\\n            # if u == (2, 3):\\n                # print('y = {0} x = {1}'.format(y, x))\\n            dfs(g, (y, x), visited)\\n\\n\\ndef dfs_(g, u, visited, component):\\n    visited[u[0]][u[1]] = True\\n    d[component].append(u)\\n\\n    for i in range(4):\\n        y = u[0] + dy[i]\\n        x = u[1] + dx[i]\\n        if y >= 0 and y < n and x >= 0 and x < m \\\\\\n           and g[y][x] == '.' and not visited[y][x]:\\n            dfs_(g, (y, x), visited, component)\\n\\n# dfs from the outer edge and mark the bad ones\\nvisited = [[False for j in range(m)] for i in range(n)]\\n\\nfor i in range(m):\\n    if g[0][i] == '.' and not visited[0][i]:\\n        dfs(g, (0, i), visited)\\n    if g[n - 1][i] == '.' and not visited[-1][i]:\\n        dfs(g, (n - 1, i), visited)\\n\\nfor i in range(1, n - 1):\\n    if g[i][0] == '.' and not visited[i][0]:\\n        dfs(g, (i, 0), visited)\\n    if g[i][m - 1] == '.' and not visited[i][m - 1]:\\n        dfs(g, (i, m - 1), visited)\\n\\ncomponent = 0\\nfor i in range(1, n - 1):\\n    for j in range(1, m - 1):\\n        if g[i][j] == '.' and not visited[i][j]:\\n            dfs_(g, (i, j), visited, component)\\n            component += 1\\n\\n\\n# print(d)\\nl = sorted(list(d.items()), key=lambda x: len(x[1]))\\n\\ni = 0\\ncount = 0\\nwhile component > k:\\n    component -= 1\\n    count += len(l[i][1])\\n    for u in l[i][1]:\\n        g[u[0]][u[1]] = '*'\\n    i += 1\\n\\nprint(count)\\n\\nfor i in range(n):\\n    print(''.join(g[i]))\\n\", \"#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\nimport sys\\ndef delete(j,m):\\n    nonlocal a\\n    i=0\\n    while(i<len(oz[j])):\\n        w,b=oz[j][i],oz[j][i+1]\\n        i+=2\\n        a[w][b]='*'\\ndef poi(i,j,k):\\n    visited[i][j]=True\\n    oz[k]+=i,j\\n    ozsi[k]+=1\\n    if (j-1)>=0 and a[i][j-1]=='.' and not visited[i][j-1]:\\n        poi(i,j-1,k)\\n    if (j+1)<=(m+1) and a[i][j+1]=='.'and not visited[i][j+1]:\\n        poi(i,j+1,k)\\n    if (i-1)>=0 and a[i-1][j]=='.'and not visited[i-1][j]:\\n        poi(i-1,j,k)\\n    if (i+1)<=(n+1) and a[i+1][j] == '.'and not visited[i+1][j]:\\n        poi(i+1, j,k)\\nn,m,vb=map(int,input().split())\\na=[]\\noz=[]\\nozsi=[]\\nvisited=[[False for r in range(m+2)] for t in range(n+2)]\\na.append(['.']*(m+2))\\nsys.setrecursionlimit(3000)\\nfor i in range(n):\\n    s='.'+input()+'.'\\n    a.append([str(x) for x in s])\\nk=0\\na.append(['.']*(m+2))\\nfor i in range(0,n+2):\\n    for j in range(0,m+2):\\n        if a[i][j]=='.':\\n            if not visited[i][j]:\\n                ozsi.append(0)\\n                oz.append([])\\n                poi(i,j,k)\\n                k += 1\\nt=len(ozsi)-vb-1\\ne=0\\nfor i in range(t):\\n    min=10**10\\n    minj=0\\n    for j in range(1,len(ozsi)):\\n        if ozsi[j]<min:\\n            min=ozsi[j]\\n            minj=j\\n    e+=min\\n    delete(minj,min)\\n    ozsi[minj]=10**10\\nprint(e)\\nfor i in range(1,n+1):\\n    for j in range(1,m+1):\\n        print(a[i][j],end='')\\n    print()\", \"from collections import Counter, defaultdict\\n\\nn, m, k = [int(x) for x in input().split()]\\n\\nmp = [[\\\".\\\"] * (m + 2)] + [list(\\\".\\\" + input().strip() + \\\".\\\") for _ in range(n)] + [[\\\".\\\"] * (m + 2)]\\nuf = {}\\nfor i in range(n + 2):\\n    for j in range(m + 2):\\n        uf[(i, j)] = (i, j)\\n\\n\\ndef find(u):\\n    if u != uf[u]:\\n        uf[u] = find(uf[u])\\n    return uf[u]\\n\\n\\ndef union(u, v):\\n    pu = find(u)\\n    pv = find(v)\\n    if pu != pv:\\n        uf[pv] = pu\\n\\n\\nfor i in range(n + 2):\\n    for j in range(m + 2):\\n        if mp[i][j] == '*':\\n            continue\\n        if i <= n and mp[i + 1][j] == '.':\\n            union((i, j), (i + 1, j))\\n        if j <= m and mp[i][j + 1] == '.':\\n            union((i, j), (i, j + 1))\\n\\nd = defaultdict(int)\\nf0 = find((0, 0))\\nfor i in range(n + 2):\\n    for j in range(m + 2):\\n        if mp[i][j] == '*':\\n            continue\\n        f = find((i, j))\\n        if f != f0:\\n            d[f] += 1\\nl = sorted([(v, k) for k, v in list(d.items())])\\nll = len(l)\\nps = set([u for _, u in l[:ll - k]])\\nr = 0\\nfor i in range(1, n + 1):\\n    for j in range(1, m + 1):\\n        if mp[i][j] == '.' and find((i, j)) in ps:\\n            mp[i][j] = '*'\\n            r += 1\\n\\nprint(r)\\nprint(\\\"\\\\n\\\".join( \\\"\\\".join(m[1:-1])for m in mp[1:-1]))\\n\", \"corr = lambda x, y: 0 <= x < n and 0 <= y < m and a[x][y] == '.'\\nocean = lambda x, y: x in (0, n - 1) or y in (0, m - 1)\\nD = (0, 1), (0, -1), (1, 0), (-1, 0)\\nfrom sys import setrecursionlimit\\nsetrecursionlimit(10 ** 5)\\n\\ndef dfs(x, y):\\n    nonlocal size, flag\\n    was[x][y] = clr\\n    size += 1\\n    if ocean(x, y): flag = True\\n    for dx, dy in D:\\n        nx, ny = x + dx, y + dy\\n        if corr(nx, ny) and not was[nx][ny]:\\n            dfs(nx, ny)\\n\\nread = lambda: map(int, input().split())\\nn, m, k = read()\\na = [input() for i in range(n)]\\ns = []\\nwas = [[0] * m for i in range(n)]\\nclr = 1\\nfor i in range(n):\\n    for j in range(m):\\n        if not was[i][j] and a[i][j] == '.':\\n            flag = False\\n            size = 0\\n            dfs(i, j)\\n            if not  flag:\\n                s.append((size, clr))\\n            clr += 1\\ns.sort()\\nans = 0\\ncolor = set()\\nfor i in range(len(s) - k):\\n    ans += s[i][0]\\n    color.add(s[i][1])\\nb = [list(a[i]) for i in range(n)]\\nfor i in range(n):\\n    for j in range(m):\\n        if was[i][j] in color:\\n            b[i][j] = '*'\\nprint(ans)\\n[print(''.join(i)) for i in b]\\n\", \"class DSU:\\n    def __init__(self, n):\\n        self.parents = [-1] * n\\n        self.size = [0] * n\\n\\n    def make(self, v):\\n        if self.parents[v] != -1:\\n            return\\n        self.parents[v] = v\\n        self.size[v] = 1\\n\\n    def find(self, v):\\n        if self.parents[v] in (v, -1):\\n            return self.parents[v]\\n        self.parents[v] = self.find(self.parents[v])\\n        return self.parents[v]\\n\\n    def join(self, v, u):\\n        v = self.find(v)\\n        u = self.find(u)\\n        if v == u or -1 in (u, v):\\n            return\\n        if self.size[v] < self.size[u]:\\n            v, u = u, v\\n        self.parents[u] = v\\n        self.size[v] += self.size[u]\\n\\ndef get_cart2line(m): \\n    return lambda x, y: x * m + y\\n\\ndef main():\\n    n, m, k = map(int, input().split())\\n    g = [list(input()) for _ in range(n)]\\n    \\n    ocean = 0\\n    dsu = DSU(n * m)\\n    dsu.make(ocean)\\n    \\n    line = get_cart2line(m)\\n    \\n    for i in range(n):\\n        a, b = line(i, 0), line(i, m - 1)\\n        dsu.make(a)\\n        dsu.make(b)\\n        dsu.join(ocean, a)\\n        dsu.join(ocean, b)\\n\\n    for i in range(m):\\n        a, b = line(0, i), line(n-1, i)\\n        dsu.make(a)\\n        dsu.make(b)\\n        dsu.join(ocean, a)\\n        dsu.join(ocean, b)\\n        \\n    for i in range(n):\\n        for j in range(m):\\n            if g[i][j] == '.':\\n                dsu.make(line(i, j))\\n                if j > 0:\\n                    if g[i][j-1] == '.':\\n                        dsu.join(line(i, j-1), line(i, j))\\n                if i > 0:\\n                    if g[i-1][j] == '.':\\n                        dsu.join(line(i-1, j), line(i, j))\\n\\n    s = set()\\n    for i in range(n):\\n        for j in range(m):\\n            tmp = dsu.find(line(i, j))\\n            if tmp not in (-1, dsu.find(ocean)):\\n                s.add(tmp)\\n    s = [(dsu.find(i), dsu.size[dsu.find(i)]) for i in s]\\n    s.sort(key=lambda x: x[1])\\n    if len(s) == k:\\n        print(0)\\n        print(*(''.join(r) for r in g), sep='\\\\n')\\n        return\\n    s = s[:len(s) - k]\\n    ans = sum((x[1] for x in s))\\n    s = {x[0] for x in s}\\n    for i in range(n):\\n        for j in range(m):\\n            if dsu.find(line(i, j)) in s:\\n                g[i][j] = '*'\\n    print(ans)\\n    print(*(''.join(r) for r in g), sep='\\\\n')\\n\\nmain()\\n\", \"def main():\\n    def dfs(x, y):\\n        nonlocal inner\\n        if land[y][x] == '.':\\n            s = 1\\n            land[y][x] = '*'\\n            if x:\\n                s += dfs(x - 1, y)\\n            else:\\n                inner = False\\n            if x + 1 < m:\\n                s += dfs(x + 1, y)\\n            else:\\n                inner = False\\n            if y:\\n                s += dfs(x, y - 1)\\n            else:\\n                inner = False\\n            if y + 1 < n:\\n                s += dfs(x, y + 1)\\n            else:\\n                inner = False\\n            return s\\n        return 0\\n\\n    n, m, k = list(map(int, input().split()))\\n    land = [list(input()) for _ in range(n)]\\n    sav = [row[:] for row in land]\\n    lakes = []\\n    for y, row in enumerate(land):\\n        for x, f in enumerate(row):\\n            inner = True\\n            s = dfs(x, y)\\n            if s and inner:\\n                lakes.append((s, x, y))\\n    land, res = sav, 0\\n    for _, x, y in sorted(lakes)[:len(lakes) - k]:\\n        res += dfs(x, y)\\n    print(res)\\n    for row in land:\\n        print(''.join(row))\\n\\n\\ndef __starting_point():\\n    from sys import setrecursionlimit\\n\\n    setrecursionlimit(3000)\\n    main()\\n\\n__starting_point()\", \"def main():\\n    def dfs(x, y):\\n        nonlocal inner\\n        if d[x, y] == '.':\\n            d[x, y], s = '*', 1\\n            for uv in (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1):\\n                try:\\n                    s += dfs(*uv)\\n                except KeyError:\\n                    inner = False\\n            return s\\n        return 0\\n\\n    n, m, k = list(map(int, input().split()))\\n    d = {(x, y): c for y in range(n) for x, c in enumerate(input())}\\n    sav, lakes = d.copy(), []\\n    for y in range(n):\\n        for x in range(m):\\n            inner = True\\n            s = dfs(x, y)\\n            if s and inner:\\n                lakes.append((s, x, y))\\n    d, res = sav, 0\\n    for _, x, y in sorted(lakes)[:len(lakes) - k]:\\n        res += dfs(x, y)\\n    print(res)\\n    for y in range(n):\\n        print(''.join(d[x, y] for x in range(m)))\\n\\n\\ndef __starting_point():\\n    from sys import setrecursionlimit\\n\\n    setrecursionlimit(6000)\\n    main()\\n\\n__starting_point()\", \"import sys\\ndef dfs(i, j):\\n    nonlocal used, ans\\n    used[i][j] = True\\n    ans.append((i, j))\\n    if (i - 1 >= 0 and j >= 0 and not used[i - 1][j]):\\n        dfs(i - 1, j)\\n    if (i >= 0 and j + 1 <= m - 1 and not used[i][j + 1]):\\n        dfs(i, j + 1)  \\n    if (i + 1 <= n - 1 and j <= m - 1 and not used[i + 1][j]):\\n        dfs(i + 1, j)\\n    if (i <= n - 1 and j - 1 >= 0 and not used[i][j - 1]):\\n        dfs(i, j - 1)\\n\\n\\nsys.setrecursionlimit(1000000)\\nn, m, k = map(int, input().split())\\nused = [[True for i in range(m)] for j in range(n)]\\nhole = [[True for i in range(m)] for j in range(n)]\\nfor i in range(n):\\n    h = input()\\n    for j in range(m):\\n        if (h[j] == \\\".\\\"):\\n            used[i][j] = False\\n            hole[i][j] = False\\nansi = []\\nfor i in range(n):\\n    for j in range(m):\\n        ans = []\\n        if (not used[i][j]):\\n            dfs(i, j)\\n        if len(ans):\\n            f = False\\n            for elem in ans:\\n                if (not elem[0]) or (not elem[1]) or (elem[0] == n - 1) or (elem[1] == m - 1):\\n                    f = True\\n            if not f:\\n                ansl = [len(ans)] + ans\\n                ansi.append(ansl)\\nansi.sort()\\ns = 0\\nfor i in range(len(ansi) - k):\\n    s += ansi[i][0]\\n    for j in range(1, ansi[i][0] + 1):\\n        hole[ansi[i][j][0]][ansi[i][j][1]] = True\\nprint(s)\\nfor i in range(n):\\n    op = \\\"\\\"\\n    for j in range(m):\\n        if hole[i][j]:\\n            op += \\\"*\\\"\\n        else:\\n            op += \\\".\\\"\\n    print(op)\", \"from typing import List, Tuple\\n\\n\\ndef solve(n: int, m: int, k: int, chart: List[List[str]]):\\n\\n    visited = [[0] * m for _ in range(n)]\\n\\n    def dfs(x: int, y: int) -> List[Tuple[int, int]]:\\n        stack = [(x, y)]\\n        component = set([(x, y)])\\n        is_ocean = False\\n        while stack:\\n            a, b = stack.pop()\\n            visited[a][b] = 1\\n            if a == 0 or a == n - 1 or b == 0 or b == m - 1:\\n                is_ocean = True\\n            for ao, bo in [(a, b + 1), (a, b - 1), (a + 1, b), (a - 1, b)]:\\n                if 0 <= ao < n and 0 <= bo < m:\\n                    if not visited[ao][bo] and chart[ao][bo] == '.':\\n                        stack.append((ao, bo))\\n                        component.add((ao, bo))\\n        if not is_ocean:\\n            return list(component)\\n\\n    lakes = []\\n    for i in range(1, n - 1):\\n        for j in range(1, m - 1):\\n            if not visited[i][j] and chart[i][j] == '.':\\n                lake = dfs(i, j)\\n                if lake:\\n                    lakes.append(lake)\\n    changes = 0\\n    for component in sorted(lakes, key=len)[:len(lakes) - k]:\\n        for x, y in component:\\n            changes += 1\\n            chart[x][y] = '*'\\n    return changes, chart\\n\\n\\nn, m, k = list(map(int, input().split()))\\nchart = [list(input()) for _ in range(n)]\\nchanges, new_chart = solve(n, m, k, chart)\\nprint(changes)\\nfor line in new_chart:\\n    print(''.join(line))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5 4 1\\n****\\n*..*\\n****\\n**.*\\n..**\\n\",\n    \"3 3 0\\n***\\n*.*\\n***\\n\",\n    \"3 5 1\\n.**.*\\n*.*.*\\n***..\\n\",\n    \"3 5 0\\n.**.*\\n*.*.*\\n***..\\n\",\n    \"3 50 7\\n***.********.*********************.**********.****\\n*...**..*.**.*.*.*.*.*.*.*..*.*.*.*.*.*.*.*.*.*..*\\n****************.*.********.**********************\\n\",\n    \"50 3 4\\n***\\n*.*\\n*.*\\n*.*\\n***\\n***\\n*.*\\n***\\n.**\\n***\\n..*\\n***\\n***\\n*.*\\n***\\n*.*\\n***\\n***\\n*.*\\n***\\n*.*\\n*.*\\n*.*\\n*.*\\n***\\n*.*\\n*.*\\n*.*\\n*.*\\n***\\n***\\n*.*\\n*.*\\n*.*\\n*.*\\n*.*\\n***\\n***\\n***\\n*.*\\n***\\n***\\n***\\n*.*\\n*.*\\n*.*\\n***\\n***\\n***\\n***\\n\",\n    \"1 1 0\\n.\\n\",\n    \"1 1 0\\n*\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n****\\n*..*\\n****\\n****\\n..**\\n\",\n    \"1\\n***\\n***\\n***\\n\",\n    \"0\\n.**.*\\n*.*.*\\n***..\\n\",\n    \"1\\n.**.*\\n***.*\\n***..\\n\",\n    \"8\\n***.********.*********************.**********.****\\n*...**..****.***.*.*******..*******.*.*.*.*.*.*..*\\n****************.*.********.**********************\\n\",\n    \"8\\n***\\n***\\n***\\n***\\n***\\n***\\n***\\n***\\n.**\\n***\\n..*\\n***\\n***\\n***\\n***\\n***\\n***\\n***\\n***\\n***\\n*.*\\n*.*\\n*.*\\n*.*\\n***\\n*.*\\n*.*\\n*.*\\n*.*\\n***\\n***\\n*.*\\n*.*\\n*.*\\n*.*\\n*.*\\n***\\n***\\n***\\n***\\n***\\n***\\n***\\n*.*\\n*.*\\n*.*\\n***\\n***\\n***\\n***\\n\",\n    \"0\\n.\\n\",\n    \"0\\n*\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/723/D", "starter_code": ""}
{"id": 2671, "question": "Andy got a box of candies for Christmas. In fact, he discovered that the box contained several identical smaller boxes, and they could contain even smaller boxes, and so on. Formally, we say that candies are boxes of level 0, and for 1 \u2264 i \u2264 n, a level i box contains ai boxes of level i\u2009-\u20091. The largest box has level n. Andy realized that it can take quite a long time to open all the boxes before he actually gets to eat some candies, so he put the box aside in frustration.\n\nBut today being his birthday, some friends came to visit Andy, and Andy decided to share some candies with them. In order to do that, he must open some of the boxes. Naturally, Andy can not open a box that is still inside an unopened box. If Andy wants to retrieve X candies, what is the least number of boxes he must open? You must help him answer many such queries. Each query is independent.\n\n-----Input-----\n- The first line contains two integers n and m, which refer to the level of the largest box, and the number of queries respectively.\n- The second line contains n integers a1,\u2009...,\u2009an.\n- The third line contains m integers X1,\u2009...,\u2009Xm.\n\n-----Output-----\n- Print m integers each in a new line, ith of them equal to the smallest number of boxes Andy must open in order to retrieve at least Xi candies.\n\n-----Constraints-----\n- 1\u2009\u2264\u2009n,m\u2009\u2264\u2009300000\n- 1\u2009\u2264\u2009ai\u2009\u2264\u2009109\n- 1\u2009\u2264\u2009Xi\u2009\u2264\u20091012\n- It is guaranteed that the total number of candies is at least Xi for all i\n\n-----Example-----\nInput 1:\n5 1\n1 1 1 1 1\n1\n\nOutput 1:\n5\n\nInput 2:\n3 3\n3 3 3\n2 8 13\n\nOutput 2:\n3\n5\n8\n\n-----Explanation-----\nTestcase 1: The only candy is contained in five levels of boxes. \nTestcase 2: In the third query, for 13 candies, Andy should open the largest box, two level-2 boxes, and finally five of six available level-1 boxes. Each of those boxes will contain 3 level-0 boxes (which are candies). So he'll have 15 candies in total, but he needs only 13 of them.", "solutions": "[\"n,m = map(int,input().split())\\nbox = list(map(int,input().split()))\\nmularr = []\\nqueries = list(map(int,input().split()))\\nqm = max(queries)\\ncnt = 0\\nmularr.append([box[0],1])\\ncandy = box[0]\\nfor b in box[1:]:\\n    if b == 1:\\n     mularr[-1][1] +=1\\n    else:\\n     candy *= b\\n     mularr.append([candy,1])\\n    if qm <= candy:\\n     break\\n#print(mularr)\\nfor query in queries:\\n    cnt = n\\n    test = query\\n    test-=1\\n    for k,v in mularr:\\n     #print(mularr[m],test)\\n     add = (test//k)*v\\n     cnt+=add\\n    print(cnt)\"]", "input_output": "{\"inputs\": [[\"5 1\", \"1 1 1 1 1\", \"1\"], [\"3 3\", \"3 3 3\", \"2 8 13\"]], \"outputs\": [[\"5\"], [\"3\", \"5\", \"8\"]]}", "difficulty": "interview", "url": "https://www.codechef.com/problems/AMBOXES", "starter_code": ""}
{"id": 2084, "question": "The marmots have prepared a very easy problem for this year's HC^2 \u2013 this one. It involves numbers n, k and a sequence of n positive integers a_1, a_2, ..., a_{n}. They also came up with a beautiful and riveting story for the problem statement. It explains what the input means, what the program should output, and it also reads like a good criminal.\n\nHowever I, Heidi, will have none of that. As my joke for today, I am removing the story from the statement and replacing it with these two unhelpful paragraphs. Now solve the problem, fools!\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n and k (1 \u2264 k \u2264 n \u2264 2200). The second line contains n space-separated integers a_1, ..., a_{n} (1 \u2264 a_{i} \u2264 10^4).\n\n\n-----Output-----\n\nOutput one number.\n\n\n-----Examples-----\nInput\n8 5\n1 1 1 1 1 1 1 1\n\nOutput\n5\nInput\n10 3\n16 8 2 4 512 256 32 128 64 1\n\nOutput\n7\nInput\n5 1\n20 10 50 30 46\n\nOutput\n10\nInput\n6 6\n6 6 6 6 6 6\n\nOutput\n36\nInput\n1 1\n100\n\nOutput\n100", "solutions": "[\"import sys\\n\\nn_k = [int(x) for x in sys.stdin.readline().split()]\\nk = n_k[1]\\na = [int(x) for x in sys.stdin.readline().split()]\\n\\n# sum of k smallest numbers\\na = sorted(a)\\nk_smallest = sum(a[:k])\\n\\nprint(k_smallest)\\n\", \"import sys\\n\\ndef solve():\\n    n, k = map(int, input().split())\\n    a = [int(i) for i in input().split()]\\n    a.sort()\\n    ans = sum(a[:k])\\n    print(ans)\\n    \\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"n, k = [int(i) for i in input().split()]\\na = [int(i) for i in input().split()]\\na = sorted(a)\\nans = sum(a[:k])\\nprint(ans)\\n\\n\", \"n, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\na.sort()\\no = 0\\nfor i in range(m):\\n    o += a[i]\\nprint(o)\\n\", \"n,k = (int(x) for x in input().split(' '))\\na = [int(x) for x in input().split(' ')]\\na.sort()\\nans = sum(a[0:k])\\nprint(ans)\", \"n,k=input().strip().split(' ')\\nn,k=(int(n),int(k))\\nl=list(map(int,input().strip().split(' ')))\\nl.sort()\\nprint(sum(l[:min(k,n)]))\", \"n, k = [int(i) for i in input().split()]\\na = [int(i) for i in input().split()]\\na.sort()\\ns = 0\\n\\nfor i in range(k):\\n    s += a[i]\\n\\nprint(s)\\n\", \"n, k=map (int, input (). split ()) \\na=list (map (int, input (). split ())) \\na=sorted (a) \\nans=0\\nfor i in range (min(k, n) ):\\n    ans+=a[i] \\nprint (ans) \", \"n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\na.sort()\\nprint(sum(a[:k]))\\n\", \"nAndk = input().split()\\nn, k = [int(i) for i in nAndk]\\n\\ninp = input().split()\\nnum = [int(i) for i in inp]\\nnum.sort()\\n\\nans = num[:k]\\nprint (sum(ans))\", \"# -*-coding: utf-8 -*-\\n\\n# Inicio del Programa\\nn, k = [int(x) for x in input().split()]\\nnumeros = [int(x) for x in input().split()]\\n\\nnumeros.sort()\\nsuma = sum(numeros[:k])\\nprint(suma)\\n\", \"n,k=list(map(int, input().split()))\\na=sorted([int(i) for i in input().split()])\\ns=0\\nfor i in range(k):\\n    s+=a[i]\\nprint(s)\\n\\n\", \"# -*-coding: utf-8 -*-\\nfrom sys import stdin\\nfor line in stdin:\\n    entrada = line.splitlines()\\n    break\\nn=int(entrada[0].split()[0])\\nk=int(entrada[0].split()[1])\\nnumeros = [int(x) for x in input().split()]\\nnumeros.sort()\\nsuma = sum(numeros[:k])\\nprint(suma)\\n\", \"# -*- coding: utf-8 -*-\\nfrom sys import stdin\\nentrada=0\\n\\nsumatotal=0\\n\\n\\nfor line in stdin:\\n    linea1 = line.splitlines()\\n    break\\n\\n\\na = int(linea1[0].split()[0])\\nb = int(linea1[0].split()[1])\\n\\narreglo=[]\\n\\nfor x in input().split():\\n\\tarreglo.append(int(x))\\n\\n\\n\\n\\narreglo.sort();\\nsumatotal=sum(arreglo[:b])\\n   \\n\\nprint(sumatotal)\", \"n, k = map(int, input().split())\\na = sorted(list(map(int, input().split())))\\nprint (sum(a[:k]))\", \"R=lambda:list(map(int,input().split()))\\nn,k=R()\\nprint(sum(sorted(R())[:k]))\\n\", \"n, k = map(int, input().split())\\na = sorted(list(map(int, input().split())))\\nprint(sum(a[:k]))\", \"n,k=map(int,input().split())\\nprint(sum(sorted(list(map(int,input().split())))[:k]))\", \"3\\nn,k = list(map(int, input().split(' ')))\\na = list(map(int, input().split(' ')))\\n\\na.sort()\\nprint(sum(a[i] for i in range(k)))\\n\", \"n, k = map(int, input().split())\\na = list(map(int, input().split()))\\nprint(sum(sorted(a)[:k]))\", \"n,k=input().split()\\nk=int(k)\\nl=list(map(int,input().split()))\\nl.sort()\\nsum=0\\nfor i in range(0,k):\\n    sum+=l[i]\\nprint(sum)\", \"n,k=map(int,input().split())\\nprint(sum(sorted(list(map(int,input().split())))[:k]))\", \"a,b=input().strip().split(' ')\\na,b=int(a),int(b)\\nl=list(map(int,input().strip().split(' ')))\\nl=sorted(l)\\nprint(sum(l[:b]))\", \"R=lambda:list(map(int,input().split()))\\nn,k=R()\\nprint(sum(sorted(R())[:k]))\", \"#!/usr/bin/env python3\\n\\nfirstLine = [int(x) for x in input().split()]\\nsecondLine = [int(x) for x in input().split()]\\n\\nprint(sum(sorted(secondLine)[:firstLine[1]]))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"8 5\\n1 1 1 1 1 1 1 1\\n\",\n    \"10 3\\n16 8 2 4 512 256 32 128 64 1\\n\",\n    \"5 1\\n20 10 50 30 46\\n\",\n    \"6 6\\n6 6 6 6 6 6\\n\",\n    \"1 1\\n100\\n\",\n    \"1 1\\n1\\n\",\n    \"10 5\\n147 1917 5539 7159 5763 416 711 1412 6733 4402\\n\",\n    \"100 60\\n1443 3849 6174 8249 696 8715 3461 9159 4468 2496 3044 2301 2437 7559 7235 7956 8959 2036 4399 9595 8664 9743 7688 3730 3705 1203 9332 7088 8563 3823 2794 8014 6951 1160 8616 970 9885 2421 6510 4885 5246 6146 8849 5141 8602 9486 7257 3300 8323 4797 4082 7135 80 9622 4543 6567 2747 5013 4626 9091 9028 9851 1654 7021 6843 3209 5350 3809 4697 4617 4450 81 5208 1877 2897 6115 3191 2878 9258 2849 8103 6678 8714 8024 80 9894 321 8074 6797 457 1348 8652 811 7215 4381 5000 7406 7899 9974 844\\n\"\n  ],\n  \"outputs\": [\n    \"5\",\n    \"7\",\n    \"10\",\n    \"36\",\n    \"100\",\n    \"1\",\n    \"4603\",\n    \"206735\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/802/M", "starter_code": ""}
{"id": 1163, "question": "There are n boys and m girls studying in the class. They should stand in a line so that boys and girls alternated there as much as possible. Let's assume that positions in the line are indexed from left to right by numbers from 1 to n + m. Then the number of integers i (1 \u2264 i < n + m) such that positions with indexes i and i + 1 contain children of different genders (position i has a girl and position i + 1 has a boy or vice versa) must be as large as possible. \n\nHelp the children and tell them how to form the line.\n\n\n-----Input-----\n\nThe single line of the input contains two integers n and m (1 \u2264 n, m \u2264 100), separated by a space.\n\n\n-----Output-----\n\nPrint a line of n + m characters. Print on the i-th position of the line character \"B\", if the i-th position of your arrangement should have a boy and \"G\", if it should have a girl. \n\nOf course, the number of characters \"B\" should equal n and the number of characters \"G\" should equal m. If there are multiple optimal solutions, print any of them.\n\n\n-----Examples-----\nInput\n3 3\n\nOutput\nGBGBGB\n\nInput\n4 2\n\nOutput\nBGBGBB\n\n\n\n-----Note-----\n\nIn the first sample another possible answer is BGBGBG. \n\nIn the second sample answer BBGBGB is also optimal.", "solutions": "[\"from itertools import *\\n\\ninStr=next(open('input.txt'))\\nn=int(inStr.split()[0])\\nm=int(inStr.split()[1])\\n\\n\\nboys=repeat('B', n)\\ngirls=repeat('G', m)\\n\\nif n>m:\\n    pairs = zip_longest(boys, girls)\\nelse:\\n    pairs = zip_longest(girls, boys)\\nresult = (y for x in pairs for y in x if y is not None)\\nans = ''.join(result)\\nopen('output.txt', 'w').write(ans)\\nprint(ans)\"]", "input_output": "{\n  \"inputs\": [\n    \"3 3\\n\",\n    \"4 2\\n\",\n    \"5 5\\n\",\n    \"6 4\\n\",\n    \"100 1\\n\",\n    \"76 48\\n\",\n    \"100 90\\n\",\n    \"90 100\\n\",\n    \"1 98\\n\",\n    \"1 100\\n\",\n    \"56 98\\n\",\n    \"89 89\\n\",\n    \"18 94\\n\",\n    \"84 27\\n\",\n    \"1 1\\n\",\n    \"1 2\\n\",\n    \"2 1\\n\",\n    \"1 34\\n\",\n    \"46 2\\n\",\n    \"99 3\\n\",\n    \"10 100\\n\",\n    \"100 100\\n\",\n    \"1 4\\n\"\n  ],\n  \"outputs\": [\n    \"GBGBGB\\n\",\n    \"BGBGBB\\n\",\n    \"GBGBGBGBGB\\n\",\n    \"BGBGBGBGBB\\n\",\n    \"BGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n\",\n    \"BGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n\",\n    \"BGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBBBBBBBBBB\\n\",\n    \"GBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGGGGGGGGGG\\n\",\n    \"GBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG\\n\",\n    \"GBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG\\n\",\n    \"GBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG\\n\",\n    \"GBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGB\\n\",\n    \"GBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG\\n\",\n    \"BGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n\",\n    \"GB\\n\",\n    \"GBG\\n\",\n    \"BGB\\n\",\n    \"GBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG\\n\",\n    \"BGBGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n\",\n    \"BGBGBGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n\",\n    \"GBGBGBGBGBGBGBGBGBGBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG\\n\",\n    \"GBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGB\\n\",\n    \"GBGGG\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/253/A", "starter_code": ""}
{"id": 2042, "question": "Igor is in the museum and he wants to see as many pictures as possible.\n\nMuseum can be represented as a rectangular field of n \u00d7 m cells. Each cell is either empty or impassable. Empty cells are marked with '.', impassable cells are marked with '*'. Every two adjacent cells of different types (one empty and one impassable) are divided by a wall containing one picture.\n\nAt the beginning Igor is in some empty cell. At every moment he can move to any empty cell that share a side with the current one.\n\nFor several starting positions you should calculate the maximum number of pictures that Igor can see. Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture. Igor have a lot of time, so he will examine every picture he can see.\n\n\n-----Input-----\n\nFirst line of the input contains three integers n, m and k (3 \u2264 n, m \u2264 1000, 1 \u2264 k \u2264 min(n\u00b7m, 100 000))\u00a0\u2014 the museum dimensions and the number of starting positions to process.\n\nEach of the next n lines contains m symbols '.', '*' \u2014 the description of the museum. It is guaranteed that all border cells are impassable, so Igor can't go out from the museum.\n\nEach of the last k lines contains two integers x and y (1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m)\u00a0\u2014 the row and the column of one of Igor's starting positions respectively. Rows are numbered from top to bottom, columns \u2014 from left to right. It is guaranteed that all starting positions are empty cells.\n\n\n-----Output-----\n\nPrint k integers\u00a0\u2014 the maximum number of pictures, that Igor can see if he starts in corresponding position.\n\n\n-----Examples-----\nInput\n5 6 3\n******\n*..*.*\n******\n*....*\n******\n2 2\n2 5\n4 3\n\nOutput\n6\n4\n10\n\nInput\n4 4 1\n****\n*..*\n*.**\n****\n3 2\n\nOutput\n8", "solutions": "[\"#!/usr/bin/env python3\\n# 598D_Igor.py - Codeforces.com/problemset/problem/598/D by Sergey 2015\\n\\nimport unittest\\nimport sys\\nfrom collections import deque\\n\\n###############################################################################\\n# Igor Class (Main Program)\\n###############################################################################\\n\\n\\ndef empty_around(i, rc, n, m, nw, mw):\\n    w = 32\\n    r = (i // m) // w\\n    c = (i % m) // w\\n    j = r * mw + c\\n    if j < len(rc):\\n        if rc[j] == 0:\\n            rc[j] = 1\\n            return True, r, c\\n    return False, 0, 0\\n\\n\\ndef fill_around(a, r0, c0, to_visit, visited, n, m):\\n    w = 32\\n    for r in range(w):\\n        for c in range(w):\\n            i = (r0 * w + r) * m + (c0 * w + c)\\n            if (r == 0 or r == w - 1 or c == 0 or c == w - 1):\\n                if a[i] == 0:\\n                    to_visit.append(i)\\n                    a[i] = 1\\n            else:\\n                a[i] = 2\\n                visited.append(i)\\n\\n\\nclass Igor:\\n    \\\"\\\"\\\" Igor representation \\\"\\\"\\\"\\n\\n    def __init__(self, test_inputs=None):\\n        \\\"\\\"\\\" Default constructor \\\"\\\"\\\"\\n\\n        it = iter(test_inputs.split(\\\"\\\\n\\\")) if test_inputs else None\\n\\n        def uinput():\\n            return next(it) if it else sys.stdin.readline().rstrip()\\n\\n        self.result = []\\n        w = 32\\n        n, m, k = [int(x) for x in uinput().split()]\\n        d0, d1, d2, d3 = -m, 2*m, -m-1, 2\\n        a = []\\n        rc = []\\n        rr = []\\n        mw = m // w\\n        nw = n // w\\n        for _ in range(n):\\n            row = [(0 if v == '.' else 3) for v in uinput()]\\n            a += row\\n            rc += [sum(row[i*w:i*w+w]) for i in range(mw)]\\n        for i in range(nw):\\n            j = i*mw*w\\n            rr += [sum([rc[j+u*mw+v] for u in range(w)]) for v in range(mw)]\\n        to_visit = deque()\\n        for _ in range(k):\\n            x0, y0 = [int(x)-1 for x in uinput().split()]\\n            i0 = x0*m+y0\\n            step = 0\\n            if a[i0] > 3:\\n                self.result.append(a[i0])\\n            else:\\n                ans = 0\\n                to_visit.append(i0)\\n                visited = deque()\\n                step += 1\\n                while to_visit:\\n                    i = to_visit.pop()\\n                    if a[i] == 2:\\n                        continue\\n                    visited.append(i)\\n                    if step % w == 1:\\n                        e, r0, c0 = empty_around(i, rr, n, m, nw, mw)\\n                    else:\\n                        e = False\\n                    a[i] = 2\\n                    if e:\\n                        fill_around(a, r0, c0, to_visit, visited, n, m)\\n                    for d in (d0, d1, d2, d3):\\n                        i += d\\n                        if a[i] == 0:\\n                            to_visit.append(i)\\n                            a[i] = 1\\n                        elif a[i] == 3:\\n                            ans += 1\\n                self.result.append(ans)\\n                for i in visited:\\n                    a[i] = ans\\n\\n    def calculate(self):\\n        \\\"\\\"\\\" Main calcualtion function of the class \\\"\\\"\\\"\\n\\n        return str(\\\"\\\\n\\\".join(map(str, self.result)))\\n\\n###############################################################################\\n# Unit Tests\\n###############################################################################\\n\\n\\nclass unitTests(unittest.TestCase):\\n\\n    def test_single_test(self):\\n        \\\"\\\"\\\" Igor class testing \\\"\\\"\\\"\\n\\n        # Constructor test\\n        test = \\\"5 6 3\\\\n******\\\\n*..*.*\\\\n******\\\\n*....*\\\\n******\\\\n2 2\\\\n2 5\\\\n4 3\\\"\\n        d = Igor(test)\\n\\n        # Sample test\\n        self.assertEqual(Igor(test).calculate(), \\\"6\\\\n4\\\\n10\\\")\\n\\n        # Sample test\\n        test = \\\"\\\"\\n        # self.assertEqual(Igor(test).calculate(), \\\"0\\\")\\n\\n        # Sample test\\n        test = \\\"\\\"\\n        # self.assertEqual(Igor(test).calculate(), \\\"0\\\")\\n\\n        # My tests\\n        test = \\\"\\\"\\n        # self.assertEqual(Igor(test).calculate(), \\\"0\\\")\\n\\n        # Time limit test\\n        # self.time_limit_test(5000)\\n\\n    def time_limit_test(self, nmax):\\n        \\\"\\\"\\\" Timelimit testing \\\"\\\"\\\"\\n        import random\\n        import timeit\\n\\n        # Random inputs\\n        test = str(nmax) + \\\" \\\" + str(nmax) + \\\"\\\\n\\\"\\n        numnums = [str(i) + \\\" \\\" + str(i+1) for i in range(nmax)]\\n        test += \\\"\\\\n\\\".join(numnums) + \\\"\\\\n\\\"\\n        nums = [random.randint(1, 10000) for i in range(nmax)]\\n        test += \\\" \\\".join(map(str, nums)) + \\\"\\\\n\\\"\\n\\n        # Run the test\\n        start = timeit.default_timer()\\n        d = Igor(test)\\n        calc = timeit.default_timer()\\n        d.calculate()\\n        stop = timeit.default_timer()\\n        print((\\\"\\\\nTimelimit Test: \\\" +\\n              \\\"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\\\".\\n              format(stop-start, calc-start, stop-calc)))\\n\\ndef __starting_point():\\n\\n    # Avoiding recursion limitaions\\n    sys.setrecursionlimit(100000)\\n\\n    if sys.argv[-1] == \\\"-ut\\\":\\n        unittest.main(argv=[\\\" \\\"])\\n\\n    # Print the result string\\n    sys.stdout.write(Igor().calculate())\\n\\n__starting_point()\", \"import sys\\nfrom queue import deque\\n\\n# sys.stdin = open('ivo.in')\\n\\nmove = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\nn, m, k = map(int, sys.stdin.readline().split())\\n\\na = []\\nfor i in range(n):\\n    a.append(sys.stdin.readline().rstrip())\\n\\n\\nvisited = []\\nvalues = []\\nfor x in range(n):\\n    visited.append([])\\n    values.append([])\\n    for y in range(m):\\n        visited[x].append(False)\\n        values[x].append(0)\\n\\n\\nfor x in range(n):\\n    for y in range(m):\\n        if a[x][y] == '*' or visited[x][y]:\\n            continue\\n        q = deque()\\n        visited[x][y] = True\\n        q.append((x, y))\\n        sum = 0\\n        connected = [(x, y)]\\n        while len(q) != 0:\\n            cur = q.pop()\\n            for l in move:\\n                tx = cur[0] + l[0]\\n                ty = cur[1] + l[1]\\n                if tx < 0 or tx >= n or ty < 0 or ty >= m:\\n                    continue\\n                if a[tx][ty] == '.' and visited[tx][ty]:\\n                    continue\\n                if a[tx][ty] == '*':\\n                    sum += 1\\n                    continue\\n                q.append((tx, ty))\\n                visited[tx][ty] = True\\n                connected.append((tx, ty))\\n        for c in connected:\\n            values[c[0]][c[1]] = sum\\n\\nfor i in range(k):\\n    x, y = map(int, sys.stdin.readline().split())\\n    print(values[x - 1][y - 1])\", \"import sys\\n \\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\\ndef get_ints(): return map(int, sys.stdin.readline().split())\\ndef input(): return sys.stdin.readline().strip('\\\\n')\\n \\n \\nvisited = []\\nout = []\\n \\nfor i in range(1010):\\n    visited.append([])\\n    out.append([])\\n    for j in range(1010):\\n        visited[i].append(0)\\n        out[i].append(-1)\\n\\n\\ndef dfs(x,y):\\n    cells = []\\n    c = 0\\n    Q = [(x,y)]\\n    while Q:\\n        x,y = Q.pop()\\n        if x >= n or x < 0 or y >= m or y < 0:\\n            return\\n        if l[x][y] == '*':\\n            c += 1\\n            continue\\n        if visited[x][y] :\\n           continue\\n        visited[x][y] = 1\\n        cells.append((x,y))\\n        Q.append((x+1,y))\\n        Q.append((x-1,y))\\n        Q.append((x,y+1))\\n        Q.append((x,y-1))\\n    \\n    for x in cells:\\n        if visited[x[0]][x[1]] and out[x[0]][x[1]] == -1:\\n            out[x[0]][x[1]] = c\\n \\nn , m , k = get_ints()\\nl = []\\nfor i in range(n):\\n    l.append(input())\\n \\nfor i in range(n):\\n    for j in range(m):\\n        if not visited[i][j] and l[i][j] == '.':\\n            dfs(i,j)\\n            \\nfor i in range(k):\\n    x , y = get_ints()\\n    x , y = x-1 , y-1\\n    ans = out[x][y]\\n    print(ans)\", \"import sys\\n\\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\\ndef get_ints(): return map(int, sys.stdin.readline().split())\\ndef input(): return sys.stdin.readline().strip('\\\\n')\\n\\nvisited = []\\nout = []\\n\\nfor i in range(1010):\\n    visited.append([])\\n    out.append([])\\n    for j in range(1010):\\n        visited[i].append(0)\\n        out[i].append(-1)\\ncells = []\\ndef dfs(x,y):\\n    nonlocal c\\n    Q = [(x,y)]\\n    while Q:\\n        x,y = Q.pop()\\n        if x >= n or x < 0 or y >= m or y < 0:\\n            continue\\n        if l[x][y] == '*':\\n            c += 1\\n            continue\\n        if visited[x][y] :\\n            continue\\n        visited[x][y] = 1\\n        cells.append((x,y))\\n        Q.append((x+1,y))\\n        Q.append((x,y+1))\\n        Q.append((x-1,y))\\n        Q.append((x,y-1))\\n\\nn , m , k = get_ints()\\nl = []\\nfor i in range(n):\\n    l.append(list(input()))\\n\\nfor i in range(n):\\n    for j in range(m):\\n        if not visited[i][j] and l[i][j] == '.':\\n            c = 0\\n            dfs(i,j)\\n            for x in cells:\\n                if visited[x[0]][x[1]] and out[x[0]][x[1]] == -1:\\n                    out[x[0]][x[1]] = c\\n            cells.clear()\\nfor i in range(k):\\n    x , y = get_ints()\\n    x , y = x-1 , y-1\\n    ans = out[x][y]\\n    print(ans)\", \"import sys\\n\\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\\ndef input(): return sys.stdin.readline().strip('\\\\n')\\n\\ncells = []\\n\\n''' Using pajenegod dfs '''\\ndef dfs(x,y):\\n    nonlocal c\\n    q = [(x,y)]\\n\\n    while q:\\n        x, y = q.pop()\\n        if x >= n or x < 0 or y >= m or y < 0:\\n            continue\\n        if l[x][y] == '*':\\n            c += 1\\n            continue\\n        if visited[x][y]:\\n            continue\\n        \\n        visited[x][y] = 1\\n        cells.append((x,y))\\n        q.append((x+1,y))\\n        q.append((x,y+1))\\n        q.append((x-1,y))\\n        q.append((x,y-1))\\n\\nn , m , k = get_ints()\\nl = []\\nfor i in range(n):\\n    l.append(list(input()))\\n\\nvisited = []\\nout = []\\n\\nfor i in range(n+10):\\n    visited.append([0]*(m+10))\\n    out.append([-1]*(m+10))\\n    \\nfor i in range(n):\\n    for j in range(m):\\n        if not visited[i][j] and l[i][j] == '.':\\n            c = 0\\n            dfs(i,j)\\n            for x in cells:\\n                if visited[x[0]][x[1]] and out[x[0]][x[1]] == -1:\\n                    out[x[0]][x[1]] = c\\n            cells.clear()\\nfor i in range(k):\\n    x , y = get_ints()\\n    x , y = x-1 , y-1\\n    print(out[x][y])\\n\", \"import sys\\n\\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\\ndef input(): return sys.stdin.readline().strip('\\\\n')\\n\\ncells = []\\n\\n''' Using Pajenegod's dfs '''\\ndef dfs(x,y):\\n    nonlocal c\\n    q = [(x,y)]\\n\\n    while q:\\n        x, y = q.pop()\\n        if x >= n or x < 0 or y >= m or y < 0:\\n            continue\\n        if l[x][y] == '*':\\n            c += 1\\n            continue\\n        if visited[x][y]:\\n            continue\\n        \\n        visited[x][y] = 1\\n        cells.append((x,y))\\n        q.append((x+1,y))\\n        q.append((x,y+1))\\n        q.append((x-1,y))\\n        q.append((x,y-1))\\n\\nn , m , k = get_ints()\\nl = []\\nfor i in range(n):\\n    l.append(list(input()))\\n\\nvisited = []\\nout = []\\n\\nfor i in range(n+10):\\n    visited.append([0]*(m+10))\\n    out.append([-1]*(m+10))\\n    \\nfor i in range(n):\\n    for j in range(m):\\n        if not visited[i][j] and l[i][j] == '.':\\n            c = 0\\n            dfs(i,j)\\n            for x in cells:\\n                if visited[x[0]][x[1]] and out[x[0]][x[1]] == -1:\\n                    out[x[0]][x[1]] = c\\n            cells.clear()\\nfor i in range(k):\\n    x , y = get_ints()\\n    x , y = x-1 , y-1\\n    print(out[x][y])\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5 6 3\\n******\\n*..*.*\\n******\\n*....*\\n******\\n2 2\\n2 5\\n4 3\\n\",\n    \"4 4 1\\n****\\n*..*\\n*.**\\n****\\n3 2\\n\",\n    \"3 3 1\\n***\\n*.*\\n***\\n2 2\\n\",\n    \"5 5 10\\n*****\\n*...*\\n*..**\\n*.***\\n*****\\n2 4\\n4 2\\n2 2\\n2 3\\n2 2\\n2 2\\n2 4\\n3 2\\n2 2\\n2 2\\n\",\n    \"10 3 10\\n***\\n*.*\\n*.*\\n***\\n***\\n*.*\\n*.*\\n*.*\\n*.*\\n***\\n2 2\\n2 2\\n2 2\\n2 2\\n8 2\\n2 2\\n2 2\\n7 2\\n8 2\\n6 2\\n\",\n    \"3 10 10\\n**********\\n***.*.*..*\\n**********\\n2 6\\n2 6\\n2 9\\n2 9\\n2 4\\n2 9\\n2 6\\n2 6\\n2 4\\n2 6\\n\",\n    \"10 10 50\\n**********\\n*......***\\n***..**..*\\n***....***\\n**..***..*\\n**..**.*.*\\n*****..***\\n*.***..***\\n*..****.**\\n**********\\n5 9\\n5 9\\n7 7\\n6 4\\n6 7\\n8 7\\n6 7\\n9 2\\n3 9\\n9 2\\n4 7\\n4 6\\n2 7\\n9 2\\n7 7\\n5 8\\n8 7\\n8 6\\n7 7\\n5 9\\n8 7\\n3 8\\n3 8\\n5 9\\n9 8\\n9 3\\n8 7\\n5 9\\n9 2\\n9 8\\n9 3\\n3 8\\n9 2\\n8 6\\n2 4\\n6 9\\n6 3\\n9 8\\n3 9\\n9 8\\n4 5\\n8 6\\n3 8\\n5 9\\n8 7\\n5 8\\n6 9\\n8 2\\n3 9\\n3 9\\n\",\n    \"5 5 21\\n*****\\n*.***\\n*****\\n*****\\n*****\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n\"\n  ],\n  \"outputs\": [\n    \"6\\n4\\n10\\n\",\n    \"8\\n\",\n    \"4\\n\",\n    \"12\\n12\\n12\\n12\\n12\\n12\\n12\\n12\\n12\\n12\\n\",\n    \"6\\n6\\n6\\n6\\n10\\n6\\n6\\n10\\n10\\n10\\n\",\n    \"4\\n4\\n6\\n6\\n4\\n6\\n4\\n4\\n4\\n4\\n\",\n    \"8\\n8\\n10\\n28\\n10\\n10\\n10\\n8\\n6\\n8\\n28\\n28\\n28\\n8\\n10\\n8\\n10\\n10\\n10\\n8\\n10\\n6\\n6\\n8\\n4\\n8\\n10\\n8\\n8\\n4\\n8\\n6\\n8\\n10\\n28\\n8\\n28\\n4\\n6\\n4\\n28\\n10\\n6\\n8\\n10\\n8\\n8\\n8\\n6\\n6\\n\",\n    \"4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/598/D", "starter_code": ""}
